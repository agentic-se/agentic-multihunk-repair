{
  "Math_93": {
    "buggy_hunks": {
      "0": {
        "start_line": 345,
        "end_line": 346,
        "file": "src/java/org/apache/commons/math/util/MathUtils.java",
        "code": "<START_BUG>\n        long result = Math.round(factorialDouble(n));\n        if (result == Long.MAX_VALUE) {\n<END_BUG>"
      },
      "1": {
        "start_line": 377,
        "end_line": 376,
        "file": "src/java/org/apache/commons/math/util/MathUtils.java",
        "code": "<START_BUG>\n<END_BUG>"
      },
      "2": {
        "start_line": 397,
        "end_line": 396,
        "file": "src/java/org/apache/commons/math/util/MathUtils.java",
        "code": "<START_BUG>\n<END_BUG>"
      }
    },
    "buggy_code": {
      "0": {
        "start_line": 344,
        "end_line": 351,
        "file": "src/java/org/apache/commons/math/util/MathUtils.java",
        "code": "public static long factorial(final int n) {\n        long result = Math.round(factorialDouble(n));\n        if (result == Long.MAX_VALUE) {\n            throw new ArithmeticException(\n                    \"factorial value is too large to fit in a long\");\n        }\n        return factorials[n];\n    }",
        "javadoc": "/**\n * Returns n!. Shorthand for <code>n</code> <a\n * href=\"http://mathworld.wolfram.com/Factorial.html\"> Factorial</a>, the\n * product of the numbers <code>1,...,n</code>.\n * <p>\n * <Strong>Preconditions</strong>:\n * <ul>\n * <li> <code>n >= 0</code> (otherwise\n * <code>IllegalArgumentException</code> is thrown)</li>\n * <li> The result is small enough to fit into a <code>long</code>. The\n * largest value of <code>n</code> for which <code>n!</code> <\n * Long.MAX_VALUE</code> is 20. If the computed value exceeds <code>Long.MAX_VALUE</code>\n * an <code>ArithMeticException </code> is thrown.</li>\n * </ul>\n * </p>\n *\n * @param n argument\n * @return <code>n!</code>\n * @throws ArithmeticException if the result is too large to be represented\n *         by a long integer.\n * @throws IllegalArgumentException if n < 0\n */\n"
      },
      "1": {
        "start_line": 373,
        "end_line": 378,
        "file": "src/java/org/apache/commons/math/util/MathUtils.java",
        "code": "public static double factorialDouble(final int n) {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"must have n >= 0 for n!\");\n        }\n        return Math.floor(Math.exp(factorialLog(n)) + 0.5);\n    }",
        "javadoc": "/**\n * Returns n!. Shorthand for <code>n</code> <a\n * href=\"http://mathworld.wolfram.com/Factorial.html\"> Factorial</a>, the\n * product of the numbers <code>1,...,n</code> as a <code>double</code>.\n * <p>\n * <Strong>Preconditions</strong>:\n * <ul>\n * <li> <code>n >= 0</code> (otherwise\n * <code>IllegalArgumentException</code> is thrown)</li>\n * <li> The result is small enough to fit into a <code>double</code>. The\n * largest value of <code>n</code> for which <code>n!</code> <\n * Double.MAX_VALUE</code> is 170. If the computed value exceeds\n * Double.MAX_VALUE, Double.POSITIVE_INFINITY is returned</li>\n * </ul>\n * </p>\n *\n * @param n argument\n * @return <code>n!</code>\n * @throws IllegalArgumentException if n < 0\n */\n"
      },
      "2": {
        "start_line": 393,
        "end_line": 402,
        "file": "src/java/org/apache/commons/math/util/MathUtils.java",
        "code": "public static double factorialLog(final int n) {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"must have n > 0 for n!\");\n        }\n        double logSum = 0;\n        for (int i = 2; i <= n; i++) {\n            logSum += Math.log((double)i);\n        }\n        return logSum;\n    }",
        "javadoc": "/**\n * Returns the natural logarithm of n!.\n * <p>\n * <Strong>Preconditions</strong>:\n * <ul>\n * <li> <code>n >= 0</code> (otherwise\n * <code>IllegalArgumentException</code> is thrown)</li>\n * </ul></p>\n *\n * @param n argument\n * @return <code>n!</code>\n * @throws IllegalArgumentException if preconditions are not met.\n */\n"
      }
    },
    "delineated_bug": {
      "0": {
        "start_line": 344,
        "end_line": 351,
        "file": "src/java/org/apache/commons/math/util/MathUtils.java",
        "code": "public static long factorial(final int n) {\n<START_BUG>\n        long result = Math.round(factorialDouble(n));\n        if (result == Long.MAX_VALUE) {\n<END_BUG>\n            throw new ArithmeticException(\n                    \"factorial value is too large to fit in a long\");\n        }\n        return factorials[n];\n    }",
        "javadoc": "/**\n * Returns n!. Shorthand for <code>n</code> <a\n * href=\"http://mathworld.wolfram.com/Factorial.html\"> Factorial</a>, the\n * product of the numbers <code>1,...,n</code>.\n * <p>\n * <Strong>Preconditions</strong>:\n * <ul>\n * <li> <code>n >= 0</code> (otherwise\n * <code>IllegalArgumentException</code> is thrown)</li>\n * <li> The result is small enough to fit into a <code>long</code>. The\n * largest value of <code>n</code> for which <code>n!</code> <\n * Long.MAX_VALUE</code> is 20. If the computed value exceeds <code>Long.MAX_VALUE</code>\n * an <code>ArithMeticException </code> is thrown.</li>\n * </ul>\n * </p>\n *\n * @param n argument\n * @return <code>n!</code>\n * @throws ArithmeticException if the result is too large to be represented\n *         by a long integer.\n * @throws IllegalArgumentException if n < 0\n */\n"
      },
      "1": {
        "start_line": 373,
        "end_line": 378,
        "file": "src/java/org/apache/commons/math/util/MathUtils.java",
        "code": "public static double factorialDouble(final int n) {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"must have n >= 0 for n!\");\n        }\n<END_BUG>\n<START_BUG>\n        return Math.floor(Math.exp(factorialLog(n)) + 0.5);\n    }",
        "javadoc": "/**\n * Returns n!. Shorthand for <code>n</code> <a\n * href=\"http://mathworld.wolfram.com/Factorial.html\"> Factorial</a>, the\n * product of the numbers <code>1,...,n</code> as a <code>double</code>.\n * <p>\n * <Strong>Preconditions</strong>:\n * <ul>\n * <li> <code>n >= 0</code> (otherwise\n * <code>IllegalArgumentException</code> is thrown)</li>\n * <li> The result is small enough to fit into a <code>double</code>. The\n * largest value of <code>n</code> for which <code>n!</code> <\n * Double.MAX_VALUE</code> is 170. If the computed value exceeds\n * Double.MAX_VALUE, Double.POSITIVE_INFINITY is returned</li>\n * </ul>\n * </p>\n *\n * @param n argument\n * @return <code>n!</code>\n * @throws IllegalArgumentException if n < 0\n */\n"
      },
      "2": {
        "start_line": 393,
        "end_line": 402,
        "file": "src/java/org/apache/commons/math/util/MathUtils.java",
        "code": "public static double factorialLog(final int n) {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"must have n > 0 for n!\");\n        }\n<END_BUG>\n<START_BUG>\n        double logSum = 0;\n        for (int i = 2; i <= n; i++) {\n            logSum += Math.log((double)i);\n        }\n        return logSum;\n    }",
        "javadoc": "/**\n * Returns the natural logarithm of n!.\n * <p>\n * <Strong>Preconditions</strong>:\n * <ul>\n * <li> <code>n >= 0</code> (otherwise\n * <code>IllegalArgumentException</code> is thrown)</li>\n * </ul></p>\n *\n * @param n argument\n * @return <code>n!</code>\n * @throws IllegalArgumentException if preconditions are not met.\n */\n"
      }
    },
    "contained_scope": "method",
    "bug_count": 3,
    "triggered_tests": {
      "0": {
        "test_path": "org.apache.commons.math.util.MathUtilsTest",
        "test_method": "testFactorial",
        "test_code": "testFactorial() {\n        for (int i = 1; i < 21; i++) {\n            assertEquals(i + \"! \", factorial(i), MathUtils.factorial(i));\n            assertEquals(i + \"! \", (double)factorial(i), MathUtils.factorialDouble(i), Double.MIN_VALUE);\n            assertEquals(i + \"! \", Math.log((double)factorial(i)), MathUtils.factorialLog(i), 10E-12);\n        }\n        \n        assertEquals(\"0\", 1, MathUtils.factorial(0));\n        assertEquals(\"0\", 1.0d, MathUtils.factorialDouble(0), 1E-14);\n        assertEquals(\"0\", 0.0d, MathUtils.factorialLog(0), 1E-14);\n    }",
        "clean_err_msg": "junit.framework.AssertionFailedError: 17!  expected:<3.55687428096E14> but was:<3.55687428096001E14>"
      }
    },
    "buggy_files": {
      "0": "src/java/org/apache/commons/math/util/MathUtils.java"
    },
    "hunk_type": "single_file_three_hunks",
    "hunk_mapping": {
      "0": [
        {
          "start_line": 345,
          "end_line": 346,
          "file": "src/java/org/apache/commons/math/util/MathUtils.java",
          "code": "<START_BUG>\n        long result = Math.round(factorialDouble(n));\n        if (result == Long.MAX_VALUE) {\n<END_BUG>"
        }
      ],
      "1": [
        {
          "start_line": 377,
          "end_line": 376,
          "file": "src/java/org/apache/commons/math/util/MathUtils.java",
          "code": "<START_BUG>\n<END_BUG>"
        }
      ],
      "2": [
        {
          "start_line": 397,
          "end_line": 396,
          "file": "src/java/org/apache/commons/math/util/MathUtils.java",
          "code": "<START_BUG>\n<END_BUG>"
        }
      ]
    },
    "bug_report": {
      "url": "https://issues.apache.org/jira/browse/MATH-240",
      "title": "MathUtils.factorial(n) fails for n >= 17",
      "bug_description": "The result of MathUtils.factorial( n ) for n = 17, 18, 19 is wrong, probably because of rounding errors in the double calculations.\nReplace the first line of MathUtilsTest.testFactorial() by\nfor (int i = 1; i <= 20; i++) {\nto check all valid arguments for the long result and see the failure.\nI suggest implementing a simple loop to multiply the long result - or even using a precomputed long[] - instead of adding logarithms."
    }
  },
  "Closure_75": {
    "buggy_hunks": {
      "0": {
        "start_line": 313,
        "end_line": 313,
        "file": "src/com/google/javascript/jscomp/NodeUtil.java",
        "code": "<START_BUG>\n      // vertical tab is not always whitespace\n<END_BUG>"
      },
      "1": {
        "start_line": 375,
        "end_line": 375,
        "file": "src/com/google/javascript/jscomp/NodeUtil.java",
        "code": "<START_BUG>\n        return TernaryValue.TRUE;\n<END_BUG>"
      }
    },
    "buggy_code": {
      "0": {
        "start_line": 312,
        "end_line": 353,
        "file": "src/com/google/javascript/jscomp/NodeUtil.java",
        "code": "static Double getStringNumberValue(String rawJsString) {\n      // vertical tab is not always whitespace\n\n    String s = trimJsWhiteSpace(rawJsString);\n    // return ScriptRuntime.toNumber(s);\n    if (s.length() == 0) {\n      return 0.0;\n    }\n\n    if (s.length() > 2\n        && s.charAt(0) == '0'\n        && (s.charAt(1) == 'x' || s.charAt(1) == 'X')) {\n      // Attempt to convert hex numbers.\n      try {\n        return Double.valueOf(Integer.parseInt(s.substring(2), 16));\n      } catch (NumberFormatException e) {\n        return Double.NaN;\n      }\n    }\n\n    if (s.length() > 3\n        && (s.charAt(0) == '-' || s.charAt(0) == '+')\n        && s.charAt(1) == '0'\n        && (s.charAt(2) == 'x' || s.charAt(2) == 'X')) {\n      // hex numbers with explicit signs vary between browsers.\n      return null;\n    }\n\n    // FireFox and IE treat the \"Infinity\" differently. FireFox is case\n    // insensitive, but IE treats \"infinity\" as NaN.  So leave it alone.\n    if (s.equals(\"infinity\")\n        || s.equals(\"-infinity\")\n        || s.equals(\"+infinity\")) {\n      return null;\n    }\n\n    try {\n      return Double.parseDouble(s);\n    } catch (NumberFormatException e) {\n      return Double.NaN;\n    }\n  }",
        "javadoc": ""
      },
      "1": {
        "start_line": 372,
        "end_line": 390,
        "file": "src/com/google/javascript/jscomp/NodeUtil.java",
        "code": "static TernaryValue isStrWhiteSpaceChar(int c) {\n    switch (c) {\n      case '\\u000B': // <VT>\n        return TernaryValue.TRUE;\n      case ' ': // <SP>\n      case '\\n': // <LF>\n      case '\\r': // <CR>\n      case '\\t': // <TAB>\n      case '\\u00A0': // <NBSP>\n      case '\\u000C': // <FF>\n      case '\\u2028': // <LS>\n      case '\\u2029': // <PS>\n      case '\\uFEFF': // <BOM>\n        return TernaryValue.TRUE;\n      default:\n        return (Character.getType(c) == Character.SPACE_SEPARATOR)\n            ? TernaryValue.TRUE : TernaryValue.FALSE;\n    }\n  }",
        "javadoc": "/**\n * Copied from Rhino's ScriptRuntime\n */\n"
      }
    },
    "delineated_bug": {
      "0": {
        "start_line": 312,
        "end_line": 353,
        "file": "src/com/google/javascript/jscomp/NodeUtil.java",
        "code": "static Double getStringNumberValue(String rawJsString) {\n<START_BUG>\n      // vertical tab is not always whitespace\n<END_BUG>\n\n    String s = trimJsWhiteSpace(rawJsString);\n    // return ScriptRuntime.toNumber(s);\n    if (s.length() == 0) {\n      return 0.0;\n    }\n\n    if (s.length() > 2\n        && s.charAt(0) == '0'\n        && (s.charAt(1) == 'x' || s.charAt(1) == 'X')) {\n      // Attempt to convert hex numbers.\n      try {\n        return Double.valueOf(Integer.parseInt(s.substring(2), 16));\n      } catch (NumberFormatException e) {\n        return Double.NaN;\n      }\n    }\n\n    if (s.length() > 3\n        && (s.charAt(0) == '-' || s.charAt(0) == '+')\n        && s.charAt(1) == '0'\n        && (s.charAt(2) == 'x' || s.charAt(2) == 'X')) {\n      // hex numbers with explicit signs vary between browsers.\n      return null;\n    }\n\n    // FireFox and IE treat the \"Infinity\" differently. FireFox is case\n    // insensitive, but IE treats \"infinity\" as NaN.  So leave it alone.\n    if (s.equals(\"infinity\")\n        || s.equals(\"-infinity\")\n        || s.equals(\"+infinity\")) {\n      return null;\n    }\n\n    try {\n      return Double.parseDouble(s);\n    } catch (NumberFormatException e) {\n      return Double.NaN;\n    }\n  }",
        "javadoc": ""
      },
      "1": {
        "start_line": 372,
        "end_line": 390,
        "file": "src/com/google/javascript/jscomp/NodeUtil.java",
        "code": "static TernaryValue isStrWhiteSpaceChar(int c) {\n    switch (c) {\n      case '\\u000B': // <VT>\n<START_BUG>\n        return TernaryValue.TRUE;\n<END_BUG>\n      case ' ': // <SP>\n      case '\\n': // <LF>\n      case '\\r': // <CR>\n      case '\\t': // <TAB>\n      case '\\u00A0': // <NBSP>\n      case '\\u000C': // <FF>\n      case '\\u2028': // <LS>\n      case '\\u2029': // <PS>\n      case '\\uFEFF': // <BOM>\n        return TernaryValue.TRUE;\n      default:\n        return (Character.getType(c) == Character.SPACE_SEPARATOR)\n            ? TernaryValue.TRUE : TernaryValue.FALSE;\n    }\n  }",
        "javadoc": "/**\n * Copied from Rhino's ScriptRuntime\n */\n"
      }
    },
    "contained_scope": "method",
    "bug_count": 2,
    "triggered_tests": {
      "0": {
        "test_path": "com.google.javascript.jscomp.PeepholeFoldConstantsTest",
        "test_method": "testIEString",
        "test_code": "testIEString() {\n    testSame(\"!+'\\\\v1'\");\n  }",
        "clean_err_msg": "junit.framework.AssertionFailedError: "
      }
    },
    "buggy_files": {
      "0": "src/com/google/javascript/jscomp/NodeUtil.java"
    },
    "hunk_type": "single_file_two_hunks",
    "hunk_mapping": {
      "0": [
        {
          "start_line": 313,
          "end_line": 313,
          "file": "src/com/google/javascript/jscomp/NodeUtil.java",
          "code": "<START_BUG>\n      // vertical tab is not always whitespace\n<END_BUG>"
        }
      ],
      "1": [
        {
          "start_line": 375,
          "end_line": 375,
          "file": "src/com/google/javascript/jscomp/NodeUtil.java",
          "code": "<START_BUG>\n        return TernaryValue.TRUE;\n<END_BUG>"
        }
      ]
    },
    "bug_report": {
      "url": "https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-395.json",
      "bug_description": "closure compiled swfobject error",
      "title": ""
    }
  },
  "Chart_25": {
    "buggy_hunks": {
      "0": {
        "start_line": 259,
        "end_line": 258,
        "file": "source/org/jfree/chart/renderer/category/StatisticalBarRenderer.java",
        "code": "<START_BUG>\n<END_BUG>"
      },
      "1": {
        "start_line": 315,
        "end_line": 315,
        "file": "source/org/jfree/chart/renderer/category/StatisticalBarRenderer.java",
        "code": "<START_BUG>\n            double valueDelta = dataset.getStdDevValue(row, column).doubleValue();\n<END_BUG>"
      },
      "2": {
        "start_line": 344,
        "end_line": 343,
        "file": "source/org/jfree/chart/renderer/category/StatisticalBarRenderer.java",
        "code": "<START_BUG>\n<END_BUG>"
      },
      "3": {
        "start_line": 403,
        "end_line": 402,
        "file": "source/org/jfree/chart/renderer/category/StatisticalBarRenderer.java",
        "code": "<START_BUG>\n<END_BUG>"
      },
      "4": {
        "start_line": 459,
        "end_line": 459,
        "file": "source/org/jfree/chart/renderer/category/StatisticalBarRenderer.java",
        "code": "<START_BUG>\n            double valueDelta = dataset.getStdDevValue(row, column).doubleValue();\n<END_BUG>"
      },
      "5": {
        "start_line": 487,
        "end_line": 486,
        "file": "source/org/jfree/chart/renderer/category/StatisticalBarRenderer.java",
        "code": "<START_BUG>\n<END_BUG>"
      }
    },
    "buggy_code": {
      "0": {
        "start_line": 230,
        "end_line": 358,
        "file": "source/org/jfree/chart/renderer/category/StatisticalBarRenderer.java",
        "code": "protected void drawHorizontalItem(Graphics2D g2,\n                                      CategoryItemRendererState state,\n                                      Rectangle2D dataArea,\n                                      CategoryPlot plot,\n                                      CategoryAxis domainAxis,\n                                      ValueAxis rangeAxis,\n                                      StatisticalCategoryDataset dataset,\n                                      int row,\n                                      int column) {\n                                     \n        RectangleEdge xAxisLocation = plot.getDomainAxisEdge();\n        \n        // BAR Y\n        double rectY = domainAxis.getCategoryStart(column, getColumnCount(), \n                dataArea, xAxisLocation);\n\n        int seriesCount = getRowCount();\n        int categoryCount = getColumnCount();\n        if (seriesCount > 1) {\n            double seriesGap = dataArea.getHeight() * getItemMargin()\n                               / (categoryCount * (seriesCount - 1));\n            rectY = rectY + row * (state.getBarWidth() + seriesGap);\n        }\n        else {\n            rectY = rectY + row * state.getBarWidth();\n        }\n\n        // BAR X\n        Number meanValue = dataset.getMeanValue(row, column);\n\n        double value = meanValue.doubleValue();\n        double base = 0.0;\n        double lclip = getLowerClip();\n        double uclip = getUpperClip();\n\n        if (uclip <= 0.0) {  // cases 1, 2, 3 and 4\n            if (value >= uclip) {\n                return; // bar is not visible\n            }\n            base = uclip;\n            if (value <= lclip) {\n                value = lclip;\n            }\n        }\n        else if (lclip <= 0.0) { // cases 5, 6, 7 and 8\n            if (value >= uclip) {\n                value = uclip;\n            }\n            else {\n                if (value <= lclip) {\n                    value = lclip;\n                }\n            }\n        }\n        else { // cases 9, 10, 11 and 12\n            if (value <= lclip) {\n                return; // bar is not visible\n            }\n            base = getLowerClip();\n            if (value >= uclip) {\n               value = uclip;\n            }\n        }\n\n        RectangleEdge yAxisLocation = plot.getRangeAxisEdge();\n        double transY1 = rangeAxis.valueToJava2D(base, dataArea, yAxisLocation);\n        double transY2 = rangeAxis.valueToJava2D(value, dataArea, \n                yAxisLocation);\n        double rectX = Math.min(transY2, transY1);\n\n        double rectHeight = state.getBarWidth();\n        double rectWidth = Math.abs(transY2 - transY1);\n\n        Rectangle2D bar = new Rectangle2D.Double(rectX, rectY, rectWidth, \n                rectHeight);\n        Paint seriesPaint = getItemPaint(row, column);\n        g2.setPaint(seriesPaint);\n        g2.fill(bar);\n        if (isDrawBarOutline() && state.getBarWidth() > 3) {\n            g2.setStroke(getItemStroke(row, column));\n            g2.setPaint(getItemOutlinePaint(row, column));\n            g2.draw(bar);\n        }\n\n        // standard deviation lines\n            double valueDelta = dataset.getStdDevValue(row, column).doubleValue();\n            double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() \n                    + valueDelta, dataArea, yAxisLocation);\n            double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue() \n                    - valueDelta, dataArea, yAxisLocation);\n\n            if (this.errorIndicatorStroke != null) {\n                g2.setStroke(this.errorIndicatorStroke);\n            }\n            else {\n                g2.setStroke(getItemOutlineStroke(row, column));\n            }\n            if (this.errorIndicatorPaint != null) {\n                g2.setPaint(this.errorIndicatorPaint);  \n            }\n            else {\n                g2.setPaint(getItemOutlinePaint(row, column));   \n            }\n        \n            Line2D line = null;\n            line = new Line2D.Double(lowVal, rectY + rectHeight / 2.0d, \n                                     highVal, rectY + rectHeight / 2.0d);\n            g2.draw(line);\n            line = new Line2D.Double(highVal, rectY + rectHeight * 0.25, \n                                     highVal, rectY + rectHeight * 0.75);\n            g2.draw(line);\n            line = new Line2D.Double(lowVal, rectY + rectHeight * 0.25, \n                                     lowVal, rectY + rectHeight * 0.75);\n            g2.draw(line);\n        \n        CategoryItemLabelGenerator generator = getItemLabelGenerator(row, \n                column);\n        if (generator != null && isItemLabelVisible(row, column)) {\n            drawItemLabel(g2, dataset, row, column, plot, generator, bar, \n                    (value < 0.0));\n        }        \n\n        // add an item entity, if this information is being collected\n        EntityCollection entities = state.getEntityCollection();\n        if (entities != null) {\n            addItemEntity(entities, dataset, row, column, bar);\n        }\n\n    }",
        "javadoc": "/**\n * Draws an item for a plot with a horizontal orientation.\n *\n * @param g2  the graphics device.\n * @param state  the renderer state.\n * @param dataArea  the data area.\n * @param plot  the plot.\n * @param domainAxis  the domain axis.\n * @param rangeAxis  the range axis.\n * @param dataset  the data.\n * @param row  the row index (zero-based).\n * @param column  the column index (zero-based).\n */\n"
      },
      "1": {
        "start_line": 373,
        "end_line": 500,
        "file": "source/org/jfree/chart/renderer/category/StatisticalBarRenderer.java",
        "code": "protected void drawVerticalItem(Graphics2D g2,\n                                    CategoryItemRendererState state,\n                                    Rectangle2D dataArea,\n                                    CategoryPlot plot,\n                                    CategoryAxis domainAxis,\n                                    ValueAxis rangeAxis,\n                                    StatisticalCategoryDataset dataset,\n                                    int row,\n                                    int column) {\n                                     \n        RectangleEdge xAxisLocation = plot.getDomainAxisEdge();\n        \n        // BAR X\n        double rectX = domainAxis.getCategoryStart(\n            column, getColumnCount(), dataArea, xAxisLocation\n        );\n\n        int seriesCount = getRowCount();\n        int categoryCount = getColumnCount();\n        if (seriesCount > 1) {\n            double seriesGap = dataArea.getWidth() * getItemMargin()\n                               / (categoryCount * (seriesCount - 1));\n            rectX = rectX + row * (state.getBarWidth() + seriesGap);\n        }\n        else {\n            rectX = rectX + row * state.getBarWidth();\n        }\n\n        // BAR Y\n        Number meanValue = dataset.getMeanValue(row, column);\n\n        double value = meanValue.doubleValue();\n        double base = 0.0;\n        double lclip = getLowerClip();\n        double uclip = getUpperClip();\n\n        if (uclip <= 0.0) {  // cases 1, 2, 3 and 4\n            if (value >= uclip) {\n                return; // bar is not visible\n            }\n            base = uclip;\n            if (value <= lclip) {\n                value = lclip;\n            }\n        }\n        else if (lclip <= 0.0) { // cases 5, 6, 7 and 8\n            if (value >= uclip) {\n                value = uclip;\n            }\n            else {\n                if (value <= lclip) {\n                    value = lclip;\n                }\n            }\n        }\n        else { // cases 9, 10, 11 and 12\n            if (value <= lclip) {\n                return; // bar is not visible\n            }\n            base = getLowerClip();\n            if (value >= uclip) {\n               value = uclip;\n            }\n        }\n\n        RectangleEdge yAxisLocation = plot.getRangeAxisEdge();\n        double transY1 = rangeAxis.valueToJava2D(base, dataArea, yAxisLocation);\n        double transY2 = rangeAxis.valueToJava2D(value, dataArea, \n                yAxisLocation);\n        double rectY = Math.min(transY2, transY1);\n\n        double rectWidth = state.getBarWidth();\n        double rectHeight = Math.abs(transY2 - transY1);\n\n        Rectangle2D bar = new Rectangle2D.Double(rectX, rectY, rectWidth, \n                rectHeight);\n        Paint seriesPaint = getItemPaint(row, column);\n        g2.setPaint(seriesPaint);\n        g2.fill(bar);\n        if (isDrawBarOutline() && state.getBarWidth() > 3) {\n            g2.setStroke(getItemStroke(row, column));\n            g2.setPaint(getItemOutlinePaint(row, column));\n            g2.draw(bar);\n        }\n\n        // standard deviation lines\n            double valueDelta = dataset.getStdDevValue(row, column).doubleValue();\n            double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() \n                    + valueDelta, dataArea, yAxisLocation);\n            double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue() \n                    - valueDelta, dataArea, yAxisLocation);\n\n            if (this.errorIndicatorStroke != null) {\n                g2.setStroke(this.errorIndicatorStroke);\n            }\n            else {\n                g2.setStroke(getItemOutlineStroke(row, column));\n            }\n            if (this.errorIndicatorPaint != null) {\n                g2.setPaint(this.errorIndicatorPaint);  \n            }\n            else {\n                g2.setPaint(getItemOutlinePaint(row, column));   \n            }\n            Line2D line = null;\n            line = new Line2D.Double(rectX + rectWidth / 2.0d, lowVal,\n                                     rectX + rectWidth / 2.0d, highVal);\n            g2.draw(line);\n            line = new Line2D.Double(rectX + rectWidth / 2.0d - 5.0d, highVal,\n                                     rectX + rectWidth / 2.0d + 5.0d, highVal);\n            g2.draw(line);\n            line = new Line2D.Double(rectX + rectWidth / 2.0d - 5.0d, lowVal,\n                                     rectX + rectWidth / 2.0d + 5.0d, lowVal);\n            g2.draw(line);\n        \n        CategoryItemLabelGenerator generator = getItemLabelGenerator(row, \n                column);\n        if (generator != null && isItemLabelVisible(row, column)) {\n            drawItemLabel(g2, dataset, row, column, plot, generator, bar, \n                    (value < 0.0));\n        }        \n\n        // add an item entity, if this information is being collected\n        EntityCollection entities = state.getEntityCollection();\n        if (entities != null) {\n            addItemEntity(entities, dataset, row, column, bar);\n        }\n    }",
        "javadoc": "/**\n * Draws an item for a plot with a horizontal orientation.\n *\n * @param g2  the graphics device.\n * @param state  the renderer state.\n * @param dataArea  the data area.\n * @param plot  the plot.\n * @param domainAxis  the domain axis.\n * @param rangeAxis  the range axis.\n * @param dataset  the data.\n * @param row  the row index (zero-based).\n * @param column  the column index (zero-based).\n */\n"
      }
    },
    "delineated_bug": {
      "0": {
        "start_line": 230,
        "end_line": 358,
        "file": "source/org/jfree/chart/renderer/category/StatisticalBarRenderer.java",
        "code": "protected void drawHorizontalItem(Graphics2D g2,\n                                      CategoryItemRendererState state,\n                                      Rectangle2D dataArea,\n                                      CategoryPlot plot,\n                                      CategoryAxis domainAxis,\n                                      ValueAxis rangeAxis,\n                                      StatisticalCategoryDataset dataset,\n                                      int row,\n                                      int column) {\n                                     \n        RectangleEdge xAxisLocation = plot.getDomainAxisEdge();\n        \n        // BAR Y\n        double rectY = domainAxis.getCategoryStart(column, getColumnCount(), \n                dataArea, xAxisLocation);\n\n        int seriesCount = getRowCount();\n        int categoryCount = getColumnCount();\n        if (seriesCount > 1) {\n            double seriesGap = dataArea.getHeight() * getItemMargin()\n                               / (categoryCount * (seriesCount - 1));\n            rectY = rectY + row * (state.getBarWidth() + seriesGap);\n        }\n        else {\n            rectY = rectY + row * state.getBarWidth();\n        }\n\n        // BAR X\n        Number meanValue = dataset.getMeanValue(row, column);\n<END_BUG>\n<START_BUG>\n\n        double value = meanValue.doubleValue();\n        double base = 0.0;\n        double lclip = getLowerClip();\n        double uclip = getUpperClip();\n\n        if (uclip <= 0.0) {  // cases 1, 2, 3 and 4\n            if (value >= uclip) {\n                return; // bar is not visible\n            }\n            base = uclip;\n            if (value <= lclip) {\n                value = lclip;\n            }\n        }\n        else if (lclip <= 0.0) { // cases 5, 6, 7 and 8\n            if (value >= uclip) {\n                value = uclip;\n            }\n            else {\n                if (value <= lclip) {\n                    value = lclip;\n                }\n            }\n        }\n        else { // cases 9, 10, 11 and 12\n            if (value <= lclip) {\n                return; // bar is not visible\n            }\n            base = getLowerClip();\n            if (value >= uclip) {\n               value = uclip;\n            }\n        }\n\n        RectangleEdge yAxisLocation = plot.getRangeAxisEdge();\n        double transY1 = rangeAxis.valueToJava2D(base, dataArea, yAxisLocation);\n        double transY2 = rangeAxis.valueToJava2D(value, dataArea, \n                yAxisLocation);\n        double rectX = Math.min(transY2, transY1);\n\n        double rectHeight = state.getBarWidth();\n        double rectWidth = Math.abs(transY2 - transY1);\n\n        Rectangle2D bar = new Rectangle2D.Double(rectX, rectY, rectWidth, \n                rectHeight);\n        Paint seriesPaint = getItemPaint(row, column);\n        g2.setPaint(seriesPaint);\n        g2.fill(bar);\n        if (isDrawBarOutline() && state.getBarWidth() > 3) {\n            g2.setStroke(getItemStroke(row, column));\n            g2.setPaint(getItemOutlinePaint(row, column));\n            g2.draw(bar);\n        }\n\n        // standard deviation lines\n<START_BUG>\n            double valueDelta = dataset.getStdDevValue(row, column).doubleValue();\n<END_BUG>\n            double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() \n                    + valueDelta, dataArea, yAxisLocation);\n            double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue() \n                    - valueDelta, dataArea, yAxisLocation);\n\n            if (this.errorIndicatorStroke != null) {\n                g2.setStroke(this.errorIndicatorStroke);\n            }\n            else {\n                g2.setStroke(getItemOutlineStroke(row, column));\n            }\n            if (this.errorIndicatorPaint != null) {\n                g2.setPaint(this.errorIndicatorPaint);  \n            }\n            else {\n                g2.setPaint(getItemOutlinePaint(row, column));   \n            }\n        \n            Line2D line = null;\n            line = new Line2D.Double(lowVal, rectY + rectHeight / 2.0d, \n                                     highVal, rectY + rectHeight / 2.0d);\n            g2.draw(line);\n            line = new Line2D.Double(highVal, rectY + rectHeight * 0.25, \n                                     highVal, rectY + rectHeight * 0.75);\n            g2.draw(line);\n            line = new Line2D.Double(lowVal, rectY + rectHeight * 0.25, \n                                     lowVal, rectY + rectHeight * 0.75);\n            g2.draw(line);\n<END_BUG>\n<START_BUG>\n        \n        CategoryItemLabelGenerator generator = getItemLabelGenerator(row, \n                column);\n        if (generator != null && isItemLabelVisible(row, column)) {\n            drawItemLabel(g2, dataset, row, column, plot, generator, bar, \n                    (value < 0.0));\n        }        \n\n        // add an item entity, if this information is being collected\n        EntityCollection entities = state.getEntityCollection();\n        if (entities != null) {\n            addItemEntity(entities, dataset, row, column, bar);\n        }\n\n    }",
        "javadoc": "/**\n * Draws an item for a plot with a horizontal orientation.\n *\n * @param g2  the graphics device.\n * @param state  the renderer state.\n * @param dataArea  the data area.\n * @param plot  the plot.\n * @param domainAxis  the domain axis.\n * @param rangeAxis  the range axis.\n * @param dataset  the data.\n * @param row  the row index (zero-based).\n * @param column  the column index (zero-based).\n */\n"
      },
      "1": {
        "start_line": 373,
        "end_line": 500,
        "file": "source/org/jfree/chart/renderer/category/StatisticalBarRenderer.java",
        "code": "protected void drawVerticalItem(Graphics2D g2,\n                                    CategoryItemRendererState state,\n                                    Rectangle2D dataArea,\n                                    CategoryPlot plot,\n                                    CategoryAxis domainAxis,\n                                    ValueAxis rangeAxis,\n                                    StatisticalCategoryDataset dataset,\n                                    int row,\n                                    int column) {\n                                     \n        RectangleEdge xAxisLocation = plot.getDomainAxisEdge();\n        \n        // BAR X\n        double rectX = domainAxis.getCategoryStart(\n            column, getColumnCount(), dataArea, xAxisLocation\n        );\n\n        int seriesCount = getRowCount();\n        int categoryCount = getColumnCount();\n        if (seriesCount > 1) {\n            double seriesGap = dataArea.getWidth() * getItemMargin()\n                               / (categoryCount * (seriesCount - 1));\n            rectX = rectX + row * (state.getBarWidth() + seriesGap);\n        }\n        else {\n            rectX = rectX + row * state.getBarWidth();\n        }\n\n        // BAR Y\n        Number meanValue = dataset.getMeanValue(row, column);\n<END_BUG>\n<START_BUG>\n\n        double value = meanValue.doubleValue();\n        double base = 0.0;\n        double lclip = getLowerClip();\n        double uclip = getUpperClip();\n\n        if (uclip <= 0.0) {  // cases 1, 2, 3 and 4\n            if (value >= uclip) {\n                return; // bar is not visible\n            }\n            base = uclip;\n            if (value <= lclip) {\n                value = lclip;\n            }\n        }\n        else if (lclip <= 0.0) { // cases 5, 6, 7 and 8\n            if (value >= uclip) {\n                value = uclip;\n            }\n            else {\n                if (value <= lclip) {\n                    value = lclip;\n                }\n            }\n        }\n        else { // cases 9, 10, 11 and 12\n            if (value <= lclip) {\n                return; // bar is not visible\n            }\n            base = getLowerClip();\n            if (value >= uclip) {\n               value = uclip;\n            }\n        }\n\n        RectangleEdge yAxisLocation = plot.getRangeAxisEdge();\n        double transY1 = rangeAxis.valueToJava2D(base, dataArea, yAxisLocation);\n        double transY2 = rangeAxis.valueToJava2D(value, dataArea, \n                yAxisLocation);\n        double rectY = Math.min(transY2, transY1);\n\n        double rectWidth = state.getBarWidth();\n        double rectHeight = Math.abs(transY2 - transY1);\n\n        Rectangle2D bar = new Rectangle2D.Double(rectX, rectY, rectWidth, \n                rectHeight);\n        Paint seriesPaint = getItemPaint(row, column);\n        g2.setPaint(seriesPaint);\n        g2.fill(bar);\n        if (isDrawBarOutline() && state.getBarWidth() > 3) {\n            g2.setStroke(getItemStroke(row, column));\n            g2.setPaint(getItemOutlinePaint(row, column));\n            g2.draw(bar);\n        }\n\n        // standard deviation lines\n<START_BUG>\n            double valueDelta = dataset.getStdDevValue(row, column).doubleValue();\n<END_BUG>\n            double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() \n                    + valueDelta, dataArea, yAxisLocation);\n            double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue() \n                    - valueDelta, dataArea, yAxisLocation);\n\n            if (this.errorIndicatorStroke != null) {\n                g2.setStroke(this.errorIndicatorStroke);\n            }\n            else {\n                g2.setStroke(getItemOutlineStroke(row, column));\n            }\n            if (this.errorIndicatorPaint != null) {\n                g2.setPaint(this.errorIndicatorPaint);  \n            }\n            else {\n                g2.setPaint(getItemOutlinePaint(row, column));   \n            }\n            Line2D line = null;\n            line = new Line2D.Double(rectX + rectWidth / 2.0d, lowVal,\n                                     rectX + rectWidth / 2.0d, highVal);\n            g2.draw(line);\n            line = new Line2D.Double(rectX + rectWidth / 2.0d - 5.0d, highVal,\n                                     rectX + rectWidth / 2.0d + 5.0d, highVal);\n            g2.draw(line);\n            line = new Line2D.Double(rectX + rectWidth / 2.0d - 5.0d, lowVal,\n                                     rectX + rectWidth / 2.0d + 5.0d, lowVal);\n            g2.draw(line);\n<END_BUG>\n<START_BUG>\n        \n        CategoryItemLabelGenerator generator = getItemLabelGenerator(row, \n                column);\n        if (generator != null && isItemLabelVisible(row, column)) {\n            drawItemLabel(g2, dataset, row, column, plot, generator, bar, \n                    (value < 0.0));\n        }        \n\n        // add an item entity, if this information is being collected\n        EntityCollection entities = state.getEntityCollection();\n        if (entities != null) {\n            addItemEntity(entities, dataset, row, column, bar);\n        }\n    }",
        "javadoc": "/**\n * Draws an item for a plot with a horizontal orientation.\n *\n * @param g2  the graphics device.\n * @param state  the renderer state.\n * @param dataArea  the data area.\n * @param plot  the plot.\n * @param domainAxis  the domain axis.\n * @param rangeAxis  the range axis.\n * @param dataset  the data.\n * @param row  the row index (zero-based).\n * @param column  the column index (zero-based).\n */\n"
      }
    },
    "contained_scope": "method",
    "bug_count": 2,
    "triggered_tests": {
      "0": {
        "test_path": "org.jfree.chart.renderer.category.junit.StatisticalBarRendererTests",
        "test_method": "testDrawWithNullMeanVertical",
        "test_code": "testDrawWithNullMeanVertical() {\n        boolean success = false;\n        try {\n            DefaultStatisticalCategoryDataset dataset \n                    = new DefaultStatisticalCategoryDataset();\n            dataset.add(1.0, 2.0, \"S1\", \"C1\");\n            dataset.add(null, new Double(4.0), \"S1\", \"C2\");\n            CategoryPlot plot = new CategoryPlot(dataset, \n                    new CategoryAxis(\"Category\"), new NumberAxis(\"Value\"), \n                    new StatisticalBarRenderer());\n            JFreeChart chart = new JFreeChart(plot);\n            /* BufferedImage image = */ chart.createBufferedImage(300, 200, \n                    null);\n            success = true;\n        }\n        catch (NullPointerException e) {\n            e.printStackTrace();\n            success = false;\n        }\n        assertTrue(success);\n    }",
        "clean_err_msg": "junit.framework.AssertionFailedError"
      },
      "1": {
        "test_path": "org.jfree.chart.renderer.category.junit.StatisticalBarRendererTests",
        "test_method": "testDrawWithNullDeviationVertical",
        "test_code": "testDrawWithNullDeviationVertical() {\n        boolean success = false;\n        try {\n            DefaultStatisticalCategoryDataset dataset \n                    = new DefaultStatisticalCategoryDataset();\n            dataset.add(1.0, 2.0, \"S1\", \"C1\");\n            dataset.add(new Double(4.0), null, \"S1\", \"C2\");\n            CategoryPlot plot = new CategoryPlot(dataset, \n                    new CategoryAxis(\"Category\"), new NumberAxis(\"Value\"), \n                    new StatisticalBarRenderer());\n            JFreeChart chart = new JFreeChart(plot);\n            /* BufferedImage image = */ chart.createBufferedImage(300, 200, \n                    null);\n            success = true;\n        }\n        catch (NullPointerException e) {\n            e.printStackTrace();\n            success = false;\n        }\n        assertTrue(success);\n    }",
        "clean_err_msg": "junit.framework.AssertionFailedError"
      },
      "2": {
        "test_path": "org.jfree.chart.renderer.category.junit.StatisticalBarRendererTests",
        "test_method": "testDrawWithNullMeanHorizontal",
        "test_code": "testDrawWithNullMeanHorizontal() {\n        boolean success = false;\n        try {\n            DefaultStatisticalCategoryDataset dataset \n                    = new DefaultStatisticalCategoryDataset();\n            dataset.add(1.0, 2.0, \"S1\", \"C1\");\n            dataset.add(null, new Double(4.0), \"S1\", \"C2\");\n            CategoryPlot plot = new CategoryPlot(dataset, \n                    new CategoryAxis(\"Category\"), new NumberAxis(\"Value\"), \n                    new StatisticalBarRenderer());\n            plot.setOrientation(PlotOrientation.HORIZONTAL);\n            JFreeChart chart = new JFreeChart(plot);\n            /* BufferedImage image = */ chart.createBufferedImage(300, 200, \n                    null);\n            success = true;\n        }\n        catch (NullPointerException e) {\n            e.printStackTrace();\n            success = false;\n        }\n        assertTrue(success);\n    }",
        "clean_err_msg": "junit.framework.AssertionFailedError"
      },
      "3": {
        "test_path": "org.jfree.chart.renderer.category.junit.StatisticalBarRendererTests",
        "test_method": "testDrawWithNullDeviationHorizontal",
        "test_code": "testDrawWithNullDeviationHorizontal() {\n        boolean success = false;\n        try {\n            DefaultStatisticalCategoryDataset dataset \n                    = new DefaultStatisticalCategoryDataset();\n            dataset.add(1.0, 2.0, \"S1\", \"C1\");\n            dataset.add(new Double(4.0), null, \"S1\", \"C2\");\n            CategoryPlot plot = new CategoryPlot(dataset, \n                    new CategoryAxis(\"Category\"), new NumberAxis(\"Value\"), \n                    new StatisticalBarRenderer());\n            plot.setOrientation(PlotOrientation.HORIZONTAL);\n            JFreeChart chart = new JFreeChart(plot);\n            /* BufferedImage image = */ chart.createBufferedImage(300, 200, \n                    null);\n            success = true;\n        }\n        catch (NullPointerException e) {\n            e.printStackTrace();\n            success = false;\n        }\n        assertTrue(success);\n    }",
        "clean_err_msg": "junit.framework.AssertionFailedError"
      }
    },
    "buggy_files": {
      "0": "source/org/jfree/chart/renderer/category/StatisticalBarRenderer.java"
    },
    "hunk_type": "single_file_four_or_more_hunks",
    "hunk_mapping": {
      "0": [
        {
          "start_line": 259,
          "end_line": 258,
          "file": "source/org/jfree/chart/renderer/category/StatisticalBarRenderer.java",
          "code": "<START_BUG>\n<END_BUG>"
        },
        {
          "start_line": 315,
          "end_line": 315,
          "file": "source/org/jfree/chart/renderer/category/StatisticalBarRenderer.java",
          "code": "<START_BUG>\n            double valueDelta = dataset.getStdDevValue(row, column).doubleValue();\n<END_BUG>"
        },
        {
          "start_line": 344,
          "end_line": 343,
          "file": "source/org/jfree/chart/renderer/category/StatisticalBarRenderer.java",
          "code": "<START_BUG>\n<END_BUG>"
        }
      ],
      "1": [
        {
          "start_line": 403,
          "end_line": 402,
          "file": "source/org/jfree/chart/renderer/category/StatisticalBarRenderer.java",
          "code": "<START_BUG>\n<END_BUG>"
        },
        {
          "start_line": 459,
          "end_line": 459,
          "file": "source/org/jfree/chart/renderer/category/StatisticalBarRenderer.java",
          "code": "<START_BUG>\n            double valueDelta = dataset.getStdDevValue(row, column).doubleValue();\n<END_BUG>"
        },
        {
          "start_line": 487,
          "end_line": 486,
          "file": "source/org/jfree/chart/renderer/category/StatisticalBarRenderer.java",
          "code": "<START_BUG>\n<END_BUG>"
        }
      ]
    },
    "bug_report": {
      "url": "UNKNOWN",
      "bug_description": "",
      "title": ""
    }
  },
  "JacksonDatabind_20": {
    "buggy_hunks": {
      "0": {
        "start_line": 4,
        "end_line": 3,
        "file": "src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java",
        "code": "<START_BUG>\n<END_BUG>"
      },
      "1": {
        "start_line": 324,
        "end_line": 323,
        "file": "src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java",
        "code": "<START_BUG>\n<END_BUG>"
      }
    },
    "buggy_code": {
      "0": {
        "start_line": 4,
        "end_line": 4,
        "file": "src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java",
        "code": "import com.fasterxml.jackson.core.*;",
        "javadoc": ""
      },
      "1": {
        "start_line": 324,
        "end_line": 324,
        "file": "src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java",
        "code": "public JsonNode setAll(Map<String,? extends JsonNode> properties)",
        "javadoc": ""
      }
    },
    "delineated_bug": {
      "0": {
        "start_line": 4,
        "end_line": 4,
        "file": "src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java",
        "code": "<START_BUG>\nimport com.fasterxml.jackson.core.*;\n<END_BUG>",
        "javadoc": ""
      },
      "1": {
        "start_line": 324,
        "end_line": 324,
        "file": "src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java",
        "code": "<START_BUG>\npublic JsonNode setAll(Map<String,? extends JsonNode> properties)\n<END_BUG>",
        "javadoc": ""
      }
    },
    "contained_scope": "file",
    "bug_count": 2,
    "triggered_tests": {
      "0": {
        "test_path": "com.fasterxml.jackson.databind.introspect.TestNamingStrategyStd",
        "test_method": "testNamingWithObjectNode",
        "test_code": "testNamingWithObjectNode() throws Exception\n    {\n        ObjectMapper m = new ObjectMapper();\n        m.setPropertyNamingStrategy(PropertyNamingStrategy.LOWER_CASE);\n        ClassWithObjectNodeField result =\n            m.readValue(\n                \"{ \\\"id\\\": \\\"1\\\", \\\"json\\\": { \\\"foo\\\": \\\"bar\\\", \\\"baz\\\": \\\"bing\\\" } }\",\n                ClassWithObjectNodeField.class);\n        assertNotNull(result);\n        assertEquals(\"1\", result.id);\n        assertNotNull(result.json);\n        assertEquals(2, result.json.size());\n        assertEquals(\"bing\", result.json.path(\"baz\").asText());\n    }",
        "clean_err_msg": "com.fasterxml.jackson.databind.JsonMappingException: Conflicting setter definitions for property \"all\": com.fasterxml.jackson.databind.node.ObjectNode#setAll(1 params) vs com.fasterxml.jackson.databind.node.ObjectNode#setAll(1 params)"
      }
    },
    "buggy_files": {
      "0": "src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java"
    },
    "hunk_type": "single_file_two_hunks",
    "hunk_mapping": {
      "0": [
        {
          "start_line": 4,
          "end_line": 3,
          "file": "src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java",
          "code": "<START_BUG>\n<END_BUG>"
        }
      ],
      "1": [
        {
          "start_line": 324,
          "end_line": 323,
          "file": "src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java",
          "code": "<START_BUG>\n<END_BUG>"
        }
      ]
    },
    "bug_report": {
      "url": "https://github.com/FasterXML/jackson-databind/issues/815",
      "title": "Presence of PropertyNamingStrategy Makes Deserialization Fail",
      "bug_description": "I originally came across this issue using Dropwizard - https://github.com/dropwizard/dropwizard/issues/1095.  But it looks like this is a Jackson issue.  Here's the rerproducer:\n\n``` java\npublic class TestPropertyNamingStrategyIssue {\n  public static class ClassWithObjectNodeField {\n    public String id;\n    public ObjectNode json;\n  }\n\n  @Test\n  public void reproducer() throws Exception {\n    ObjectMapper mapper = new ObjectMapper();\n    mapper.setPropertyNamingStrategy(PropertyNamingStrategy.LOWER_CASE);\n    ClassWithObjectNodeField deserialized =\n        mapper.readValue(\n            \"{ \\\"id\\\": \\\"1\\\", \\\"json\\\": { \\\"foo\\\": \\\"bar\\\", \\\"baz\\\": \\\"bing\\\" } }\",\n            ClassWithObjectNodeField.class);\n  }\n}\n```\n\nLooks like the presence of any PropertyNamingStrategy make deserialization to ObjectNode fail.  This works fine if I remove the property naming strategy."
    }
  },
  "JacksonCore_10": {
    "buggy_hunks": {
      "0": {
        "start_line": 925,
        "end_line": 925,
        "file": "src/main/java/com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java",
        "code": "<START_BUG>\n        if (_spilloverEnd >= hashArea.length) {\n<END_BUG>"
      },
      "1": {
        "start_line": 984,
        "end_line": 984,
        "file": "src/main/java/com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java",
        "code": "<START_BUG>\n        hash ^= (hash >>> 12);\n<END_BUG>"
      }
    },
    "buggy_code": {
      "0": {
        "start_line": 887,
        "end_line": 934,
        "file": "src/main/java/com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java",
        "code": "private int _findOffsetForAdd(int hash)\n    {\n        // first, check the primary:\n        int offset = _calcOffset(hash);\n        final int[] hashArea = _hashArea;\n        if (hashArea[offset+3] == 0) {\n//System.err.printf(\" PRImary slot #%d, hash %X\\n\", (offset>>2), hash & 0x7F);\n            return offset;\n        }\n        // then secondary\n        int offset2 = _secondaryStart + ((offset >> 3) << 2);\n        if (hashArea[offset2+3] == 0) {\n//System.err.printf(\" SECondary slot #%d (start x%X), hash %X\\n\",(offset >> 3), _secondaryStart, (hash & 0x7F));\n            return offset2;\n        }\n        // if not, tertiary?\n\n        offset2 = _tertiaryStart + ((offset >> (_tertiaryShift + 2)) << _tertiaryShift);\n        final int bucketSize = (1 << _tertiaryShift);\n        for (int end = offset2 + bucketSize; offset2 < end; offset2 += 4) {\n            if (hashArea[offset2+3] == 0) {\n//System.err.printf(\" TERtiary slot x%X (from x%X, start x%X), hash %X.\\n\", offset2, ((offset >> (_tertiaryShift + 2)) << _tertiaryShift), _tertiaryStart, (hash & 0x7F));\n                return offset2;\n            }\n        }\n\n        // and if even tertiary full, append at the end of spill area\n        offset = _spilloverEnd;\n        _spilloverEnd += 4;\n\n//System.err.printf(\" SPIll-over at x%X; start x%X; end x%X, hash %X\\n\", offset, _spilloverStart(), _hashArea.length, (hash & 0x7F));\n        \n        // one caveat: in the unlikely event if spill-over filling up,\n        // check if that could be considered a DoS attack; handle appropriately\n        // (NOTE: approximate for now; we could verify details if that becomes necessary)\n        /* 31-Jul-2015, tatu: Note that spillover area does NOT end at end of array,\n         *   since \"long names\" area follows. Instead, need to calculate from hash size.\n         */\n        if (_spilloverEnd >= hashArea.length) {\n            if (_failOnDoS) {\n                _reportTooManyCollisions();\n            }\n            // and if we didn't fail, we'll simply force rehash for next add\n            // (which, in turn, may double up or nuke contents, depending on size etc)\n            _needRehash = true;\n        }\n        return offset;\n    }",
        "javadoc": "/**\n * Method called to find the location within hash table to add a new symbol in.\n */\n"
      },
      "1": {
        "start_line": 975,
        "end_line": 986,
        "file": "src/main/java/com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java",
        "code": "public int calcHash(int q1)\n    {\n        int hash = q1 ^ _seed;\n        /* 29-Mar-2015, tatu: Earlier used 15 + 9 right shifts, which worked ok\n         *    except for one specific problem case: numbers. So needed to make sure\n         *    that all 4 least-significant bits participate in hash. Couple of ways\n         *    to work it out, but this is the simplest, fast and seems to do ok.\n         */\n        hash += (hash >>> 16); // to xor hi- and low- 16-bits\n        hash ^= (hash >>> 12);\n        return hash;\n    }",
        "javadoc": ""
      }
    },
    "delineated_bug": {
      "0": {
        "start_line": 887,
        "end_line": 934,
        "file": "src/main/java/com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java",
        "code": "private int _findOffsetForAdd(int hash)\n    {\n        // first, check the primary:\n        int offset = _calcOffset(hash);\n        final int[] hashArea = _hashArea;\n        if (hashArea[offset+3] == 0) {\n//System.err.printf(\" PRImary slot #%d, hash %X\\n\", (offset>>2), hash & 0x7F);\n            return offset;\n        }\n        // then secondary\n        int offset2 = _secondaryStart + ((offset >> 3) << 2);\n        if (hashArea[offset2+3] == 0) {\n//System.err.printf(\" SECondary slot #%d (start x%X), hash %X\\n\",(offset >> 3), _secondaryStart, (hash & 0x7F));\n            return offset2;\n        }\n        // if not, tertiary?\n\n        offset2 = _tertiaryStart + ((offset >> (_tertiaryShift + 2)) << _tertiaryShift);\n        final int bucketSize = (1 << _tertiaryShift);\n        for (int end = offset2 + bucketSize; offset2 < end; offset2 += 4) {\n            if (hashArea[offset2+3] == 0) {\n//System.err.printf(\" TERtiary slot x%X (from x%X, start x%X), hash %X.\\n\", offset2, ((offset >> (_tertiaryShift + 2)) << _tertiaryShift), _tertiaryStart, (hash & 0x7F));\n                return offset2;\n            }\n        }\n\n        // and if even tertiary full, append at the end of spill area\n        offset = _spilloverEnd;\n        _spilloverEnd += 4;\n\n//System.err.printf(\" SPIll-over at x%X; start x%X; end x%X, hash %X\\n\", offset, _spilloverStart(), _hashArea.length, (hash & 0x7F));\n        \n        // one caveat: in the unlikely event if spill-over filling up,\n        // check if that could be considered a DoS attack; handle appropriately\n        // (NOTE: approximate for now; we could verify details if that becomes necessary)\n        /* 31-Jul-2015, tatu: Note that spillover area does NOT end at end of array,\n         *   since \"long names\" area follows. Instead, need to calculate from hash size.\n         */\n<START_BUG>\n        if (_spilloverEnd >= hashArea.length) {\n<END_BUG>\n            if (_failOnDoS) {\n                _reportTooManyCollisions();\n            }\n            // and if we didn't fail, we'll simply force rehash for next add\n            // (which, in turn, may double up or nuke contents, depending on size etc)\n            _needRehash = true;\n        }\n        return offset;\n    }",
        "javadoc": "/**\n * Method called to find the location within hash table to add a new symbol in.\n */\n"
      },
      "1": {
        "start_line": 975,
        "end_line": 986,
        "file": "src/main/java/com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java",
        "code": "public int calcHash(int q1)\n    {\n        int hash = q1 ^ _seed;\n        /* 29-Mar-2015, tatu: Earlier used 15 + 9 right shifts, which worked ok\n         *    except for one specific problem case: numbers. So needed to make sure\n         *    that all 4 least-significant bits participate in hash. Couple of ways\n         *    to work it out, but this is the simplest, fast and seems to do ok.\n         */\n        hash += (hash >>> 16); // to xor hi- and low- 16-bits\n<START_BUG>\n        hash ^= (hash >>> 12);\n<END_BUG>\n        return hash;\n    }",
        "javadoc": ""
      }
    },
    "contained_scope": "method",
    "bug_count": 2,
    "triggered_tests": {
      "0": {
        "test_path": "com.fasterxml.jackson.core.sym.TestByteBasedSymbols",
        "test_method": "testIssue207",
        "test_code": "testIssue207() throws Exception\n    {\n        ByteQuadsCanonicalizer nc = ByteQuadsCanonicalizer.createRoot(-523743345);\n        Field byteSymbolCanonicalizerField = JsonFactory.class.getDeclaredField(\"_byteSymbolCanonicalizer\");\n        byteSymbolCanonicalizerField.setAccessible(true);\n        JsonFactory jsonF = new JsonFactory();\n        byteSymbolCanonicalizerField.set(jsonF, nc);\n\n        StringBuilder stringBuilder = new StringBuilder();\n        stringBuilder.append(\"{\\n\");\n        stringBuilder.append(\"    \\\"expectedGCperPosition\\\": null\");\n        for (int i = 0; i < 60; ++i) {\n            stringBuilder.append(\",\\n    \\\"\").append(i + 1).append(\"\\\": null\");\n        }\n        stringBuilder.append(\"\\n}\");\n\n        JsonParser p = jsonF.createParser(stringBuilder.toString().getBytes(\"UTF-8\"));\n        while (p.nextToken() != null) { }\n        p.close();\n    }",
        "clean_err_msg": "java.lang.ArrayIndexOutOfBoundsException: 256"
      },
      "1": {
        "test_path": "com.fasterxml.jackson.core.sym.TestSymbolTables",
        "test_method": "testCollisionsWithBytesNew187b",
        "test_code": "testCollisionsWithBytesNew187b() throws IOException\n    {\n        ByteQuadsCanonicalizer symbols =\n                ByteQuadsCanonicalizer.createRoot(1).makeChild(JsonFactory.Feature.collectDefaults());\n\n        final int COUNT = 10000;\n        for (int i = 0; i < COUNT; ++i) {\n            String id = String.valueOf(i);\n            int[] quads = calcQuads(id.getBytes(\"UTF-8\"));\n            symbols.addName(id, quads, quads.length);\n        }\n        assertEquals(COUNT, symbols.size());\n        \n        assertEquals(16384, symbols.bucketCount());\n\n        // fragile, but essential to verify low collision counts;\n        // here bit low primary, 55% \n        assertEquals(5402, symbols.primaryCount());\n        // secondary higher than usual, above 25%\n        assertEquals(2744, symbols.secondaryCount());\n        // and most of remaining in tertiary\n        assertEquals(1834, symbols.tertiaryCount());\n        // with a bit of spillover\n        assertEquals(20, symbols.spilloverCount());\n    }",
        "clean_err_msg": "junit.framework.AssertionFailedError: expected:<16384> but was:<32768>"
      },
      "2": {
        "test_path": "com.fasterxml.jackson.core.sym.TestSymbolTables",
        "test_method": "testSyntheticWithBytesNew",
        "test_code": "testSyntheticWithBytesNew() throws IOException\n    {\n        // pass seed, to keep results consistent:\n        final int SEED = 33333;\n        ByteQuadsCanonicalizer symbols =\n                ByteQuadsCanonicalizer.createRoot(SEED).makeChild(JsonFactory.Feature.collectDefaults());\n\n        final int COUNT = 12000;\n        for (int i = 0; i < COUNT; ++i) {\n            String id = fieldNameFor(i);\n            int[] quads = calcQuads(id.getBytes(\"UTF-8\"));\n            symbols.addName(id, quads, quads.length);\n        }\n        assertEquals(COUNT, symbols.size());\n        assertEquals(16384, symbols.bucketCount());\n        \n        // fragile, but essential to verify low collision counts;\n        // anywhere between 70-80% primary matches\n        assertEquals(8534, symbols.primaryCount());\n        // secondary between 10-20%\n        assertEquals(2534, symbols.secondaryCount());\n        // and most of remaining in tertiary\n        assertEquals(932, symbols.tertiaryCount());\n        // so that spill-over is empty or close to\n        assertEquals(0, symbols.spilloverCount());\n    }",
        "clean_err_msg": "junit.framework.AssertionFailedError: expected:<8534> but was:<8524>"
      },
      "3": {
        "test_path": "com.fasterxml.jackson.core.sym.TestSymbolTables",
        "test_method": "testShortNameCollisionsDirectNew",
        "test_code": "testShortNameCollisionsDirectNew() throws IOException\n    {\n        final int COUNT = 700;\n        {\n            ByteQuadsCanonicalizer symbols =\n                    ByteQuadsCanonicalizer.createRoot(333).makeChild(JsonFactory.Feature.collectDefaults());\n            for (int i = 0; i < COUNT; ++i) {\n                String id = String.valueOf((char) i);\n                int[] quads = calcQuads(id.getBytes(\"UTF-8\"));\n                symbols.addName(id, quads, quads.length);\n            }\n            assertEquals(COUNT, symbols.size());\n\n            assertEquals(1024, symbols.bucketCount());\n\n            // Primary is good, but secondary spills cluster in nasty way...\n            assertEquals(564, symbols.primaryCount());\n            assertEquals(122, symbols.secondaryCount());\n            assertEquals(14, symbols.tertiaryCount());\n            assertEquals(0, symbols.spilloverCount());\n\n            assertEquals(COUNT,\n                    symbols.primaryCount() + symbols.secondaryCount() + symbols.tertiaryCount() + symbols.spilloverCount());\n        }\n    }",
        "clean_err_msg": "junit.framework.AssertionFailedError: expected:<1024> but was:<2048>"
      }
    },
    "buggy_files": {
      "0": "src/main/java/com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java"
    },
    "hunk_type": "single_file_two_hunks",
    "hunk_mapping": {
      "0": [
        {
          "start_line": 925,
          "end_line": 925,
          "file": "src/main/java/com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java",
          "code": "<START_BUG>\n        if (_spilloverEnd >= hashArea.length) {\n<END_BUG>"
        }
      ],
      "1": [
        {
          "start_line": 984,
          "end_line": 984,
          "file": "src/main/java/com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java",
          "code": "<START_BUG>\n        hash ^= (hash >>> 12);\n<END_BUG>"
        }
      ]
    },
    "bug_report": {
      "url": "https://github.com/FasterXML/jackson-core/issues/207",
      "title": "ArrayIndexOutOfBoundsException in com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer",
      "bug_description": "The following code demonstrates a bug in jackson-core, version 2.6.0, in the hash table implementation of `com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer`. From a quick glance, it looks to me as if the \"primary hash information area\" `_hashArea` has a spillover area that is not accounted for properly in the `String` array `_names`.\n\n``` java\nimport com.fasterxml.jackson.core.JsonFactory;\nimport com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport org.testng.annotations.Test;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Map;\n\n/**\n * Simple test case for demonstrating bug in class {@link ByteQuadsCanonicalizer}.\n *\n * <p>In some cases, it is possible to work around this bug by disabling the\n * {@link JsonFactory.Feature#CANONICALIZE_FIELD_NAMES} feature. In that case\n * {@link com.fasterxml.jackson.core.json.ByteSourceJsonBootstrapper#constructParser(int, com.fasterxml.jackson.core.ObjectCodec, ByteQuadsCanonicalizer, com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer, int)}\n * creates a {@link com.fasterxml.jackson.core.json.ReaderBasedJsonParser} instead of a\n * {@link com.fasterxml.jackson.core.json.UTF8StreamJsonParser}.\n */\npublic class UTF8ByteStreamTest {\n    private static final int SEED = -523743345;\n\n    private static void injectReproducibleSeed(ObjectMapper objectMapper) throws Exception {\n        JsonFactory jsonFactory = objectMapper.getFactory();\n        // As a workaround, uncomment the following line.\n        // jsonFactory.disable(JsonFactory.Feature.CANONICALIZE_FIELD_NAMES);\n        Field byteSymbolCanonicalizerField = JsonFactory.class.getDeclaredField(\"_byteSymbolCanonicalizer\");\n        byteSymbolCanonicalizerField.setAccessible(true);\n\n        Method factoryMethod = ByteQuadsCanonicalizer.class.getDeclaredMethod(\"createRoot\", int.class);\n        factoryMethod.setAccessible(true);\n        byteSymbolCanonicalizerField.set(jsonFactory, factoryMethod.invoke(null, SEED));\n    }\n\n    @Test\n    public void testRead() throws Exception {\n        ObjectMapper objectMapper = new ObjectMapper();\n        injectReproducibleSeed(objectMapper);\n        StringBuilder stringBuilder = new StringBuilder();\n        stringBuilder.append(\"{\\n\");\n        stringBuilder.append(\"    \\\"expectedGCperPosition\\\": null\");\n        for (int i = 0; i < 60; ++i) {\n            stringBuilder.append(\",\\n    \\\"\").append(i + 1).append(\"\\\": null\");\n        }\n        stringBuilder.append(\"\\n}\");\n        objectMapper.readValue(stringBuilder.toString().getBytes(StandardCharsets.UTF_8), Map.class);\n    }\n}\n```"
    }
  },
  "Gson_1": {
    "buggy_hunks": {
      "0": {
        "start_line": 93,
        "end_line": 94,
        "file": "gson/src/main/java/com/google/gson/TypeInfoFactory.java",
        "code": "<START_BUG>\n\n\n<END_BUG>"
      },
      "1": {
        "start_line": 109,
        "end_line": 113,
        "file": "gson/src/main/java/com/google/gson/TypeInfoFactory.java",
        "code": "<START_BUG>\n\n      // Evaluate type on this type\n\n\n\n<END_BUG>"
      }
    },
    "buggy_code": {
      "0": {
        "start_line": 58,
        "end_line": 107,
        "file": "gson/src/main/java/com/google/gson/TypeInfoFactory.java",
        "code": "private static Type getActualType(\n      Type typeToEvaluate, Type parentType, Class<?> rawParentClass) {\n    if (typeToEvaluate instanceof Class<?>) {\n      return typeToEvaluate;\n    } else if (typeToEvaluate instanceof ParameterizedType) {\n      ParameterizedType castedType = (ParameterizedType) typeToEvaluate;\n      Type owner = castedType.getOwnerType();\n      Type[] actualTypeParameters =\n          extractRealTypes(castedType.getActualTypeArguments(), parentType, rawParentClass);\n      Type rawType = castedType.getRawType();\n      return new ParameterizedTypeImpl(rawType, actualTypeParameters, owner);\n    } else if (typeToEvaluate instanceof GenericArrayType) {\n      GenericArrayType castedType = (GenericArrayType) typeToEvaluate;\n      Type componentType = castedType.getGenericComponentType();\n      Type actualType = getActualType(componentType, parentType, rawParentClass);\n      if (componentType.equals(actualType)) {\n        return castedType;\n      }\n      return actualType instanceof Class<?> ?\n          TypeUtils.wrapWithArray(TypeUtils.toRawClass(actualType))\n          : new GenericArrayTypeImpl(actualType);\n    } else if (typeToEvaluate instanceof TypeVariable<?>) {\n      if (parentType instanceof ParameterizedType) {\n        // The class definition has the actual types used for the type variables.\n        // Find the matching actual type for the Type Variable used for the field.\n        // For example, class Foo<A> { A a; }\n        // new Foo<Integer>(); defines the actual type of A to be Integer.\n        // So, to find the type of the field a, we will have to look at the class'\n        // actual type arguments.\n        TypeVariable<?> fieldTypeVariable = (TypeVariable<?>) typeToEvaluate;\n        TypeVariable<?>[] classTypeVariables = rawParentClass.getTypeParameters();\n        ParameterizedType objParameterizedType = (ParameterizedType) parentType;\n        int indexOfActualTypeArgument = getIndex(classTypeVariables, fieldTypeVariable);\n        Type[] actualTypeArguments = objParameterizedType.getActualTypeArguments();\n        return actualTypeArguments[indexOfActualTypeArgument];\n\n\n      }\n\n      throw new UnsupportedOperationException(\"Expecting parameterized type, got \" + parentType\n          + \".\\n Are you missing the use of TypeToken idiom?\\n See \"\n          + \"http://sites.google.com/site/gson/gson-user-guide#TOC-Serializing-and-Deserializing-Gener\");\n    } else if (typeToEvaluate instanceof WildcardType) {\n      WildcardType castedType = (WildcardType) typeToEvaluate;\n      return getActualType(castedType.getUpperBounds()[0], parentType, rawParentClass);\n    } else {\n      throw new IllegalArgumentException(\"Type \\'\" + typeToEvaluate + \"\\' is not a Class, \"\n          + \"ParameterizedType, GenericArrayType or TypeVariable. Can't extract type.\");\n    }\n  }",
        "javadoc": ""
      },
      "1": {
        "start_line": 109,
        "end_line": 113,
        "file": "gson/src/main/java/com/google/gson/TypeInfoFactory.java",
        "code": "// Evaluate type on this type",
        "javadoc": ""
      }
    },
    "delineated_bug": {
      "0": {
        "start_line": 58,
        "end_line": 107,
        "file": "gson/src/main/java/com/google/gson/TypeInfoFactory.java",
        "code": "private static Type getActualType(\n      Type typeToEvaluate, Type parentType, Class<?> rawParentClass) {\n    if (typeToEvaluate instanceof Class<?>) {\n      return typeToEvaluate;\n    } else if (typeToEvaluate instanceof ParameterizedType) {\n      ParameterizedType castedType = (ParameterizedType) typeToEvaluate;\n      Type owner = castedType.getOwnerType();\n      Type[] actualTypeParameters =\n          extractRealTypes(castedType.getActualTypeArguments(), parentType, rawParentClass);\n      Type rawType = castedType.getRawType();\n      return new ParameterizedTypeImpl(rawType, actualTypeParameters, owner);\n    } else if (typeToEvaluate instanceof GenericArrayType) {\n      GenericArrayType castedType = (GenericArrayType) typeToEvaluate;\n      Type componentType = castedType.getGenericComponentType();\n      Type actualType = getActualType(componentType, parentType, rawParentClass);\n      if (componentType.equals(actualType)) {\n        return castedType;\n      }\n      return actualType instanceof Class<?> ?\n          TypeUtils.wrapWithArray(TypeUtils.toRawClass(actualType))\n          : new GenericArrayTypeImpl(actualType);\n    } else if (typeToEvaluate instanceof TypeVariable<?>) {\n      if (parentType instanceof ParameterizedType) {\n        // The class definition has the actual types used for the type variables.\n        // Find the matching actual type for the Type Variable used for the field.\n        // For example, class Foo<A> { A a; }\n        // new Foo<Integer>(); defines the actual type of A to be Integer.\n        // So, to find the type of the field a, we will have to look at the class'\n        // actual type arguments.\n        TypeVariable<?> fieldTypeVariable = (TypeVariable<?>) typeToEvaluate;\n        TypeVariable<?>[] classTypeVariables = rawParentClass.getTypeParameters();\n        ParameterizedType objParameterizedType = (ParameterizedType) parentType;\n        int indexOfActualTypeArgument = getIndex(classTypeVariables, fieldTypeVariable);\n        Type[] actualTypeArguments = objParameterizedType.getActualTypeArguments();\n        return actualTypeArguments[indexOfActualTypeArgument];\n<START_BUG>\n\n\n<END_BUG>\n      }\n\n      throw new UnsupportedOperationException(\"Expecting parameterized type, got \" + parentType\n          + \".\\n Are you missing the use of TypeToken idiom?\\n See \"\n          + \"http://sites.google.com/site/gson/gson-user-guide#TOC-Serializing-and-Deserializing-Gener\");\n    } else if (typeToEvaluate instanceof WildcardType) {\n      WildcardType castedType = (WildcardType) typeToEvaluate;\n      return getActualType(castedType.getUpperBounds()[0], parentType, rawParentClass);\n    } else {\n      throw new IllegalArgumentException(\"Type \\'\" + typeToEvaluate + \"\\' is not a Class, \"\n          + \"ParameterizedType, GenericArrayType or TypeVariable. Can't extract type.\");\n    }\n  }",
        "javadoc": ""
      },
      "1": {
        "start_line": 109,
        "end_line": 113,
        "file": "gson/src/main/java/com/google/gson/TypeInfoFactory.java",
        "code": "<START_BUG>\n// Evaluate type on this type\n<END_BUG>",
        "javadoc": ""
      }
    },
    "contained_scope": "file",
    "bug_count": 2,
    "triggered_tests": {
      "0": {
        "test_path": "com.google.gson.functional.TypeVariableTest",
        "test_method": "testSingle",
        "test_code": "testSingle() throws Exception {\n    Gson gson = new Gson();\n    Bar bar1 = new Bar(\"someString\", 1);\n    ArrayList<Integer> arrayList = new ArrayList<Integer>();\n    arrayList.add(1);\n    arrayList.add(2);\n    bar1.map.put(\"key1\", arrayList);\n    bar1.map.put(\"key2\", new ArrayList<Integer>());\n    String json = gson.toJson(bar1);\n    System.out.println(json);\n\n    Bar bar2 = gson.fromJson(json, Bar.class);\n    assertEquals(bar1, bar2);\n  }",
        "clean_err_msg": "java.lang.UnsupportedOperationException: Expecting parameterized type, got class com.google.gson.functional.TypeVariableTest$Bar."
      }
    },
    "buggy_files": {
      "0": "gson/src/main/java/com/google/gson/TypeInfoFactory.java"
    },
    "hunk_type": "single_file_two_hunks",
    "hunk_mapping": {
      "0": [
        {
          "start_line": 93,
          "end_line": 94,
          "file": "gson/src/main/java/com/google/gson/TypeInfoFactory.java",
          "code": "<START_BUG>\n\n\n<END_BUG>"
        }
      ],
      "1": [
        {
          "start_line": 109,
          "end_line": 113,
          "file": "gson/src/main/java/com/google/gson/TypeInfoFactory.java",
          "code": "<START_BUG>\n\n      // Evaluate type on this type\n\n\n\n<END_BUG>"
        }
      ]
    },
    "bug_report": {
      "url": "https://github.com/google/gson/issues/40",
      "title": "Fails to serialize/deserialize a class where a super-class has a type parameter",
      "bug_description": "```\nUnfortunately, shortly after the Gson 1.2 release, I found a bug in the\nTypeVariable support.  Basically, the following class can not be serialized\nor deserialized using Gson:\n\npublic class Foo<T> {\n  private final T someField;\n\n  public Foo(T value) {\n    this.someField = value;\n  }\n\n  public boolean equals(Object o) {\n    if (!(o instanceof Foo)) {\n      return false;\n    } else {\n        return someField.equals(((Foo)o).someField);\n    }\n  }\n}\n\npublic class Bar extends Foo<Integer> {\n  public Bar(Integer i) {\n    super(i);\n  }\n}\n\nGson gson = new Gson();\nBar bar1 = new Bar(1);\nString json = gson.toJson(bar1);   // Fails\nBar bar2 = gson.fromJson(\"{\\\"someField\\\":1\", Bar.class);    // Fails\n\nassertEquals(bar1, bar2);\n\n```\n\nOriginal issue reported on code.google.com by `joel.leitch@gmail.com` on 29 Aug 2008 at 11:53\n- Merged into: #168"
    }
  },
  "Closure_108": {
    "buggy_hunks": {
      "0": {
        "start_line": 259,
        "end_line": 258,
        "file": "src/com/google/javascript/jscomp/ScopedAliases.java",
        "code": "<START_BUG>\n<END_BUG>"
      },
      "1": {
        "start_line": 316,
        "end_line": 315,
        "file": "src/com/google/javascript/jscomp/ScopedAliases.java",
        "code": "<START_BUG>\n<END_BUG>"
      },
      "2": {
        "start_line": 432,
        "end_line": 431,
        "file": "src/com/google/javascript/jscomp/ScopedAliases.java",
        "code": "<START_BUG>\n<END_BUG>"
      },
      "3": {
        "start_line": 581,
        "end_line": 581,
        "file": "src/com/google/javascript/jscomp/ScopedAliases.java",
        "code": "<START_BUG>\n        if (info != null) {\n<END_BUG>"
      }
    },
    "buggy_code": {
      "0": {
        "start_line": 259,
        "end_line": 259,
        "file": "src/com/google/javascript/jscomp/ScopedAliases.java",
        "code": "",
        "javadoc": ""
      },
      "1": {
        "start_line": 308,
        "end_line": 321,
        "file": "src/com/google/javascript/jscomp/ScopedAliases.java",
        "code": "@Override\n    public void exitScope(NodeTraversal t) {\n      if (t.getScopeDepth() > 2) {\n        findNamespaceShadows(t);\n      }\n\n      if (t.getScopeDepth() == 2) {\n        renameNamespaceShadows(t);\n        aliases.clear();\n        forbiddenLocals.clear();\n        transformation = null;\n        hasNamespaceShadows = false;\n      }\n    }",
        "javadoc": ""
      },
      "2": {
        "start_line": 357,
        "end_line": 445,
        "file": "src/com/google/javascript/jscomp/ScopedAliases.java",
        "code": "private void findAliases(NodeTraversal t) {\n      Scope scope = t.getScope();\n      for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n          recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n          // Bleeding functions already get a BAD_PARAMETERS error, so just\n          // do nothing.\n        } else if (parent.getType() == Token.LP) {\n          // Parameters of the scope function also get a BAD_PARAMETERS\n          // error.\n        } else if (isVar || isFunctionDecl) {\n          boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n          Node grandparent = parent.getParent();\n          Node value = v.getInitialValue() != null ?\n              v.getInitialValue() :\n              null;\n          Node varNode = null;\n\n          String name = n.getString();\n          int nameCount = scopedAliasNames.count(name);\n          scopedAliasNames.add(name);\n          String globalName =\n              \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n\n          compiler.ensureLibraryInjected(\"base\");\n\n          // First, we need to free up the function expression (EXPR)\n          // to be used in another expression.\n          if (isFunctionDecl) {\n            // Replace \"function NAME() { ... }\" with \"var NAME;\".\n            Node existingName = v.getNameNode();\n\n            // We can't keep the local name on the function expression,\n            // because IE is buggy and will leak the name into the global\n            // scope. This is covered in more detail here:\n            // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n            //\n            // This will only cause problems if this is a hoisted, recursive\n            // function, and the programmer is using the hoisting.\n            Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n            value.replaceChild(existingName, newName);\n\n            varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n            grandparent.replaceChild(parent, varNode);\n          } else {\n            if (value != null) {\n              // If this is a VAR, we can just detach the expression and\n              // the tree will still be valid.\n              value.detachFromParent();\n            }\n            varNode = parent;\n          }\n\n          // Add $jscomp.scope.name = EXPR;\n          // Make sure we copy over all the jsdoc and debug info.\n          if (value != null || v.getJSDocInfo() != null) {\n            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n                compiler.getCodingConvention(),\n                globalName,\n                value,\n                v.getJSDocInfo())\n                .useSourceInfoIfMissingFromForTree(n);\n            NodeUtil.setDebugInformation(\n                newDecl.getFirstChild().getFirstChild(), n, name);\n\n            if (isHoisted) {\n              grandparent.addChildToFront(newDecl);\n            } else {\n              grandparent.addChildBefore(newDecl, varNode);\n            }\n          }\n\n          // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n          v.getNameNode().addChildToFront(\n              NodeUtil.newQualifiedNameNode(\n                  compiler.getCodingConvention(), globalName, n, name));\n\n          recordAlias(v);\n        } else {\n          // Do not other kinds of local symbols, like catch params.\n          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n      }\n    }",
        "javadoc": ""
      },
      "3": {
        "start_line": 522,
        "end_line": 589,
        "file": "src/com/google/javascript/jscomp/ScopedAliases.java",
        "code": "@Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, n.getParent());\n      }\n\n      if (t.getScopeDepth() < 2) {\n        return;\n      }\n\n      int type = n.getType();\n      Var aliasVar = null;\n      if (type == Token.NAME) {\n        String name = n.getString();\n        Var lexicalVar = t.getScope().getVar(n.getString());\n        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n          aliasVar = lexicalVar;\n        }\n      }\n\n      // Validate the top-level of the goog.scope block.\n      if (t.getScopeDepth() == 2) {\n        if (aliasVar != null && NodeUtil.isLValue(n)) {\n          if (aliasVar.getNode() == n) {\n            aliasDefinitionsInOrder.add(n);\n\n            // Return early, to ensure that we don't record a definition\n            // twice.\n            return;\n          } else {\n            report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n          }\n        }\n\n        if (type == Token.RETURN) {\n          report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n          report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n          report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n      }\n\n      // Validate all descendent scopes of the goog.scope block.\n      if (t.getScopeDepth() >= 2) {\n        // Check if this name points to an alias.\n        if (aliasVar != null) {\n          // Note, to support the transitive case, it's important we don't\n          // clone aliasedNode here.  For example,\n          // var g = goog; var d = g.dom; d.createElement('DIV');\n          // The node in aliasedNode (which is \"g\") will be replaced in the\n          // changes pass above with \"goog\".  If we cloned here, we'd end up\n          // with <code>g.dom.createElement('DIV')</code>.\n          aliasUsages.add(new AliasedNode(aliasVar, n));\n        }\n\n        // When we inject declarations, we duplicate jsdoc. Make sure\n        // we only process that jsdoc once.\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n          for (Node node : info.getTypeNodes()) {\n            fixTypeNode(node);\n          }\n        }\n\n        // TODO(robbyw): Error for goog.scope not at root.\n      }\n    }",
        "javadoc": ""
      }
    },
    "delineated_bug": {
      "0": {
        "start_line": 259,
        "end_line": 259,
        "file": "src/com/google/javascript/jscomp/ScopedAliases.java",
        "code": "<START_BUG>\n\n<END_BUG>",
        "javadoc": ""
      },
      "1": {
        "start_line": 308,
        "end_line": 321,
        "file": "src/com/google/javascript/jscomp/ScopedAliases.java",
        "code": "@Override\n    public void exitScope(NodeTraversal t) {\n      if (t.getScopeDepth() > 2) {\n        findNamespaceShadows(t);\n      }\n\n      if (t.getScopeDepth() == 2) {\n        renameNamespaceShadows(t);\n<END_BUG>\n<START_BUG>\n        aliases.clear();\n        forbiddenLocals.clear();\n        transformation = null;\n        hasNamespaceShadows = false;\n      }\n    }",
        "javadoc": ""
      },
      "2": {
        "start_line": 357,
        "end_line": 445,
        "file": "src/com/google/javascript/jscomp/ScopedAliases.java",
        "code": "private void findAliases(NodeTraversal t) {\n      Scope scope = t.getScope();\n      for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n          recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n          // Bleeding functions already get a BAD_PARAMETERS error, so just\n          // do nothing.\n        } else if (parent.getType() == Token.LP) {\n          // Parameters of the scope function also get a BAD_PARAMETERS\n          // error.\n        } else if (isVar || isFunctionDecl) {\n          boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n          Node grandparent = parent.getParent();\n          Node value = v.getInitialValue() != null ?\n              v.getInitialValue() :\n              null;\n          Node varNode = null;\n\n          String name = n.getString();\n          int nameCount = scopedAliasNames.count(name);\n          scopedAliasNames.add(name);\n          String globalName =\n              \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n\n          compiler.ensureLibraryInjected(\"base\");\n\n          // First, we need to free up the function expression (EXPR)\n          // to be used in another expression.\n          if (isFunctionDecl) {\n            // Replace \"function NAME() { ... }\" with \"var NAME;\".\n            Node existingName = v.getNameNode();\n\n            // We can't keep the local name on the function expression,\n            // because IE is buggy and will leak the name into the global\n            // scope. This is covered in more detail here:\n            // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n            //\n            // This will only cause problems if this is a hoisted, recursive\n            // function, and the programmer is using the hoisting.\n            Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n            value.replaceChild(existingName, newName);\n\n            varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n            grandparent.replaceChild(parent, varNode);\n          } else {\n            if (value != null) {\n              // If this is a VAR, we can just detach the expression and\n              // the tree will still be valid.\n              value.detachFromParent();\n            }\n            varNode = parent;\n          }\n\n          // Add $jscomp.scope.name = EXPR;\n          // Make sure we copy over all the jsdoc and debug info.\n          if (value != null || v.getJSDocInfo() != null) {\n            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n                compiler.getCodingConvention(),\n                globalName,\n                value,\n                v.getJSDocInfo())\n                .useSourceInfoIfMissingFromForTree(n);\n            NodeUtil.setDebugInformation(\n                newDecl.getFirstChild().getFirstChild(), n, name);\n\n            if (isHoisted) {\n              grandparent.addChildToFront(newDecl);\n            } else {\n              grandparent.addChildBefore(newDecl, varNode);\n            }\n<END_BUG>\n<START_BUG>\n          }\n\n          // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n          v.getNameNode().addChildToFront(\n              NodeUtil.newQualifiedNameNode(\n                  compiler.getCodingConvention(), globalName, n, name));\n\n          recordAlias(v);\n        } else {\n          // Do not other kinds of local symbols, like catch params.\n          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n      }\n    }",
        "javadoc": ""
      },
      "3": {
        "start_line": 522,
        "end_line": 589,
        "file": "src/com/google/javascript/jscomp/ScopedAliases.java",
        "code": "@Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, n.getParent());\n      }\n\n      if (t.getScopeDepth() < 2) {\n        return;\n      }\n\n      int type = n.getType();\n      Var aliasVar = null;\n      if (type == Token.NAME) {\n        String name = n.getString();\n        Var lexicalVar = t.getScope().getVar(n.getString());\n        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n          aliasVar = lexicalVar;\n        }\n      }\n\n      // Validate the top-level of the goog.scope block.\n      if (t.getScopeDepth() == 2) {\n        if (aliasVar != null && NodeUtil.isLValue(n)) {\n          if (aliasVar.getNode() == n) {\n            aliasDefinitionsInOrder.add(n);\n\n            // Return early, to ensure that we don't record a definition\n            // twice.\n            return;\n          } else {\n            report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n          }\n        }\n\n        if (type == Token.RETURN) {\n          report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n          report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n          report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n      }\n\n      // Validate all descendent scopes of the goog.scope block.\n      if (t.getScopeDepth() >= 2) {\n        // Check if this name points to an alias.\n        if (aliasVar != null) {\n          // Note, to support the transitive case, it's important we don't\n          // clone aliasedNode here.  For example,\n          // var g = goog; var d = g.dom; d.createElement('DIV');\n          // The node in aliasedNode (which is \"g\") will be replaced in the\n          // changes pass above with \"goog\".  If we cloned here, we'd end up\n          // with <code>g.dom.createElement('DIV')</code>.\n          aliasUsages.add(new AliasedNode(aliasVar, n));\n        }\n\n        // When we inject declarations, we duplicate jsdoc. Make sure\n        // we only process that jsdoc once.\n        JSDocInfo info = n.getJSDocInfo();\n<START_BUG>\n        if (info != null) {\n<END_BUG>\n          for (Node node : info.getTypeNodes()) {\n            fixTypeNode(node);\n          }\n        }\n\n        // TODO(robbyw): Error for goog.scope not at root.\n      }\n    }",
        "javadoc": ""
      }
    },
    "contained_scope": "file",
    "bug_count": 4,
    "triggered_tests": {
      "0": {
        "test_path": "com.google.javascript.jscomp.ScopedAliasesTest",
        "test_method": "testIssue1144",
        "test_code": "testIssue1144() {\n    test(\"var ns = {};\" +\n         \"ns.sub = {};\" +\n         \"/** @constructor */ ns.sub.C = function () {};\" +\n         \"goog.scope(function () {\" +\n         \"  var sub = ns.sub;\" +\n         \"  /** @type {sub.C} */\" +\n         \"  var x = null;\" +\n         \"});\",\n         SCOPE_NAMESPACE +\n         \"var ns = {};\" +\n         \"ns.sub = {};\" +\n         \"/** @constructor */ ns.sub.C = function () {};\" +\n         \"$jscomp.scope.x = null;\");\n  }",
        "clean_err_msg": "java.lang.IllegalStateException"
      }
    },
    "buggy_files": {
      "0": "src/com/google/javascript/jscomp/ScopedAliases.java"
    },
    "hunk_type": "single_file_four_or_more_hunks",
    "hunk_mapping": {
      "0": [
        {
          "start_line": 259,
          "end_line": 258,
          "file": "src/com/google/javascript/jscomp/ScopedAliases.java",
          "code": "<START_BUG>\n<END_BUG>"
        }
      ],
      "1": [
        {
          "start_line": 316,
          "end_line": 315,
          "file": "src/com/google/javascript/jscomp/ScopedAliases.java",
          "code": "<START_BUG>\n<END_BUG>"
        }
      ],
      "2": [
        {
          "start_line": 432,
          "end_line": 431,
          "file": "src/com/google/javascript/jscomp/ScopedAliases.java",
          "code": "<START_BUG>\n<END_BUG>"
        }
      ],
      "3": [
        {
          "start_line": 581,
          "end_line": 581,
          "file": "src/com/google/javascript/jscomp/ScopedAliases.java",
          "code": "<START_BUG>\n        if (info != null) {\n<END_BUG>"
        }
      ]
    },
    "bug_report": {
      "url": "https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1144.json",
      "bug_description": "precondition crash: goog.scope local with aliased in the type declaration",
      "title": ""
    }
  },
  "Closure_68": {
    "buggy_hunks": {
      "0": {
        "start_line": 868,
        "end_line": 870,
        "file": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "code": "<START_BUG>\n\n                  token = eatTokensUntilEOL();\n                  }\n<END_BUG>"
      },
      "1": {
        "start_line": 1709,
        "end_line": 1708,
        "file": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "code": "<START_BUG>\n<END_BUG>"
      },
      "2": {
        "start_line": 1761,
        "end_line": 1760,
        "file": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "code": "<START_BUG>\n<END_BUG>"
      }
    },
    "buggy_code": {
      "0": {
        "start_line": 169,
        "end_line": 913,
        "file": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "code": "boolean parse() {\n    int lineno;\n    int charno;\n\n    // JSTypes are represented as Rhino AST nodes, and then resolved later.\n    JSTypeExpression type;\n\n    state = State.SEARCHING_ANNOTATION;\n    skipEOLs();\n\n    JsDocToken token = next();\n\n    List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();\n\n    // Always record that we have a comment.\n    if (jsdocBuilder.shouldParseDocumentation()) {\n      ExtractionInfo blockInfo = extractBlockComment(token);\n      token = blockInfo.token;\n      if (!blockInfo.string.isEmpty()) {\n        jsdocBuilder.recordBlockDescription(blockInfo.string);\n      }\n    } else {\n      if (token != JsDocToken.ANNOTATION &&\n          token != JsDocToken.EOC) {\n        // Mark that there was a description, but don't bother marking\n        // what it was.\n        jsdocBuilder.recordBlockDescription(\"\");\n      }\n    }\n\n    // Parse the actual JsDoc.\n    retry: for (;;) {\n      switch (token) {\n        case ANNOTATION:\n          if (state == State.SEARCHING_ANNOTATION) {\n            state = State.SEARCHING_NEWLINE;\n            lineno = stream.getLineno();\n            charno = stream.getCharno();\n\n            String annotationName = stream.getString();\n            Annotation annotation = annotationNames.get(annotationName);\n            if (annotation == null) {\n              parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName,\n                  stream.getLineno(), stream.getCharno());\n            } else {\n              // Mark the beginning of the annotation.\n              jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n\n              switch (annotation) {\n                case AUTHOR:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo authorInfo = extractSingleLineBlock();\n                    String author = authorInfo.string;\n\n                    if (author.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.authormissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addAuthor(author);\n                    }\n                    token = authorInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case CONSTANT:\n                  if (!jsdocBuilder.recordConstancy()) {\n                    parser.addParserWarning(\"msg.jsdoc.const\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case CONSTRUCTOR:\n                  if (!jsdocBuilder.recordConstructor()) {\n                    if (jsdocBuilder.isInterfaceRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DEPRECATED:\n                  if (!jsdocBuilder.recordDeprecated()) {\n                    parser.addParserWarning(\"msg.jsdoc.deprecated\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  // Find the reason/description, if any.\n                  ExtractionInfo reasonInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String reason = reasonInfo.string;\n\n                  if (reason.length() > 0) {\n                    jsdocBuilder.recordDeprecationReason(reason);\n                  }\n\n                  token = reasonInfo.token;\n                  continue retry;\n\n                case INTERFACE:\n                  if (!jsdocBuilder.recordInterface()) {\n                    if (jsdocBuilder.isConstructorRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DESC:\n                  if (jsdocBuilder.isDescriptionRecorded()) {\n                    parser.addParserWarning(\"msg.jsdoc.desc.extra\",\n                        stream.getLineno(), stream.getCharno());\n                    token = eatTokensUntilEOL();\n                    continue retry;\n                  } else {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    jsdocBuilder.recordDescription(description);\n                    token = descriptionInfo.token;\n                    continue retry;\n                  }\n\n                case FILE_OVERVIEW:\n                  String fileOverview = \"\";\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo fileOverviewInfo =\n                        extractMultilineTextualBlock(token,\n                            WhitespaceOption.TRIM);\n\n                    fileOverview = fileOverviewInfo.string;\n\n                    token = fileOverviewInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n\n                  if (!jsdocBuilder.recordFileOverview(fileOverview) ||\n                      fileOverviewJSDocInfo != null) {\n                    parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case LICENSE:\n                case PRESERVE:\n                  ExtractionInfo preserveInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.PRESERVE);\n\n                  String preserve = preserveInfo.string;\n\n                  if (preserve.length() > 0) {\n                    if (fileLevelJsDocBuilder != null) {\n                      fileLevelJsDocBuilder.append(preserve);\n                    }\n                  }\n\n                  token = preserveInfo.token;\n                  continue retry;\n\n                case ENUM:\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  type = null;\n                  if (token != JsDocToken.EOL && token != JsDocToken.EOC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n                  }\n\n                  if (type == null) {\n                    type = createJSTypeExpression(newStringNode(\"number\"));\n                  }\n                  if (!jsdocBuilder.recordEnumParameterType(type)) {\n                    parser.addTypeWarning(\n                        \"msg.jsdoc.incompat.type\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case EXPORT:\n                  if (!jsdocBuilder.recordExport()) {\n                    parser.addParserWarning(\"msg.jsdoc.export\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTERNS:\n                  if (!jsdocBuilder.recordExterns()) {\n                    parser.addParserWarning(\"msg.jsdoc.externs\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case JAVA_DISPATCH:\n                  if (!jsdocBuilder.recordJavaDispatch()) {\n                    parser.addParserWarning(\"msg.jsdoc.javadispatch\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTENDS:\n                case IMPLEMENTS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  boolean matchingRc = false;\n\n                  if (token == JsDocToken.LC) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (token == JsDocToken.STRING) {\n                    Node typeNode = parseAndRecordTypeNameNode(\n                        token, lineno, charno, matchingRc);\n\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && !matchingRc) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                    type = createJSTypeExpression(typeNode);\n\n                    if (annotation == Annotation.EXTENDS) {\n                      // record the extended type, check later\n                      extendedTypes.add(new ExtendedTypeInfo(\n                          type, stream.getLineno(), stream.getCharno()));\n                    } else {\n                      Preconditions.checkState(\n                          annotation == Annotation.IMPLEMENTS);\n                      if (!jsdocBuilder.recordImplementedInterface(type)) {\n                        parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\",\n                            lineno, charno);\n                      }\n                    }\n                    token = next();\n                    if (matchingRc) {\n                      if (token != JsDocToken.RC) {\n                        parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                            stream.getLineno(), stream.getCharno());\n                      }\n                    } else if (token != JsDocToken.EOL &&\n                        token != JsDocToken.EOF && token != JsDocToken.EOC) {\n                      parser.addTypeWarning(\"msg.end.annotation.expected\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case HIDDEN:\n                  if (!jsdocBuilder.recordHiddenness()) {\n                    parser.addParserWarning(\"msg.jsdoc.hidden\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case LENDS:\n                  skipEOLs();\n\n                  matchingRc = false;\n                  if (match(JsDocToken.LC)) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (match(JsDocToken.STRING)) {\n                    token = next();\n                    if (!jsdocBuilder.recordLends(stream.getString())) {\n                      parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.jsdoc.lends.missing\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  if (matchingRc && !match(JsDocToken.RC)) {\n                    parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MEANING:\n                  ExtractionInfo meaningInfo =\n                      extractMultilineTextualBlock(token);\n                  String meaning = meaningInfo.string;\n                  token = meaningInfo.token;\n                  if (!jsdocBuilder.recordMeaning(meaning)) {\n                    parser.addParserWarning(\"msg.jsdoc.meaning.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case NO_ALIAS:\n                  if (!jsdocBuilder.recordNoAlias()) {\n                    parser.addParserWarning(\"msg.jsdoc.noalias\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_COMPILE:\n                  if (!jsdocBuilder.recordNoCompile()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocompile\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_TYPE_CHECK:\n                  if (!jsdocBuilder.recordNoTypeCheck()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocheck\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NOT_IMPLEMENTED:\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case INHERIT_DOC:\n                case OVERRIDE:\n                  if (!jsdocBuilder.recordOverride()) {\n                    parser.addTypeWarning(\"msg.jsdoc.override\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case THROWS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                  }\n\n                  // *Update* the token to that after the type annotation.\n                  token = current();\n\n                  // Save the throw type.\n                  jsdocBuilder.recordThrowType(type);\n\n                  // Find the throw's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    if (description.length() > 0) {\n                      jsdocBuilder.recordThrowDescription(type, description);\n                    }\n\n                    token = descriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PARAM:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordParamTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                    skipEOLs();\n                    token = next();\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n                  }\n\n                  String name = null;\n                  boolean isBracketedParam = JsDocToken.LB == token;\n                  if (isBracketedParam) {\n                    token = next();\n                  }\n\n                  if (JsDocToken.STRING != token) {\n                    parser.addTypeWarning(\"msg.missing.variable.name\",\n                        lineno, charno);\n                  } else {\n                    name = stream.getString();\n\n                    if (isBracketedParam) {\n                      token = next();\n\n                      // Throw out JsDocToolkit's \"default\" parameter\n                      // annotation.  It makes no sense under our type\n                      // system.\n                      if (JsDocToken.EQUALS == token) {\n                        token = next();\n                        if (JsDocToken.STRING == token) {\n                          token = next();\n                        }\n                      }\n\n                      if (JsDocToken.RB != token) {\n                        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                      } else if (type != null) {\n                        // Make the type expression optional, if it isn't\n                        // already.\n                        type = JSTypeExpression.makeOptionalArg(type);\n                      }\n                    }\n\n                    // If the param name has a DOT in it, just throw it out\n                    // quietly. We do not handle the JsDocToolkit method\n                    // for handling properties of params.\n                    if (name.indexOf('.') > -1) {\n                      name = null;\n                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                      if (jsdocBuilder.hasParameter(name)) {\n                        parser.addTypeWarning(\"msg.dup.variable.name\", name,\n                            lineno, charno);\n                      } else {\n                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name,\n                            lineno, charno);\n                      }\n                    }\n                  }\n\n                  if (name == null) {\n                    token = eatTokensUntilEOL(token);\n                    continue retry;\n                  }\n\n                  jsdocBuilder.markName(name, lineno, charno);\n\n                  // Find the parameter's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo paramDescriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String paramDescription = paramDescriptionInfo.string;\n\n                    if (paramDescription.length() > 0) {\n                      jsdocBuilder.recordParameterDescription(name,\n                          paramDescription);\n                    }\n\n                    token = paramDescriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PRESERVE_TRY:\n                  if (!jsdocBuilder.recordPreserveTry()) {\n                    parser.addParserWarning(\"msg.jsdoc.preservertry\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PRIVATE:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.private\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PROTECTED:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.protected\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PUBLIC:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.public\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SHADOW:\n                  if (!jsdocBuilder.recordNoShadow()) {\n                    parser.addParserWarning(\"msg.jsdoc.noshadow\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SIDE_EFFECTS:\n                  if (!jsdocBuilder.recordNoSideEffects()) {\n                    parser.addParserWarning(\"msg.jsdoc.nosideeffects\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MODIFIES:\n                  token = parseModifiesTag(next());\n                  continue retry;\n\n                case IMPLICIT_CAST:\n                  if (!jsdocBuilder.recordImplicitCast()) {\n                    parser.addTypeWarning(\"msg.jsdoc.implicitcast\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case SEE:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo referenceInfo = extractSingleLineBlock();\n                    String reference = referenceInfo.string;\n\n                    if (reference.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.seemissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addReference(reference);\n                    }\n\n                    token = referenceInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case SUPPRESS:\n                  token = parseSuppressTag(next());\n                  continue retry;\n\n                case TEMPLATE:\n                  ExtractionInfo templateInfo = extractSingleLineBlock();\n                  String templateTypeName = templateInfo.string;\n\n                  if (templateTypeName.length() == 0) {\n                    parser.addTypeWarning(\"msg.jsdoc.templatemissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else if (!jsdocBuilder.recordTemplateTypeName(\n                      templateTypeName)) {\n                    parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  token = templateInfo.token;\n                  continue retry;\n\n                case VERSION:\n                  ExtractionInfo versionInfo = extractSingleLineBlock();\n                  String version = versionInfo.string;\n\n                  if (version.length() == 0) {\n                    parser.addParserWarning(\"msg.jsdoc.versionmissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    if (!jsdocBuilder.recordVersion(version)) {\n                       parser.addParserWarning(\"msg.jsdoc.extraversion\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n\n                  token = versionInfo.token;\n                  continue retry;\n\n                case DEFINE:\n                case RETURN:\n                case THIS:\n                case TYPE:\n                case TYPEDEF:\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  Node typeNode = null;\n                  if (!lookAheadForTypeAnnotation() &&\n                      annotation == Annotation.RETURN) {\n                    // If RETURN doesn't have a type annotation, record\n                    // it as the unknown type.\n                    typeNode = newNode(Token.QMARK);\n                  } else {\n                    skipEOLs();\n                    token = next();\n                    typeNode = parseAndRecordTypeNode(token, lineno, charno);\n                  }\n\n                  if (annotation == Annotation.THIS) {\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && token != JsDocToken.LC) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                  }\n                  type = createJSTypeExpression(typeNode);\n\n                  if (type == null) {\n                    // error reported during recursive descent\n                    // recovering parsing\n                  } else {\n                    switch (annotation) {\n                      case DEFINE:\n                        if (!jsdocBuilder.recordDefineType(type)) {\n                          parser.addParserWarning(\"msg.jsdoc.define\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case RETURN:\n                        if (!jsdocBuilder.recordReturnType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                          break;\n                        }\n\n                        // Find the return's description (if applicable).\n                        if (jsdocBuilder.shouldParseDocumentation()) {\n                          ExtractionInfo returnDescriptionInfo =\n                              extractMultilineTextualBlock(token);\n\n                          String returnDescription =\n                              returnDescriptionInfo.string;\n\n                          if (returnDescription.length() > 0) {\n                            jsdocBuilder.recordReturnDescription(\n                                returnDescription);\n                          }\n\n                          token = returnDescriptionInfo.token;\n                        } else {\n                          token = eatTokensUntilEOL(token);\n                        }\n                        continue retry;\n\n                      case THIS:\n                        if (!jsdocBuilder.recordThisType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPE:\n                        if (!jsdocBuilder.recordType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPEDEF:\n                        if (!jsdocBuilder.recordTypedef(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n                    }\n\n                  token = eatTokensUntilEOL();\n                  }\n                  continue retry;\n              }\n            }\n          }\n          break;\n\n        case EOC:\n          if (hasParsedFileOverviewDocInfo()) {\n            fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();\n          }\n          checkExtendedTypes(extendedTypes);\n          return true;\n\n        case EOF:\n          // discard any accumulated information\n          jsdocBuilder.build(null);\n          parser.addParserWarning(\"msg.unexpected.eof\",\n              stream.getLineno(), stream.getCharno());\n          checkExtendedTypes(extendedTypes);\n          return false;\n\n        case EOL:\n          if (state == State.SEARCHING_NEWLINE) {\n            state = State.SEARCHING_ANNOTATION;\n          }\n          token = next();\n          continue retry;\n\n        default:\n          if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {\n            token = next();\n            continue retry;\n          } else {\n            state = State.SEARCHING_NEWLINE;\n            token = eatTokensUntilEOL();\n            continue retry;\n          }\n      }\n\n      // next token\n      token = next();\n    }\n  }",
        "javadoc": "/**\n * Parses a {@link JSDocInfo} object. This parsing method reads all tokens\n * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the\n * {@link JsDocToken#EOC} is returned.\n *\n * @return {@code true} if JSDoc information was correctly parsed,\n *     {@code false} otherwise\n */\n"
      },
      "1": {
        "start_line": 1685,
        "end_line": 1710,
        "file": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "code": "private Node parseBasicTypeExpression(JsDocToken token) {\n    if (token == JsDocToken.STAR) {\n      return newNode(Token.STAR);\n    } else if (token == JsDocToken.LB) {\n      skipEOLs();\n      return parseArrayType(next());\n    } else if (token == JsDocToken.LC) {\n      skipEOLs();\n      return parseRecordType(next());\n    } else if (token == JsDocToken.LP) {\n      skipEOLs();\n      return parseUnionType(next());\n    } else if (token == JsDocToken.STRING) {\n      String string = stream.getString();\n      if (\"function\".equals(string)) {\n        skipEOLs();\n        return parseFunctionType(next());\n      } else if (\"null\".equals(string) || \"undefined\".equals(string)) {\n        return newStringNode(string);\n      } else {\n        return parseTypeName(token);\n      }\n    }\n\n    return reportGenericTypeSyntaxWarning();\n  }",
        "javadoc": "/**\n * BasicTypeExpression := '*' | 'null' | 'undefined' | TypeName\n *     | FunctionType | UnionType | RecordType | ArrayType\n */\n"
      },
      "2": {
        "start_line": 1757,
        "end_line": 1826,
        "file": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "code": "private Node parseFunctionType(JsDocToken token) {\n    // NOTE(nicksantos): We're not implementing generics at the moment, so\n    // just throw out TypeParameters.\n    if (token != JsDocToken.LP) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n\n    Node functionType = newNode(Token.FUNCTION);\n    Node parameters = null;\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n      token = next();\n\n      boolean hasParams = true;\n      if (token == JsDocToken.STRING) {\n        String tokenStr = stream.getString();\n        boolean isThis = \"this\".equals(tokenStr);\n        boolean isNew = \"new\".equals(tokenStr);\n        if (isThis || isNew) {\n          if (match(JsDocToken.COLON)) {\n            next();\n            skipEOLs();\n            Node contextType = wrapNode(\n                isThis ? Token.THIS : Token.NEW,\n                parseTypeName(next()));\n            if (contextType == null) {\n              return null;\n            }\n\n            functionType.addChildToFront(contextType);\n          } else {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n          }\n\n          if (match(JsDocToken.COMMA)) {\n            next();\n            skipEOLs();\n            token = next();\n          } else {\n            hasParams = false;\n          }\n        }\n      }\n\n      if (hasParams) {\n        parameters = parseParametersType(token);\n        if (parameters == null) {\n          return null;\n        }\n      }\n    }\n\n    if (parameters != null) {\n      functionType.addChildToBack(parameters);\n    }\n\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n\n    skipEOLs();\n    Node resultType = parseResultType(next());\n    if (resultType == null) {\n      return null;\n    } else {\n      functionType.addChildToBack(resultType);\n    }\n    return functionType;\n  }",
        "javadoc": "/**\n * FunctionType := 'function' FunctionSignatureType\n * FunctionSignatureType :=\n *    TypeParameters '(' 'this' ':' TypeName, ParametersType ')' ResultType\n */\n"
      }
    },
    "delineated_bug": {
      "0": {
        "start_line": 169,
        "end_line": 913,
        "file": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "code": "boolean parse() {\n    int lineno;\n    int charno;\n\n    // JSTypes are represented as Rhino AST nodes, and then resolved later.\n    JSTypeExpression type;\n\n    state = State.SEARCHING_ANNOTATION;\n    skipEOLs();\n\n    JsDocToken token = next();\n\n    List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();\n\n    // Always record that we have a comment.\n    if (jsdocBuilder.shouldParseDocumentation()) {\n      ExtractionInfo blockInfo = extractBlockComment(token);\n      token = blockInfo.token;\n      if (!blockInfo.string.isEmpty()) {\n        jsdocBuilder.recordBlockDescription(blockInfo.string);\n      }\n    } else {\n      if (token != JsDocToken.ANNOTATION &&\n          token != JsDocToken.EOC) {\n        // Mark that there was a description, but don't bother marking\n        // what it was.\n        jsdocBuilder.recordBlockDescription(\"\");\n      }\n    }\n\n    // Parse the actual JsDoc.\n    retry: for (;;) {\n      switch (token) {\n        case ANNOTATION:\n          if (state == State.SEARCHING_ANNOTATION) {\n            state = State.SEARCHING_NEWLINE;\n            lineno = stream.getLineno();\n            charno = stream.getCharno();\n\n            String annotationName = stream.getString();\n            Annotation annotation = annotationNames.get(annotationName);\n            if (annotation == null) {\n              parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName,\n                  stream.getLineno(), stream.getCharno());\n            } else {\n              // Mark the beginning of the annotation.\n              jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n\n              switch (annotation) {\n                case AUTHOR:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo authorInfo = extractSingleLineBlock();\n                    String author = authorInfo.string;\n\n                    if (author.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.authormissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addAuthor(author);\n                    }\n                    token = authorInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case CONSTANT:\n                  if (!jsdocBuilder.recordConstancy()) {\n                    parser.addParserWarning(\"msg.jsdoc.const\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case CONSTRUCTOR:\n                  if (!jsdocBuilder.recordConstructor()) {\n                    if (jsdocBuilder.isInterfaceRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DEPRECATED:\n                  if (!jsdocBuilder.recordDeprecated()) {\n                    parser.addParserWarning(\"msg.jsdoc.deprecated\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  // Find the reason/description, if any.\n                  ExtractionInfo reasonInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String reason = reasonInfo.string;\n\n                  if (reason.length() > 0) {\n                    jsdocBuilder.recordDeprecationReason(reason);\n                  }\n\n                  token = reasonInfo.token;\n                  continue retry;\n\n                case INTERFACE:\n                  if (!jsdocBuilder.recordInterface()) {\n                    if (jsdocBuilder.isConstructorRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DESC:\n                  if (jsdocBuilder.isDescriptionRecorded()) {\n                    parser.addParserWarning(\"msg.jsdoc.desc.extra\",\n                        stream.getLineno(), stream.getCharno());\n                    token = eatTokensUntilEOL();\n                    continue retry;\n                  } else {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    jsdocBuilder.recordDescription(description);\n                    token = descriptionInfo.token;\n                    continue retry;\n                  }\n\n                case FILE_OVERVIEW:\n                  String fileOverview = \"\";\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo fileOverviewInfo =\n                        extractMultilineTextualBlock(token,\n                            WhitespaceOption.TRIM);\n\n                    fileOverview = fileOverviewInfo.string;\n\n                    token = fileOverviewInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n\n                  if (!jsdocBuilder.recordFileOverview(fileOverview) ||\n                      fileOverviewJSDocInfo != null) {\n                    parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case LICENSE:\n                case PRESERVE:\n                  ExtractionInfo preserveInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.PRESERVE);\n\n                  String preserve = preserveInfo.string;\n\n                  if (preserve.length() > 0) {\n                    if (fileLevelJsDocBuilder != null) {\n                      fileLevelJsDocBuilder.append(preserve);\n                    }\n                  }\n\n                  token = preserveInfo.token;\n                  continue retry;\n\n                case ENUM:\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  type = null;\n                  if (token != JsDocToken.EOL && token != JsDocToken.EOC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n                  }\n\n                  if (type == null) {\n                    type = createJSTypeExpression(newStringNode(\"number\"));\n                  }\n                  if (!jsdocBuilder.recordEnumParameterType(type)) {\n                    parser.addTypeWarning(\n                        \"msg.jsdoc.incompat.type\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case EXPORT:\n                  if (!jsdocBuilder.recordExport()) {\n                    parser.addParserWarning(\"msg.jsdoc.export\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTERNS:\n                  if (!jsdocBuilder.recordExterns()) {\n                    parser.addParserWarning(\"msg.jsdoc.externs\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case JAVA_DISPATCH:\n                  if (!jsdocBuilder.recordJavaDispatch()) {\n                    parser.addParserWarning(\"msg.jsdoc.javadispatch\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTENDS:\n                case IMPLEMENTS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  boolean matchingRc = false;\n\n                  if (token == JsDocToken.LC) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (token == JsDocToken.STRING) {\n                    Node typeNode = parseAndRecordTypeNameNode(\n                        token, lineno, charno, matchingRc);\n\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && !matchingRc) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                    type = createJSTypeExpression(typeNode);\n\n                    if (annotation == Annotation.EXTENDS) {\n                      // record the extended type, check later\n                      extendedTypes.add(new ExtendedTypeInfo(\n                          type, stream.getLineno(), stream.getCharno()));\n                    } else {\n                      Preconditions.checkState(\n                          annotation == Annotation.IMPLEMENTS);\n                      if (!jsdocBuilder.recordImplementedInterface(type)) {\n                        parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\",\n                            lineno, charno);\n                      }\n                    }\n                    token = next();\n                    if (matchingRc) {\n                      if (token != JsDocToken.RC) {\n                        parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                            stream.getLineno(), stream.getCharno());\n                      }\n                    } else if (token != JsDocToken.EOL &&\n                        token != JsDocToken.EOF && token != JsDocToken.EOC) {\n                      parser.addTypeWarning(\"msg.end.annotation.expected\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case HIDDEN:\n                  if (!jsdocBuilder.recordHiddenness()) {\n                    parser.addParserWarning(\"msg.jsdoc.hidden\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case LENDS:\n                  skipEOLs();\n\n                  matchingRc = false;\n                  if (match(JsDocToken.LC)) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (match(JsDocToken.STRING)) {\n                    token = next();\n                    if (!jsdocBuilder.recordLends(stream.getString())) {\n                      parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.jsdoc.lends.missing\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  if (matchingRc && !match(JsDocToken.RC)) {\n                    parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MEANING:\n                  ExtractionInfo meaningInfo =\n                      extractMultilineTextualBlock(token);\n                  String meaning = meaningInfo.string;\n                  token = meaningInfo.token;\n                  if (!jsdocBuilder.recordMeaning(meaning)) {\n                    parser.addParserWarning(\"msg.jsdoc.meaning.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case NO_ALIAS:\n                  if (!jsdocBuilder.recordNoAlias()) {\n                    parser.addParserWarning(\"msg.jsdoc.noalias\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_COMPILE:\n                  if (!jsdocBuilder.recordNoCompile()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocompile\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_TYPE_CHECK:\n                  if (!jsdocBuilder.recordNoTypeCheck()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocheck\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NOT_IMPLEMENTED:\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case INHERIT_DOC:\n                case OVERRIDE:\n                  if (!jsdocBuilder.recordOverride()) {\n                    parser.addTypeWarning(\"msg.jsdoc.override\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case THROWS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                  }\n\n                  // *Update* the token to that after the type annotation.\n                  token = current();\n\n                  // Save the throw type.\n                  jsdocBuilder.recordThrowType(type);\n\n                  // Find the throw's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    if (description.length() > 0) {\n                      jsdocBuilder.recordThrowDescription(type, description);\n                    }\n\n                    token = descriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PARAM:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordParamTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                    skipEOLs();\n                    token = next();\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n                  }\n\n                  String name = null;\n                  boolean isBracketedParam = JsDocToken.LB == token;\n                  if (isBracketedParam) {\n                    token = next();\n                  }\n\n                  if (JsDocToken.STRING != token) {\n                    parser.addTypeWarning(\"msg.missing.variable.name\",\n                        lineno, charno);\n                  } else {\n                    name = stream.getString();\n\n                    if (isBracketedParam) {\n                      token = next();\n\n                      // Throw out JsDocToolkit's \"default\" parameter\n                      // annotation.  It makes no sense under our type\n                      // system.\n                      if (JsDocToken.EQUALS == token) {\n                        token = next();\n                        if (JsDocToken.STRING == token) {\n                          token = next();\n                        }\n                      }\n\n                      if (JsDocToken.RB != token) {\n                        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                      } else if (type != null) {\n                        // Make the type expression optional, if it isn't\n                        // already.\n                        type = JSTypeExpression.makeOptionalArg(type);\n                      }\n                    }\n\n                    // If the param name has a DOT in it, just throw it out\n                    // quietly. We do not handle the JsDocToolkit method\n                    // for handling properties of params.\n                    if (name.indexOf('.') > -1) {\n                      name = null;\n                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                      if (jsdocBuilder.hasParameter(name)) {\n                        parser.addTypeWarning(\"msg.dup.variable.name\", name,\n                            lineno, charno);\n                      } else {\n                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name,\n                            lineno, charno);\n                      }\n                    }\n                  }\n\n                  if (name == null) {\n                    token = eatTokensUntilEOL(token);\n                    continue retry;\n                  }\n\n                  jsdocBuilder.markName(name, lineno, charno);\n\n                  // Find the parameter's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo paramDescriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String paramDescription = paramDescriptionInfo.string;\n\n                    if (paramDescription.length() > 0) {\n                      jsdocBuilder.recordParameterDescription(name,\n                          paramDescription);\n                    }\n\n                    token = paramDescriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PRESERVE_TRY:\n                  if (!jsdocBuilder.recordPreserveTry()) {\n                    parser.addParserWarning(\"msg.jsdoc.preservertry\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PRIVATE:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.private\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PROTECTED:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.protected\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PUBLIC:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.public\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SHADOW:\n                  if (!jsdocBuilder.recordNoShadow()) {\n                    parser.addParserWarning(\"msg.jsdoc.noshadow\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SIDE_EFFECTS:\n                  if (!jsdocBuilder.recordNoSideEffects()) {\n                    parser.addParserWarning(\"msg.jsdoc.nosideeffects\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MODIFIES:\n                  token = parseModifiesTag(next());\n                  continue retry;\n\n                case IMPLICIT_CAST:\n                  if (!jsdocBuilder.recordImplicitCast()) {\n                    parser.addTypeWarning(\"msg.jsdoc.implicitcast\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case SEE:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo referenceInfo = extractSingleLineBlock();\n                    String reference = referenceInfo.string;\n\n                    if (reference.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.seemissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addReference(reference);\n                    }\n\n                    token = referenceInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case SUPPRESS:\n                  token = parseSuppressTag(next());\n                  continue retry;\n\n                case TEMPLATE:\n                  ExtractionInfo templateInfo = extractSingleLineBlock();\n                  String templateTypeName = templateInfo.string;\n\n                  if (templateTypeName.length() == 0) {\n                    parser.addTypeWarning(\"msg.jsdoc.templatemissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else if (!jsdocBuilder.recordTemplateTypeName(\n                      templateTypeName)) {\n                    parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  token = templateInfo.token;\n                  continue retry;\n\n                case VERSION:\n                  ExtractionInfo versionInfo = extractSingleLineBlock();\n                  String version = versionInfo.string;\n\n                  if (version.length() == 0) {\n                    parser.addParserWarning(\"msg.jsdoc.versionmissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    if (!jsdocBuilder.recordVersion(version)) {\n                       parser.addParserWarning(\"msg.jsdoc.extraversion\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n\n                  token = versionInfo.token;\n                  continue retry;\n\n                case DEFINE:\n                case RETURN:\n                case THIS:\n                case TYPE:\n                case TYPEDEF:\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  Node typeNode = null;\n                  if (!lookAheadForTypeAnnotation() &&\n                      annotation == Annotation.RETURN) {\n                    // If RETURN doesn't have a type annotation, record\n                    // it as the unknown type.\n                    typeNode = newNode(Token.QMARK);\n                  } else {\n                    skipEOLs();\n                    token = next();\n                    typeNode = parseAndRecordTypeNode(token, lineno, charno);\n                  }\n\n                  if (annotation == Annotation.THIS) {\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && token != JsDocToken.LC) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                  }\n                  type = createJSTypeExpression(typeNode);\n\n                  if (type == null) {\n                    // error reported during recursive descent\n                    // recovering parsing\n                  } else {\n                    switch (annotation) {\n                      case DEFINE:\n                        if (!jsdocBuilder.recordDefineType(type)) {\n                          parser.addParserWarning(\"msg.jsdoc.define\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case RETURN:\n                        if (!jsdocBuilder.recordReturnType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                          break;\n                        }\n\n                        // Find the return's description (if applicable).\n                        if (jsdocBuilder.shouldParseDocumentation()) {\n                          ExtractionInfo returnDescriptionInfo =\n                              extractMultilineTextualBlock(token);\n\n                          String returnDescription =\n                              returnDescriptionInfo.string;\n\n                          if (returnDescription.length() > 0) {\n                            jsdocBuilder.recordReturnDescription(\n                                returnDescription);\n                          }\n\n                          token = returnDescriptionInfo.token;\n                        } else {\n                          token = eatTokensUntilEOL(token);\n                        }\n                        continue retry;\n\n                      case THIS:\n                        if (!jsdocBuilder.recordThisType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPE:\n                        if (!jsdocBuilder.recordType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPEDEF:\n                        if (!jsdocBuilder.recordTypedef(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n                    }\n<START_BUG>\n\n                  token = eatTokensUntilEOL();\n                  }\n<END_BUG>\n                  continue retry;\n              }\n            }\n          }\n          break;\n\n        case EOC:\n          if (hasParsedFileOverviewDocInfo()) {\n            fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();\n          }\n          checkExtendedTypes(extendedTypes);\n          return true;\n\n        case EOF:\n          // discard any accumulated information\n          jsdocBuilder.build(null);\n          parser.addParserWarning(\"msg.unexpected.eof\",\n              stream.getLineno(), stream.getCharno());\n          checkExtendedTypes(extendedTypes);\n          return false;\n\n        case EOL:\n          if (state == State.SEARCHING_NEWLINE) {\n            state = State.SEARCHING_ANNOTATION;\n          }\n          token = next();\n          continue retry;\n\n        default:\n          if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {\n            token = next();\n            continue retry;\n          } else {\n            state = State.SEARCHING_NEWLINE;\n            token = eatTokensUntilEOL();\n            continue retry;\n          }\n      }\n\n      // next token\n      token = next();\n    }\n  }",
        "javadoc": "/**\n * Parses a {@link JSDocInfo} object. This parsing method reads all tokens\n * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the\n * {@link JsDocToken#EOC} is returned.\n *\n * @return {@code true} if JSDoc information was correctly parsed,\n *     {@code false} otherwise\n */\n"
      },
      "1": {
        "start_line": 1685,
        "end_line": 1710,
        "file": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "code": "private Node parseBasicTypeExpression(JsDocToken token) {\n    if (token == JsDocToken.STAR) {\n      return newNode(Token.STAR);\n    } else if (token == JsDocToken.LB) {\n      skipEOLs();\n      return parseArrayType(next());\n    } else if (token == JsDocToken.LC) {\n      skipEOLs();\n      return parseRecordType(next());\n    } else if (token == JsDocToken.LP) {\n      skipEOLs();\n      return parseUnionType(next());\n    } else if (token == JsDocToken.STRING) {\n      String string = stream.getString();\n      if (\"function\".equals(string)) {\n        skipEOLs();\n        return parseFunctionType(next());\n      } else if (\"null\".equals(string) || \"undefined\".equals(string)) {\n        return newStringNode(string);\n      } else {\n        return parseTypeName(token);\n      }\n    }\n\n<END_BUG>\n<START_BUG>\n    return reportGenericTypeSyntaxWarning();\n  }",
        "javadoc": "/**\n * BasicTypeExpression := '*' | 'null' | 'undefined' | TypeName\n *     | FunctionType | UnionType | RecordType | ArrayType\n */\n"
      },
      "2": {
        "start_line": 1757,
        "end_line": 1826,
        "file": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "code": "private Node parseFunctionType(JsDocToken token) {\n    // NOTE(nicksantos): We're not implementing generics at the moment, so\n    // just throw out TypeParameters.\n    if (token != JsDocToken.LP) {\n<END_BUG>\n<START_BUG>\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n\n    Node functionType = newNode(Token.FUNCTION);\n    Node parameters = null;\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n      token = next();\n\n      boolean hasParams = true;\n      if (token == JsDocToken.STRING) {\n        String tokenStr = stream.getString();\n        boolean isThis = \"this\".equals(tokenStr);\n        boolean isNew = \"new\".equals(tokenStr);\n        if (isThis || isNew) {\n          if (match(JsDocToken.COLON)) {\n            next();\n            skipEOLs();\n            Node contextType = wrapNode(\n                isThis ? Token.THIS : Token.NEW,\n                parseTypeName(next()));\n            if (contextType == null) {\n              return null;\n            }\n\n            functionType.addChildToFront(contextType);\n          } else {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n          }\n\n          if (match(JsDocToken.COMMA)) {\n            next();\n            skipEOLs();\n            token = next();\n          } else {\n            hasParams = false;\n          }\n        }\n      }\n\n      if (hasParams) {\n        parameters = parseParametersType(token);\n        if (parameters == null) {\n          return null;\n        }\n      }\n    }\n\n    if (parameters != null) {\n      functionType.addChildToBack(parameters);\n    }\n\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n\n    skipEOLs();\n    Node resultType = parseResultType(next());\n    if (resultType == null) {\n      return null;\n    } else {\n      functionType.addChildToBack(resultType);\n    }\n    return functionType;\n  }",
        "javadoc": "/**\n * FunctionType := 'function' FunctionSignatureType\n * FunctionSignatureType :=\n *    TypeParameters '(' 'this' ':' TypeName, ParametersType ')' ResultType\n */\n"
      }
    },
    "contained_scope": "method",
    "bug_count": 3,
    "triggered_tests": {
      "0": {
        "test_path": "com.google.javascript.jscomp.parsing.JsDocInfoParserTest",
        "test_method": "testIssue477",
        "test_code": "testIssue477() throws Exception {\n    parse(\"@type function */\",\n        \"Bad type annotation. missing opening (\");\n  }",
        "clean_err_msg": "junit.framework.AssertionFailedError: extra warning: Unexpected end of file"
      }
    },
    "buggy_files": {
      "0": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java"
    },
    "hunk_type": "single_file_three_hunks",
    "hunk_mapping": {
      "0": [
        {
          "start_line": 868,
          "end_line": 870,
          "file": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
          "code": "<START_BUG>\n\n                  token = eatTokensUntilEOL();\n                  }\n<END_BUG>"
        }
      ],
      "1": [
        {
          "start_line": 1709,
          "end_line": 1708,
          "file": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
          "code": "<START_BUG>\n<END_BUG>"
        }
      ],
      "2": [
        {
          "start_line": 1761,
          "end_line": 1760,
          "file": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
          "code": "<START_BUG>\n<END_BUG>"
        }
      ]
    },
    "bug_report": {
      "url": "https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-477.json",
      "bug_description": "Cryptic error message on invalid \"@type function\" annotation",
      "title": ""
    }
  },
  "Mockito_21": {
    "buggy_hunks": {
      "0": {
        "start_line": 17,
        "end_line": 28,
        "file": "src/org/mockito/internal/creation/instance/ConstructorInstantiator.java",
        "code": "<START_BUG>\n        return withOuterClass(cls);\n    }\n\n    private <T> T withOuterClass(Class<T> cls) {\n        try {\n            //this is kind of overengineered because we don't need to support more params\n            //however, I know we will be needing it :)\n            Constructor<T> c = cls.getDeclaredConstructor(outerClassInstance.getClass());\n            return c.newInstance(outerClassInstance);\n        } catch (Exception e) {\n            throw paramsException(cls, e);\n        }\n<END_BUG>"
      },
      "1": {
        "start_line": 36,
        "end_line": 35,
        "file": "src/org/mockito/internal/creation/instance/ConstructorInstantiator.java",
        "code": "<START_BUG>\n<END_BUG>"
      }
    },
    "buggy_code": {
      "0": {
        "start_line": 13,
        "end_line": 29,
        "file": "src/org/mockito/internal/creation/instance/ConstructorInstantiator.java",
        "code": "public <T> T newInstance(Class<T> cls) {\n        if (outerClassInstance == null) {\n            return noArgConstructor(cls);\n        }\n        return withOuterClass(cls);\n    }\n\n    private <T> T withOuterClass(Class<T> cls) {\n        try {\n            //this is kind of overengineered because we don't need to support more params\n            //however, I know we will be needing it :)\n            Constructor<T> c = cls.getDeclaredConstructor(outerClassInstance.getClass());\n            return c.newInstance(outerClassInstance);\n        } catch (Exception e) {\n            throw paramsException(cls, e);\n        }\n    }",
        "javadoc": ""
      },
      "1": {
        "start_line": 36,
        "end_line": 36,
        "file": "src/org/mockito/internal/creation/instance/ConstructorInstantiator.java",
        "code": "",
        "javadoc": ""
      }
    },
    "delineated_bug": {
      "0": {
        "start_line": 13,
        "end_line": 29,
        "file": "src/org/mockito/internal/creation/instance/ConstructorInstantiator.java",
        "code": "public <T> T newInstance(Class<T> cls) {\n        if (outerClassInstance == null) {\n            return noArgConstructor(cls);\n        }\n<START_BUG>\n        return withOuterClass(cls);\n    }\n\n    private <T> T withOuterClass(Class<T> cls) {\n        try {\n            //this is kind of overengineered because we don't need to support more params\n            //however, I know we will be needing it :)\n            Constructor<T> c = cls.getDeclaredConstructor(outerClassInstance.getClass());\n            return c.newInstance(outerClassInstance);\n        } catch (Exception e) {\n            throw paramsException(cls, e);\n        }\n<END_BUG>\n    }",
        "javadoc": ""
      },
      "1": {
        "start_line": 36,
        "end_line": 36,
        "file": "src/org/mockito/internal/creation/instance/ConstructorInstantiator.java",
        "code": "<START_BUG>\n\n<END_BUG>",
        "javadoc": ""
      }
    },
    "contained_scope": "file",
    "bug_count": 2,
    "triggered_tests": {
      "0": {
        "test_path": "org.mockito.internal.creation.instance.ConstructorInstantiatorTest",
        "test_method": "creates_instances_of_inner_classes",
        "test_code": "creates_instances_of_inner_classes() {\n        assertEquals(new ConstructorInstantiator(this).newInstance(SomeInnerClass.class).getClass(), SomeInnerClass.class);\n        assertEquals(new ConstructorInstantiator(new ChildOfThis()).newInstance(SomeInnerClass.class).getClass(), SomeInnerClass.class);\n    }",
        "clean_err_msg": "org.mockito.internal.creation.instance.InstantationException: Unable to create mock instance of 'SomeInnerClass'."
      }
    },
    "buggy_files": {
      "0": "src/org/mockito/internal/creation/instance/ConstructorInstantiator.java"
    },
    "hunk_type": "single_file_two_hunks",
    "hunk_mapping": {
      "0": [
        {
          "start_line": 17,
          "end_line": 28,
          "file": "src/org/mockito/internal/creation/instance/ConstructorInstantiator.java",
          "code": "<START_BUG>\n        return withOuterClass(cls);\n    }\n\n    private <T> T withOuterClass(Class<T> cls) {\n        try {\n            //this is kind of overengineered because we don't need to support more params\n            //however, I know we will be needing it :)\n            Constructor<T> c = cls.getDeclaredConstructor(outerClassInstance.getClass());\n            return c.newInstance(outerClassInstance);\n        } catch (Exception e) {\n            throw paramsException(cls, e);\n        }\n<END_BUG>"
        }
      ],
      "1": [
        {
          "start_line": 36,
          "end_line": 35,
          "file": "src/org/mockito/internal/creation/instance/ConstructorInstantiator.java",
          "code": "<START_BUG>\n<END_BUG>"
        }
      ]
    },
    "bug_report": {
      "url": "https://github.com/mockito/mockito/issues/92",
      "title": "Allow convenient spying on abstract classes",
      "bug_description": "I posted this in GoogleCode and was asked to submit in github.\n\nMockito is easy to use when the test needs to provide canned values for a certain method.\n\nBut it gets harder when a canned value isn't sufficient.\n##### Example 1: Fake with trivial Logic\n\n```\ninterface UserAccount {\n  List<String> getEmails();\n  void addEmail(String email);\n  // 12 other methods ...\n}\n```\n\nWhen mocking such domain entity object, it's tedious to manually program getEmails()/addEmail() with when().thenReturn() and to make sure the two methods are logically consistent, that is, getEmails() returns all emails added.\n##### Example 2: callback-style API\n\n```\ninterface AccountService {\n  void getAccount(String id, AsyncCallback<UserAccount> callback);\n}\n```\n\nStubbing AccountService isn't easy. It'd require use of Answer, and the Answer API isn't statically type safe:\n\n```\nwhen(service.getAccount(eq(id), any(AsyncCallback.class)).thenAnswer(new Answer<Void>() {\n  AsyncCallback<UserAccount> callback = (AsyncCallback<UserAccount>) getArguments()[1];\n  ...\n});\n```\n##### Example 3: Uninteresting parameters\n\n```\ninterface AccountRpcService {\n  FutureAccount getAccount(RpcContext context, String id);\n}\n```\n\nNone of the tests care about the context object. It's an uninteresting parameter imposed by the framework.\n\nIf AccountRpcService were directly mocked, all tests would have to use isA() to repetitively mention this uninteresting parameter, like this:\n\n`when(service.getAccount(isA(RpcContext.class), eq(\"id\")).thenReturn(...);`\n\nAnd all other parameters are required to be wrapped in eq().\n#### Proposal\n\nI propose adding support for abstract classes to mockito to make it easier to deal with tests like above:\n##### For example 1\n\n```\nabstract class FakeUserAccount implements UserAccount {\n  private final List<String> emails = new ArrayList<>();\n\n  @Override public void addEmail(String email) {\n    emails.add(email);\n  }\n  @Override List<String> getEmails() {\n    return ImmutableList.copyOf(emails);\n  }\n}\n\n@Fake private FakeUserAccount userAccount; // Mockito instantiates abstract class.\n```\n##### For example 2\n\n```\nabstract class MockAccountService implements AccountService {\n  @Override public void getAccount(String id, AsyncCallback<UserAccount> callback) {\n    callback.onSuccess(getAccount(id));\n  }\n  abstract UserAccount getAccount(String id);\n}\n\n@Fake private MockAccountService service;\n\n...\n\nwhen(service.getAccount(\"id\")).thenReturn(account);\n```\n##### For example 3\n\n```\nabstract class MockAccountRpcService implements AccountRpcService {\n  @Override Future<Account> getAccount(RpcContext context, String id) {\n    checkNotNull(context);  // Common sanity test. Don't have to repeat it in tests.\n    return getAccount(id);\n  }\n\n  abstract Future<Account> getAccount(String id);\n}\n\n@Fake private MockAccountRpcService service;\n\nwhen(service.getAccount(\"id\")).thenReturn(...);\n```\n\nMy work place internally implemented a default Answer to support abstract classes. We found that the support of abstract classes helps us to avoid overusing mocks when we should be using fakes. And in situations like above we get cleaner test code.\n\nBut because it's not integrated in the core Mockito, there are gotchas with our implementation (like, you can't have private/final methods in your fake).\n\nIf the idea sounds okay to give a try, I'll volunteer to submit a patch.\n\nThanks!"
    }
  },
  "Lang_62": {
    "buggy_hunks": {
      "0": {
        "start_line": 850,
        "end_line": 849,
        "file": "src/java/org/apache/commons/lang/Entities.java",
        "code": "<START_BUG>\n<END_BUG>"
      },
      "1": {
        "start_line": 920,
        "end_line": 925,
        "file": "src/java/org/apache/commons/lang/Entities.java",
        "code": "<START_BUG>\n                                    }\n                                    default : {\n                                        entityValue = Integer.parseInt(entityContent.substring(1), 10);\n                                    }\n                                }\n                            } catch (NumberFormatException e) {\n<END_BUG>"
      }
    },
    "buggy_code": {
      "0": {
        "start_line": 813,
        "end_line": 870,
        "file": "src/java/org/apache/commons/lang/Entities.java",
        "code": "public String unescape(String str) {\n        int firstAmp = str.indexOf('&');\n        if (firstAmp < 0) {\n            return str;\n        }\n\n        StringBuffer buf = new StringBuffer(str.length());\n        buf.append(str.substring(0, firstAmp));\n        for (int i = firstAmp; i < str.length(); ++i) {\n            char ch = str.charAt(i);\n            if (ch == '&') {\n                int semi = str.indexOf(';', i + 1);\n                if (semi == -1) {\n                    buf.append(ch);\n                    continue;\n                }\n                int amph = str.indexOf('&', i + 1);\n                if( amph != -1 && amph < semi ) {\n                    // Then the text looks like &...&...;\n                    buf.append(ch);\n                    continue;\n                }\n                String entityName = str.substring(i + 1, semi);\n                int entityValue;\n                if (entityName.length() == 0) {\n                    entityValue = -1;\n                } else if (entityName.charAt(0) == '#') {\n                    if (entityName.length() == 1) {\n                        entityValue = -1;\n                    } else {\n                        char charAt1 = entityName.charAt(1);\n                        try {\n                            if (charAt1 == 'x' || charAt1=='X') {\n                                entityValue = Integer.valueOf(entityName.substring(2), 16).intValue();\n                            } else {\n                                entityValue = Integer.parseInt(entityName.substring(1));\n                            }\n                        } catch (NumberFormatException ex) {\n                            entityValue = -1;\n                        }\n                    }\n                } else {\n                    entityValue = this.entityValue(entityName);\n                }\n                if (entityValue == -1) {\n                    buf.append('&');\n                    buf.append(entityName);\n                    buf.append(';');\n                } else {\n                    buf.append((char) (entityValue));\n                }\n                i = semi;\n            } else {\n                buf.append(ch);\n            }\n        }\n        return buf.toString();\n    }",
        "javadoc": "/**\n * <p>Unescapes the entities in a <code>String</code>.</p>\n *\n * <p>For example, if you have called addEntity(&quot;foo&quot;, 0xA1),\n * unescape(&quot;&amp;foo;&quot;) will return &quot;\\u00A1&quot;</p>\n *\n * @param str The <code>String</code> to escape.\n * @return A new escaped <code>String</code>.\n */\n"
      },
      "1": {
        "start_line": 884,
        "end_line": 945,
        "file": "src/java/org/apache/commons/lang/Entities.java",
        "code": "public void unescape(Writer writer, String string) throws IOException {\n        int firstAmp = string.indexOf('&');\n        if (firstAmp < 0) {\n            writer.write(string);\n            return;\n        }\n\n        writer.write(string, 0, firstAmp);\n        int len = string.length();\n        for (int i = firstAmp; i < len; i++) {\n            char c = string.charAt(i);\n            if (c == '&') {\n                int nextIdx = i+1;\n                int semiColonIdx = string.indexOf(';', nextIdx);\n                if (semiColonIdx == -1) {\n                    writer.write(c);\n                    continue;\n                }\n                int amphersandIdx = string.indexOf('&', i + 1);\n                if( amphersandIdx != -1 && amphersandIdx < semiColonIdx ) {\n                    // Then the text looks like &...&...;\n                    writer.write(c);\n                    continue;\n                }\n                String entityContent = string.substring(nextIdx, semiColonIdx);\n                int entityValue = -1;\n                int entityContentLen = entityContent.length();\n                if (entityContentLen > 0) {\n                    if (entityContent.charAt(0) == '#') { //escaped value content is an integer (decimal or hexidecimal)\n                        if (entityContentLen > 1) {  \n                            char isHexChar = entityContent.charAt(1);\n                            try {\n                                switch (isHexChar) {\n                                    case 'X' :\n                                    case 'x' : {\n                                        entityValue = Integer.parseInt(entityContent.substring(2), 16);\n                                    }\n                                    default : {\n                                        entityValue = Integer.parseInt(entityContent.substring(1), 10);\n                                    }\n                                }\n                            } catch (NumberFormatException e) {\n                            }\n                        }\n                    } else { //escaped value content is an entity name\n                        entityValue = this.entityValue(entityContent);\n                    }\n                }\n                \n                if (entityValue == -1) {\n                    writer.write('&');\n                    writer.write(entityContent);\n                    writer.write(';');\n                } else {\n                    writer.write(entityValue);\n                }\n                i = semiColonIdx; //move index up to the semi-colon                \n            } else {\n                writer.write(c);\n            }\n        }\n    }",
        "javadoc": "/**\n * <p>Unescapes the escaped entities in the <code>String</code> passed and\n * writes the result to the <code>Writer</code> passed.</p>\n *\n * @param writer The <code>Writer</code> to write the results to; assumed to be non-null.\n * @param string The <code>String</code> to write the results to; assumed to be non-null.\n * @throws IOException when <code>Writer</code> passed throws the exception from\n *                                       calls to the {@link Writer#write(int)} methods.\n *\n * @see #escape(String)\n * @see Writer\n */\n"
      }
    },
    "delineated_bug": {
      "0": {
        "start_line": 813,
        "end_line": 870,
        "file": "src/java/org/apache/commons/lang/Entities.java",
        "code": "public String unescape(String str) {\n        int firstAmp = str.indexOf('&');\n        if (firstAmp < 0) {\n            return str;\n        }\n\n        StringBuffer buf = new StringBuffer(str.length());\n        buf.append(str.substring(0, firstAmp));\n        for (int i = firstAmp; i < str.length(); ++i) {\n            char ch = str.charAt(i);\n            if (ch == '&') {\n                int semi = str.indexOf(';', i + 1);\n                if (semi == -1) {\n                    buf.append(ch);\n                    continue;\n                }\n                int amph = str.indexOf('&', i + 1);\n                if( amph != -1 && amph < semi ) {\n                    // Then the text looks like &...&...;\n                    buf.append(ch);\n                    continue;\n                }\n                String entityName = str.substring(i + 1, semi);\n                int entityValue;\n                if (entityName.length() == 0) {\n                    entityValue = -1;\n                } else if (entityName.charAt(0) == '#') {\n                    if (entityName.length() == 1) {\n                        entityValue = -1;\n                    } else {\n                        char charAt1 = entityName.charAt(1);\n                        try {\n                            if (charAt1 == 'x' || charAt1=='X') {\n                                entityValue = Integer.valueOf(entityName.substring(2), 16).intValue();\n                            } else {\n                                entityValue = Integer.parseInt(entityName.substring(1));\n                            }\n<END_BUG>\n<START_BUG>\n                        } catch (NumberFormatException ex) {\n                            entityValue = -1;\n                        }\n                    }\n                } else {\n                    entityValue = this.entityValue(entityName);\n                }\n                if (entityValue == -1) {\n                    buf.append('&');\n                    buf.append(entityName);\n                    buf.append(';');\n                } else {\n                    buf.append((char) (entityValue));\n                }\n                i = semi;\n            } else {\n                buf.append(ch);\n            }\n        }\n        return buf.toString();\n    }",
        "javadoc": "/**\n * <p>Unescapes the entities in a <code>String</code>.</p>\n *\n * <p>For example, if you have called addEntity(&quot;foo&quot;, 0xA1),\n * unescape(&quot;&amp;foo;&quot;) will return &quot;\\u00A1&quot;</p>\n *\n * @param str The <code>String</code> to escape.\n * @return A new escaped <code>String</code>.\n */\n"
      },
      "1": {
        "start_line": 884,
        "end_line": 945,
        "file": "src/java/org/apache/commons/lang/Entities.java",
        "code": "public void unescape(Writer writer, String string) throws IOException {\n        int firstAmp = string.indexOf('&');\n        if (firstAmp < 0) {\n            writer.write(string);\n            return;\n        }\n\n        writer.write(string, 0, firstAmp);\n        int len = string.length();\n        for (int i = firstAmp; i < len; i++) {\n            char c = string.charAt(i);\n            if (c == '&') {\n                int nextIdx = i+1;\n                int semiColonIdx = string.indexOf(';', nextIdx);\n                if (semiColonIdx == -1) {\n                    writer.write(c);\n                    continue;\n                }\n                int amphersandIdx = string.indexOf('&', i + 1);\n                if( amphersandIdx != -1 && amphersandIdx < semiColonIdx ) {\n                    // Then the text looks like &...&...;\n                    writer.write(c);\n                    continue;\n                }\n                String entityContent = string.substring(nextIdx, semiColonIdx);\n                int entityValue = -1;\n                int entityContentLen = entityContent.length();\n                if (entityContentLen > 0) {\n                    if (entityContent.charAt(0) == '#') { //escaped value content is an integer (decimal or hexidecimal)\n                        if (entityContentLen > 1) {  \n                            char isHexChar = entityContent.charAt(1);\n                            try {\n                                switch (isHexChar) {\n                                    case 'X' :\n                                    case 'x' : {\n                                        entityValue = Integer.parseInt(entityContent.substring(2), 16);\n<START_BUG>\n                                    }\n                                    default : {\n                                        entityValue = Integer.parseInt(entityContent.substring(1), 10);\n                                    }\n                                }\n                            } catch (NumberFormatException e) {\n<END_BUG>\n                            }\n                        }\n                    } else { //escaped value content is an entity name\n                        entityValue = this.entityValue(entityContent);\n                    }\n                }\n                \n                if (entityValue == -1) {\n                    writer.write('&');\n                    writer.write(entityContent);\n                    writer.write(';');\n                } else {\n                    writer.write(entityValue);\n                }\n                i = semiColonIdx; //move index up to the semi-colon                \n            } else {\n                writer.write(c);\n            }\n        }\n    }",
        "javadoc": "/**\n * <p>Unescapes the escaped entities in the <code>String</code> passed and\n * writes the result to the <code>Writer</code> passed.</p>\n *\n * @param writer The <code>Writer</code> to write the results to; assumed to be non-null.\n * @param string The <code>String</code> to write the results to; assumed to be non-null.\n * @throws IOException when <code>Writer</code> passed throws the exception from\n *                                       calls to the {@link Writer#write(int)} methods.\n *\n * @see #escape(String)\n * @see Writer\n */\n"
      }
    },
    "contained_scope": "method",
    "bug_count": 2,
    "triggered_tests": {
      "0": {
        "test_path": "org.apache.commons.lang.EntitiesTest",
        "test_method": "testNumberOverflow",
        "test_code": "testNumberOverflow() throws Exception {\n        doTestUnescapeEntity(\"&#12345678;\", \"&#12345678;\");\n        doTestUnescapeEntity(\"x&#12345678;y\", \"x&#12345678;y\");\n        doTestUnescapeEntity(\"&#x12345678;\", \"&#x12345678;\");\n        doTestUnescapeEntity(\"x&#x12345678;y\", \"x&#x12345678;y\");\n    }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<[&#12345678;]> but was:<[\u614e]>"
      }
    },
    "buggy_files": {
      "0": "src/java/org/apache/commons/lang/Entities.java"
    },
    "hunk_type": "single_file_two_hunks",
    "hunk_mapping": {
      "0": [
        {
          "start_line": 850,
          "end_line": 849,
          "file": "src/java/org/apache/commons/lang/Entities.java",
          "code": "<START_BUG>\n<END_BUG>"
        }
      ],
      "1": [
        {
          "start_line": 920,
          "end_line": 925,
          "file": "src/java/org/apache/commons/lang/Entities.java",
          "code": "<START_BUG>\n                                    }\n                                    default : {\n                                        entityValue = Integer.parseInt(entityContent.substring(1), 10);\n                                    }\n                                }\n                            } catch (NumberFormatException e) {\n<END_BUG>"
        }
      ]
    },
    "bug_report": {
      "url": "https://issues.apache.org/jira/browse/LANG-292",
      "title": "https://issues.apache.org/jira/browse/LANG-292",
      "bug_description": "Following test (in EntitiesTest.java) fails:\npublic void testNumberOverflow() throws Exception\n{\n        doTestUnescapeEntity(\"&#12345678;\", \"&#12345678;\");\n        doTestUnescapeEntity(\"x&#12345678;y\", \"x&#12345678;y\");\n        doTestUnescapeEntity(\"&#x12345678;\", \"&#x12345678;\");\n        doTestUnescapeEntity(\"x&#x12345678;y\", \"x&#x12345678;y\");\n    }\nMaximim value for char is 0xFFFF, so &#12345678; is invalid entity reference, and so should be left as is."
    }
  },
  "Closure_21": {
    "buggy_hunks": {
      "0": {
        "start_line": 101,
        "end_line": 101,
        "file": "src/com/google/javascript/jscomp/CheckSideEffects.java",
        "code": "<START_BUG>\n    if (n.isExprResult()) {\n<END_BUG>"
      },
      "1": {
        "start_line": 113,
        "end_line": 130,
        "file": "src/com/google/javascript/jscomp/CheckSideEffects.java",
        "code": "<START_BUG>\n    if (parent.getType() == Token.COMMA) {\n      if (isResultUsed) {\n        return;\n      }\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA) continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n          else break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n        return;\n      }\n    }\n    if (\n<END_BUG>"
      }
    },
    "buggy_code": {
      "0": {
        "start_line": 83,
        "end_line": 148,
        "file": "src/com/google/javascript/jscomp/CheckSideEffects.java",
        "code": "@Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    // VOID nodes appear when there are extra semicolons at the BLOCK level.\n    // I've been unable to think of any cases where this indicates a bug,\n    // and apparently some people like keeping these semicolons around,\n    // so we'll allow it.\n    if (n.isEmpty() ||\n        n.isComma()) {\n      return;\n    }\n\n    if (parent == null) {\n      return;\n    }\n\n    // Do not try to remove a block or an expr result. We already handle\n    // these cases when we visit the child, and the peephole passes will\n    // fix up the tree in more clever ways when these are removed.\n    if (n.isExprResult()) {\n      return;\n    }\n\n    // This no-op statement was there so that JSDoc information could\n    // be attached to the name. This check should not complain about it.\n    if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n      return;\n    }\n\n    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n    if (parent.getType() == Token.COMMA) {\n      if (isResultUsed) {\n        return;\n      }\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA) continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n          else break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n        return;\n      }\n    }\n    if (\n        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n      String msg = \"This code lacks side-effects. Is there a bug?\";\n      if (n.isString()) {\n        msg = \"Is there a missing '+' on the previous line?\";\n      } else if (isSimpleOp) {\n        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n            \"' operator is not being used.\";\n      }\n\n      t.getCompiler().report(\n          t.makeError(n, level, USELESS_CODE_ERROR, msg));\n      // TODO(johnlenz): determine if it is necessary to\n      // try to protect side-effect free statements as well.\n      if (!NodeUtil.isStatement(n)) {\n        problemNodes.add(n);\n      }\n    }\n  }",
        "javadoc": ""
      }
    },
    "delineated_bug": {
      "0": {
        "start_line": 83,
        "end_line": 148,
        "file": "src/com/google/javascript/jscomp/CheckSideEffects.java",
        "code": "@Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    // VOID nodes appear when there are extra semicolons at the BLOCK level.\n    // I've been unable to think of any cases where this indicates a bug,\n    // and apparently some people like keeping these semicolons around,\n    // so we'll allow it.\n    if (n.isEmpty() ||\n        n.isComma()) {\n      return;\n    }\n\n    if (parent == null) {\n      return;\n    }\n\n    // Do not try to remove a block or an expr result. We already handle\n    // these cases when we visit the child, and the peephole passes will\n    // fix up the tree in more clever ways when these are removed.\n<START_BUG>\n    if (n.isExprResult()) {\n<END_BUG>\n      return;\n    }\n\n    // This no-op statement was there so that JSDoc information could\n    // be attached to the name. This check should not complain about it.\n    if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n      return;\n    }\n\n    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n<START_BUG>\n    if (parent.getType() == Token.COMMA) {\n      if (isResultUsed) {\n        return;\n      }\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA) continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n          else break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n        return;\n      }\n    }\n    if (\n<END_BUG>\n        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n      String msg = \"This code lacks side-effects. Is there a bug?\";\n      if (n.isString()) {\n        msg = \"Is there a missing '+' on the previous line?\";\n      } else if (isSimpleOp) {\n        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n            \"' operator is not being used.\";\n      }\n\n      t.getCompiler().report(\n          t.makeError(n, level, USELESS_CODE_ERROR, msg));\n      // TODO(johnlenz): determine if it is necessary to\n      // try to protect side-effect free statements as well.\n      if (!NodeUtil.isStatement(n)) {\n        problemNodes.add(n);\n      }\n    }\n  }",
        "javadoc": ""
      }
    },
    "contained_scope": "method",
    "bug_count": 1,
    "triggered_tests": {
      "0": {
        "test_path": "com.google.javascript.jscomp.CheckSideEffectsTest",
        "test_method": "testUselessCode",
        "test_code": "testUselessCode() {\n    test(\"function f(x) { if(x) return; }\", ok);\n    test(\"function f(x) { if(x); }\", \"function f(x) { if(x); }\", e);\n\n    test(\"if(x) x = y;\", ok);\n    test(\"if(x) x == bar();\", \"if(x) JSCOMPILER_PRESERVE(x == bar());\", e);\n\n    test(\"x = 3;\", ok);\n    test(\"x == 3;\", \"JSCOMPILER_PRESERVE(x == 3);\", e);\n\n    test(\"var x = 'test'\", ok);\n    test(\"var x = 'test'\\n'str'\",\n         \"var x = 'test'\\nJSCOMPILER_PRESERVE('str')\", e);\n\n    test(\"\", ok);\n    test(\"foo();;;;bar();;;;\", ok);\n\n    test(\"var a, b; a = 5, b = 6\", ok);\n    test(\"var a, b; a = 5, b == 6\",\n         \"var a, b; a = 5, JSCOMPILER_PRESERVE(b == 6)\", e);\n    test(\"var a, b; a = (5, 6)\",\n         \"var a, b; a = (JSCOMPILER_PRESERVE(5), 6)\", e);\n    test(\"var a, b; a = (bar(), 6, 7)\",\n         \"var a, b; a = (bar(), JSCOMPILER_PRESERVE(6), 7)\", e);\n    test(\"var a, b; a = (bar(), bar(), 7, 8)\",\n         \"var a, b; a = (bar(), bar(), JSCOMPILER_PRESERVE(7), 8)\", e);\n    test(\"var a, b; a = (b = 7, 6)\", ok);\n    test(\"function x(){}\\nfunction f(a, b){}\\nf(1,(x(), 2));\", ok);\n    test(\"function x(){}\\nfunction f(a, b){}\\nf(1,(2, 3));\",\n         \"function x(){}\\nfunction f(a, b){}\\n\" +\n         \"f(1,(JSCOMPILER_PRESERVE(2), 3));\", e);\n  }",
        "clean_err_msg": "junit.framework.AssertionFailedError: There should be one warning, repeated 1 time(s). expected:<1> but was:<0>"
      }
    },
    "buggy_files": {
      "0": "src/com/google/javascript/jscomp/CheckSideEffects.java"
    },
    "hunk_type": "single_file_two_hunks",
    "hunk_mapping": {
      "0": [
        {
          "start_line": 101,
          "end_line": 101,
          "file": "src/com/google/javascript/jscomp/CheckSideEffects.java",
          "code": "<START_BUG>\n    if (n.isExprResult()) {\n<END_BUG>"
        },
        {
          "start_line": 113,
          "end_line": 130,
          "file": "src/com/google/javascript/jscomp/CheckSideEffects.java",
          "code": "<START_BUG>\n    if (parent.getType() == Token.COMMA) {\n      if (isResultUsed) {\n        return;\n      }\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA) continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n          else break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n        return;\n      }\n    }\n    if (\n<END_BUG>"
        }
      ]
    },
    "bug_report": {
      "url": "https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-753.json",
      "bug_description": "Classify non-rightmost expressions as problematic",
      "title": ""
    }
  },
  "Lang_27": {
    "buggy_hunks": {
      "0": {
        "start_line": 479,
        "end_line": 479,
        "file": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
        "code": "<START_BUG>\n                if (expPos < decPos) {\n<END_BUG>"
      },
      "1": {
        "start_line": 489,
        "end_line": 488,
        "file": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
        "code": "<START_BUG>\n<END_BUG>"
      }
    },
    "buggy_code": {
      "0": {
        "start_line": 452,
        "end_line": 599,
        "file": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
        "code": "public static Number createNumber(String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n            return createInteger(str);\n        }   \n        char lastChar = str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = str.indexOf('.');\n        int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\n        if (decPos > -1) {\n\n            if (expPos > -1) {\n                if (expPos < decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                dec = str.substring(decPos + 1);\n            }\n            mant = str.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n                mant = str.substring(0, expPos);\n            } else {\n                mant = str;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar) && lastChar != '.') {\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp = null;\n            }\n            //Requesting a specific type..\n            String numeric = str.substring(0, str.length() - 1);\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n                        && exp == null\n                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            //Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            //If it's too big for a float or the float value = 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException nfe) {\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                case 'd' :\n                case 'D' :\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) {\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) {\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn't have a preference on the return type, so let's start\n            //small and go from there...\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length());\n            } else {\n                exp = null;\n            }\n            if (dec == null && exp == null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                return createBigInteger(str);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                    Float f = createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    Double d = createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n\n                return createBigDecimal(str);\n\n            }\n        }\n    }",
        "javadoc": "/**\n * <p>Turns a string value into a java.lang.Number.</p>\n *\n * <p>First, the value is examined for a type qualifier on the end\n * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts\n * trying to create successively larger types from the type specified\n * until one is found that can represent the value.</p>\n *\n * <p>If a type specifier is not found, it will check for a decimal point\n * and then try successively larger types from <code>Integer</code> to\n * <code>BigInteger</code> and from <code>Float</code> to\n * <code>BigDecimal</code>.</p>\n *\n * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it\n * will be interpreted as a hexadecimal integer.  Values with leading\n * <code>0</code>'s will not be interpreted as octal.</p>\n *\n * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n *\n * <p>This method does not trim the input string, i.e., strings with leading\n * or trailing spaces will generate NumberFormatExceptions.</p>\n *\n * @param str  String containing a number, may be null\n * @return Number created from the string\n * @throws NumberFormatException if the value cannot be converted\n */\n"
      }
    },
    "delineated_bug": {
      "0": {
        "start_line": 452,
        "end_line": 599,
        "file": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
        "code": "public static Number createNumber(String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n            return createInteger(str);\n        }   \n        char lastChar = str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = str.indexOf('.');\n        int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\n        if (decPos > -1) {\n\n            if (expPos > -1) {\n<START_BUG>\n                if (expPos < decPos) {\n<END_BUG>\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                dec = str.substring(decPos + 1);\n            }\n            mant = str.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n<END_BUG>\n<START_BUG>\n                mant = str.substring(0, expPos);\n            } else {\n                mant = str;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar) && lastChar != '.') {\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp = null;\n            }\n            //Requesting a specific type..\n            String numeric = str.substring(0, str.length() - 1);\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n                        && exp == null\n                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            //Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            //If it's too big for a float or the float value = 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException nfe) {\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                case 'd' :\n                case 'D' :\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) {\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) {\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn't have a preference on the return type, so let's start\n            //small and go from there...\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length());\n            } else {\n                exp = null;\n            }\n            if (dec == null && exp == null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                return createBigInteger(str);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                    Float f = createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    Double d = createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n\n                return createBigDecimal(str);\n\n            }\n        }\n    }",
        "javadoc": "/**\n * <p>Turns a string value into a java.lang.Number.</p>\n *\n * <p>First, the value is examined for a type qualifier on the end\n * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts\n * trying to create successively larger types from the type specified\n * until one is found that can represent the value.</p>\n *\n * <p>If a type specifier is not found, it will check for a decimal point\n * and then try successively larger types from <code>Integer</code> to\n * <code>BigInteger</code> and from <code>Float</code> to\n * <code>BigDecimal</code>.</p>\n *\n * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it\n * will be interpreted as a hexadecimal integer.  Values with leading\n * <code>0</code>'s will not be interpreted as octal.</p>\n *\n * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n *\n * <p>This method does not trim the input string, i.e., strings with leading\n * or trailing spaces will generate NumberFormatExceptions.</p>\n *\n * @param str  String containing a number, may be null\n * @return Number created from the string\n * @throws NumberFormatException if the value cannot be converted\n */\n"
      }
    },
    "contained_scope": "method",
    "bug_count": 1,
    "triggered_tests": {
      "0": {
        "test_path": "org.apache.commons.lang3.math.NumberUtilsTest",
        "test_method": "testCreateNumber",
        "test_code": "testCreateNumber() {\n        // a lot of things can go wrong\n        assertEquals(\"createNumber(String) 1 failed\", new Float(\"1234.5\"), NumberUtils.createNumber(\"1234.5\"));\n        assertEquals(\"createNumber(String) 2 failed\", new Integer(\"12345\"), NumberUtils.createNumber(\"12345\"));\n        assertEquals(\"createNumber(String) 3 failed\", new Double(\"1234.5\"), NumberUtils.createNumber(\"1234.5D\"));\n        assertEquals(\"createNumber(String) 3 failed\", new Double(\"1234.5\"), NumberUtils.createNumber(\"1234.5d\"));\n        assertEquals(\"createNumber(String) 4 failed\", new Float(\"1234.5\"), NumberUtils.createNumber(\"1234.5F\"));\n        assertEquals(\"createNumber(String) 4 failed\", new Float(\"1234.5\"), NumberUtils.createNumber(\"1234.5f\"));\n        assertEquals(\"createNumber(String) 5 failed\", new Long(Integer.MAX_VALUE + 1L), NumberUtils.createNumber(\"\"\n            + (Integer.MAX_VALUE + 1L)));\n        assertEquals(\"createNumber(String) 6 failed\", new Long(12345), NumberUtils.createNumber(\"12345L\"));\n        assertEquals(\"createNumber(String) 6 failed\", new Long(12345), NumberUtils.createNumber(\"12345l\"));\n        assertEquals(\"createNumber(String) 7 failed\", new Float(\"-1234.5\"), NumberUtils.createNumber(\"-1234.5\"));\n        assertEquals(\"createNumber(String) 8 failed\", new Integer(\"-12345\"), NumberUtils.createNumber(\"-12345\"));\n        assertTrue(\"createNumber(String) 9 failed\", 0xFADE == NumberUtils.createNumber(\"0xFADE\").intValue());\n        assertTrue(\"createNumber(String) 10 failed\", -0xFADE == NumberUtils.createNumber(\"-0xFADE\").intValue());\n        assertEquals(\"createNumber(String) 11 failed\", new Double(\"1.1E200\"), NumberUtils.createNumber(\"1.1E200\"));\n        assertEquals(\"createNumber(String) 12 failed\", new Float(\"1.1E20\"), NumberUtils.createNumber(\"1.1E20\"));\n        assertEquals(\"createNumber(String) 13 failed\", new Double(\"-1.1E200\"), NumberUtils.createNumber(\"-1.1E200\"));\n        assertEquals(\"createNumber(String) 14 failed\", new Double(\"1.1E-200\"), NumberUtils.createNumber(\"1.1E-200\"));\n        assertEquals(\"createNumber(null) failed\", null, NumberUtils.createNumber(null));\n        assertEquals(\"createNumber(String) failed\", new BigInteger(\"12345678901234567890\"), NumberUtils\n                .createNumber(\"12345678901234567890L\"));\n\n        // jdk 1.2 doesn't support this. unsure about jdk 1.2.2\n        if (SystemUtils.isJavaVersionAtLeast(1.3f)) {\n            assertEquals(\"createNumber(String) 15 failed\", new BigDecimal(\"1.1E-700\"), NumberUtils\n                    .createNumber(\"1.1E-700F\"));\n        }\n        assertEquals(\"createNumber(String) 16 failed\", new Long(\"10\" + Integer.MAX_VALUE), NumberUtils\n                .createNumber(\"10\" + Integer.MAX_VALUE + \"L\"));\n        assertEquals(\"createNumber(String) 17 failed\", new Long(\"10\" + Integer.MAX_VALUE), NumberUtils\n                .createNumber(\"10\" + Integer.MAX_VALUE));\n        assertEquals(\"createNumber(String) 18 failed\", new BigInteger(\"10\" + Long.MAX_VALUE), NumberUtils\n                .createNumber(\"10\" + Long.MAX_VALUE));\n\n        // LANG-521\n        assertEquals(\"createNumber(String) LANG-521 failed\", new Float(\"2.\"), NumberUtils.createNumber(\"2.\"));\n\n        // LANG-638\n        assertFalse(\"createNumber(String) succeeded\", checkCreateNumber(\"1eE\"));\n    }",
        "clean_err_msg": "java.lang.StringIndexOutOfBoundsException: String index out of range: 4"
      }
    },
    "buggy_files": {
      "0": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java"
    },
    "hunk_type": "single_file_two_hunks",
    "hunk_mapping": {
      "0": [
        {
          "start_line": 479,
          "end_line": 479,
          "file": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
          "code": "<START_BUG>\n                if (expPos < decPos) {\n<END_BUG>"
        },
        {
          "start_line": 489,
          "end_line": 488,
          "file": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
          "code": "<START_BUG>\n<END_BUG>"
        }
      ]
    },
    "bug_report": {
      "url": "https://issues.apache.org/jira/browse/LANG-638",
      "title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed in",
      "bug_description": "NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in.\nOne example of such a String is \"1eE\"."
    }
  },
  "JacksonCore_21": {
    "buggy_hunks": {
      "0": {
        "start_line": 238,
        "end_line": 237,
        "file": "src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java",
        "code": "<START_BUG>\n<END_BUG>"
      },
      "1": {
        "start_line": 248,
        "end_line": 247,
        "file": "src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java",
        "code": "<START_BUG>\n<END_BUG>"
      }
    },
    "buggy_code": {
      "0": {
        "start_line": 226,
        "end_line": 454,
        "file": "src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java",
        "code": "@Override\n    public JsonToken nextToken() throws IOException\n    {\n        // 23-May-2017, tatu: To be honest, code here is rather hairy and I don't like all\n        //    conditionals; and it seems odd to return `null` but NOT considering input\n        //    as closed... would love a rewrite to simplify/clear up logic here.\n        \n        // Check for _allowMultipleMatches - false and at least there is one token - which is _currToken\n        // check for no buffered context _exposedContext - null\n        // If all the conditions matches then check for scalar / non-scalar property\n        if (!_allowMultipleMatches && (_currToken != null) && (_exposedContext == null)) {\n            //if not scalar and ended successfully, and !includePath, then return null\n                if (_currToken.isStructEnd()) {\n                    if (_headContext.isStartHandled()) {\n                        return (_currToken = null);\n                    }\n                } else if (_currToken.isScalarValue()) {\n                    //else if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL matched once\n                    // then return null \n                    if (!_headContext.isStartHandled() && (_itemFilter == TokenFilter.INCLUDE_ALL)) {\n                        return (_currToken = null);\n                    }\n            }\n        }\n        // Anything buffered?\n        TokenFilterContext ctxt = _exposedContext;\n\n        if (ctxt != null) {\n            while (true) {\n                JsonToken t = ctxt.nextTokenToRead();\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n                // all done with buffered stuff?\n                if (ctxt == _headContext) {\n                    _exposedContext = null;\n                    if (ctxt.inArray()) {\n                        t = delegate.getCurrentToken();\n// Is this guaranteed to work without further checks?\n//                        if (t != JsonToken.START_ARRAY) {\n                        _currToken = t;\n                        return t;\n                    }\n\n                    // Almost! Most likely still have the current token;\n                    // with the sole exception of \n                    /*\n                    t = delegate.getCurrentToken();\n                    if (t != JsonToken.FIELD_NAME) {\n                        _currToken = t;\n                        return t;\n                    }\n                    */\n                    break;\n                }\n                // If not, traverse down the context chain\n                ctxt = _headContext.findChildOf(ctxt);\n                _exposedContext = ctxt;\n                if (ctxt == null) { // should never occur\n                    throw _constructError(\"Unexpected problem: chain of filtered context broken\");\n                }\n            }\n        }\n\n        // If not, need to read more. If we got any:\n        JsonToken t = delegate.nextToken();\n        if (t == null) {\n            // no strict need to close, since we have no state here\n            _currToken = t;\n            return t;\n        }\n\n        // otherwise... to include or not?\n        TokenFilter f;\n        \n        switch (t.id()) {\n        case ID_START_ARRAY:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartArray();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            _headContext = _headContext.createChildArrayContext(f, false);\n            \n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            break;\n\n        case ID_START_OBJECT:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartObject();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            _headContext = _headContext.createChildObjectContext(f, false);\n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            // note: inclusion of surrounding Object handled separately via\n            // FIELD_NAME\n            break;\n\n        case ID_END_ARRAY:\n        case ID_END_OBJECT:\n            {\n                boolean returnEnd = _headContext.isStartHandled();\n                f = _headContext.getFilter();\n                if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                    f.filterFinishArray();\n                }\n                _headContext = _headContext.getParent();\n                _itemFilter = _headContext.getFilter();\n                if (returnEnd) {\n                    return (_currToken = t);\n                }\n            }\n            break;\n\n        case ID_FIELD_NAME:\n            {\n                final String name = delegate.getCurrentName();\n                // note: this will also set 'needToHandleName'\n                f = _headContext.setFieldName(name);\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _itemFilter = f;\n                    if (!_includePath) {\n                        // Minor twist here: if parent NOT included, may need to induce output of\n                        // surrounding START_OBJECT/END_OBJECT\n                        if (_includeImmediateParent && !_headContext.isStartHandled()) {\n                            t = _headContext.nextTokenToRead(); // returns START_OBJECT but also marks it handled\n                            _exposedContext = _headContext;\n                        }\n                    }\n                    return (_currToken = t);\n                }\n                if (f == null) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                f = f.includeProperty(name);\n                if (f == null) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    if (_includePath) {\n                        return (_currToken = t);\n                    }\n                }\n                if (_includePath) {\n                    t = _nextTokenWithBuffering(_headContext);\n                    if (t != null) {\n                        _currToken = t;\n                        return t;\n                    }\n                }\n                break;\n            }\n\n        default: // scalar value\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                return (_currToken = t);\n            }\n            if (f != null) {\n                f = _headContext.checkValue(f);\n                if ((f == TokenFilter.INCLUDE_ALL)\n                        || ((f != null) && f.includeValue(delegate))) {\n                    return (_currToken = t);\n                }\n            }\n            // Otherwise not included (leaves must be explicitly included)\n            break;\n        }\n\n        // We get here if token was not yet found; offlined handling\n        return _nextToken2();\n    }",
        "javadoc": ""
      }
    },
    "delineated_bug": {
      "0": {
        "start_line": 226,
        "end_line": 454,
        "file": "src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java",
        "code": "@Override\n    public JsonToken nextToken() throws IOException\n    {\n        // 23-May-2017, tatu: To be honest, code here is rather hairy and I don't like all\n        //    conditionals; and it seems odd to return `null` but NOT considering input\n        //    as closed... would love a rewrite to simplify/clear up logic here.\n        \n        // Check for _allowMultipleMatches - false and at least there is one token - which is _currToken\n        // check for no buffered context _exposedContext - null\n        // If all the conditions matches then check for scalar / non-scalar property\n        if (!_allowMultipleMatches && (_currToken != null) && (_exposedContext == null)) {\n            //if not scalar and ended successfully, and !includePath, then return null\n<END_BUG>\n<START_BUG>\n                if (_currToken.isStructEnd()) {\n                    if (_headContext.isStartHandled()) {\n                        return (_currToken = null);\n                    }\n                } else if (_currToken.isScalarValue()) {\n                    //else if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL matched once\n                    // then return null \n                    if (!_headContext.isStartHandled() && (_itemFilter == TokenFilter.INCLUDE_ALL)) {\n                        return (_currToken = null);\n                    }\n<END_BUG>\n<START_BUG>\n            }\n        }\n        // Anything buffered?\n        TokenFilterContext ctxt = _exposedContext;\n\n        if (ctxt != null) {\n            while (true) {\n                JsonToken t = ctxt.nextTokenToRead();\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n                // all done with buffered stuff?\n                if (ctxt == _headContext) {\n                    _exposedContext = null;\n                    if (ctxt.inArray()) {\n                        t = delegate.getCurrentToken();\n// Is this guaranteed to work without further checks?\n//                        if (t != JsonToken.START_ARRAY) {\n                        _currToken = t;\n                        return t;\n                    }\n\n                    // Almost! Most likely still have the current token;\n                    // with the sole exception of \n                    /*\n                    t = delegate.getCurrentToken();\n                    if (t != JsonToken.FIELD_NAME) {\n                        _currToken = t;\n                        return t;\n                    }\n                    */\n                    break;\n                }\n                // If not, traverse down the context chain\n                ctxt = _headContext.findChildOf(ctxt);\n                _exposedContext = ctxt;\n                if (ctxt == null) { // should never occur\n                    throw _constructError(\"Unexpected problem: chain of filtered context broken\");\n                }\n            }\n        }\n\n        // If not, need to read more. If we got any:\n        JsonToken t = delegate.nextToken();\n        if (t == null) {\n            // no strict need to close, since we have no state here\n            _currToken = t;\n            return t;\n        }\n\n        // otherwise... to include or not?\n        TokenFilter f;\n        \n        switch (t.id()) {\n        case ID_START_ARRAY:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartArray();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            _headContext = _headContext.createChildArrayContext(f, false);\n            \n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            break;\n\n        case ID_START_OBJECT:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartObject();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            _headContext = _headContext.createChildObjectContext(f, false);\n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            // note: inclusion of surrounding Object handled separately via\n            // FIELD_NAME\n            break;\n\n        case ID_END_ARRAY:\n        case ID_END_OBJECT:\n            {\n                boolean returnEnd = _headContext.isStartHandled();\n                f = _headContext.getFilter();\n                if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                    f.filterFinishArray();\n                }\n                _headContext = _headContext.getParent();\n                _itemFilter = _headContext.getFilter();\n                if (returnEnd) {\n                    return (_currToken = t);\n                }\n            }\n            break;\n\n        case ID_FIELD_NAME:\n            {\n                final String name = delegate.getCurrentName();\n                // note: this will also set 'needToHandleName'\n                f = _headContext.setFieldName(name);\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _itemFilter = f;\n                    if (!_includePath) {\n                        // Minor twist here: if parent NOT included, may need to induce output of\n                        // surrounding START_OBJECT/END_OBJECT\n                        if (_includeImmediateParent && !_headContext.isStartHandled()) {\n                            t = _headContext.nextTokenToRead(); // returns START_OBJECT but also marks it handled\n                            _exposedContext = _headContext;\n                        }\n                    }\n                    return (_currToken = t);\n                }\n                if (f == null) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                f = f.includeProperty(name);\n                if (f == null) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    if (_includePath) {\n                        return (_currToken = t);\n                    }\n                }\n                if (_includePath) {\n                    t = _nextTokenWithBuffering(_headContext);\n                    if (t != null) {\n                        _currToken = t;\n                        return t;\n                    }\n                }\n                break;\n            }\n\n        default: // scalar value\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                return (_currToken = t);\n            }\n            if (f != null) {\n                f = _headContext.checkValue(f);\n                if ((f == TokenFilter.INCLUDE_ALL)\n                        || ((f != null) && f.includeValue(delegate))) {\n                    return (_currToken = t);\n                }\n            }\n            // Otherwise not included (leaves must be explicitly included)\n            break;\n        }\n\n        // We get here if token was not yet found; offlined handling\n        return _nextToken2();\n    }",
        "javadoc": ""
      }
    },
    "contained_scope": "method",
    "bug_count": 1,
    "triggered_tests": {
      "0": {
        "test_path": "com.fasterxml.jackson.core.filter.TokenVerifyingParserFiltering330Test",
        "test_method": "testTokensSingleMatchWithPath",
        "test_code": "testTokensSingleMatchWithPath() throws Exception\n    {\n        JsonParser p0 = JSON_F.createParser(SIMPLE);\n        JsonParser p = new FilteringParserDelegate(p0,\n               new NameMatchFilter(\"value\"),\n                   true, // includePath\n                   false // multipleMatches\n                );\n\n        assertFalse(p.hasCurrentToken());\n        assertNull(p.getCurrentToken());\n        assertEquals(JsonTokenId.ID_NO_TOKEN, p.getCurrentTokenId());\n        assertFalse(p.isExpectedStartObjectToken());\n        assertFalse(p.isExpectedStartArrayToken());\n        \n// {'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4},'b':true}\n//      String result = readAndWrite(JSON_F, p);\n//      assertEquals(aposToQuotes(\"{'ob':{'value':3}}\"), result);\n\n        assertToken(JsonToken.START_OBJECT, p.nextToken());\n        assertEquals(JsonToken.START_OBJECT, p.getCurrentToken());\n        assertTrue(p.isExpectedStartObjectToken());\n        assertFalse(p.isExpectedStartArrayToken());\n\n        assertToken(JsonToken.FIELD_NAME, p.nextToken());\n        assertEquals(JsonToken.FIELD_NAME, p.getCurrentToken());\n        assertEquals(\"ob\", p.getCurrentName());\n//        assertEquals(\"ob\", p.getText());\n\n        assertToken(JsonToken.START_OBJECT, p.nextToken());\n        assertEquals(\"ob\", p.getCurrentName());\n\n        assertToken(JsonToken.FIELD_NAME, p.nextToken());\n        assertEquals(\"value\", p.getCurrentName());\n        assertEquals(\"value\", p.getText());\n\n        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n        assertEquals(JsonToken.VALUE_NUMBER_INT, p.getCurrentToken());\n        assertEquals(NumberType.INT, p.getNumberType());\n        assertEquals(3, p.getIntValue());\n        assertEquals(\"value\", p.getCurrentName());\n\n        assertToken(JsonToken.END_OBJECT, p.nextToken());\n        assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());\n\n        assertToken(JsonToken.END_OBJECT, p.nextToken());\n        assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());\n\n        p.clearCurrentToken();\n        assertNull(p.getCurrentToken());\n        \n        p.close();\n    }",
        "clean_err_msg": "junit.framework.AssertionFailedError: Expected token END_OBJECT, current token null"
      },
      "1": {
        "test_path": "com.fasterxml.jackson.core.filter.TokenVerifyingParserFiltering330Test",
        "test_method": "testBasicSingleMatchFilteringWithPath",
        "test_code": "testBasicSingleMatchFilteringWithPath() throws Exception\n    {\n        JsonParser p0 = JSON_F.createParser(SIMPLE);\n        JsonParser p = new FilteringParserDelegate(p0,\n               new NameMatchFilter(\"value\"),\n                   true, // includePath\n                   false // multipleMatches\n                );\n\n// {'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4},'b':true}\n        String result = readAndWrite(JSON_F, p);\n        assertEquals(aposToQuotes(\"{'ob':{'value':3}}\"), result);\n    }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<{\"ob\":{\"value\":3}[}]> but was:<{\"ob\":{\"value\":3}[]>"
      },
      "2": {
        "test_path": "com.fasterxml.jackson.core.filter.TokenVerifyingParserFiltering330Test",
        "test_method": "testSkippingForSingleWithPath",
        "test_code": "testSkippingForSingleWithPath() throws Exception\n    {\n        JsonParser p0 = JSON_F.createParser(SIMPLE);\n        JsonParser p = new FilteringParserDelegate(p0,\n               new NameMatchFilter(\"value\"),\n                   true, // includePath\n                   false // multipleMatches\n                );\n\n//        assertEquals(aposToQuotes(\"{'ob':{'value':3}}\"), result);\n\n        assertToken(JsonToken.START_OBJECT, p.nextToken());\n        p.skipChildren();\n        assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());\n        assertNull(p.nextToken());\n    }",
        "clean_err_msg": "junit.framework.AssertionFailedError: expected:<END_OBJECT> but was:<null>"
      }
    },
    "buggy_files": {
      "0": "src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java"
    },
    "hunk_type": "single_file_two_hunks",
    "hunk_mapping": {
      "0": [
        {
          "start_line": 238,
          "end_line": 237,
          "file": "src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java",
          "code": "<START_BUG>\n<END_BUG>"
        },
        {
          "start_line": 248,
          "end_line": 247,
          "file": "src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java",
          "code": "<START_BUG>\n<END_BUG>"
        }
      ]
    },
    "bug_report": {
      "url": "https://github.com/FasterXML/jackson-core/issues/330",
      "title": "FilteringParserDelegate seems to miss last closing END_OBJECT",
      "bug_description": "(note: adding a failing test for this case)\r\n\r\nLooks like with settings like:\r\n\r\n```java\r\n        JsonParser p = new FilteringParserDelegate(p0,\r\n               new NameMatchFilter(\"value\"),\r\n                   true, // includePath\r\n                   false // multipleMatches\r\n                );\r\n```\r\n\r\nand input\r\n\r\n```json\r\n{\r\n  \"a\":123,\r\n  \"array\":[1,2],\r\n  \"ob\": {\r\n    \"value0\":2,\r\n    \"value\":3,\r\n    \"value2\":4\r\n  },\r\n  \"b\":true\r\n}\r\n```\r\n\r\noutput will be like:\r\n\r\n```json\r\n{\"ob\":{\"value\":3}\r\n```\r\n\r\n(note the missing trailing `}` for closing `END_OBJECT`)"
    }
  },
  "Cli_23": {
    "buggy_hunks": {
      "0": {
        "start_line": 824,
        "end_line": 824,
        "file": "src/java/org/apache/commons/cli/HelpFormatter.java",
        "code": "<START_BUG>\n            int lastPos = pos;\n<END_BUG>"
      },
      "1": {
        "start_line": 833,
        "end_line": 836,
        "file": "src/java/org/apache/commons/cli/HelpFormatter.java",
        "code": "<START_BUG>\n            } else\n            if (pos == lastPos)\n            {\n                throw new RuntimeException(\"Text too long for line - throwing exception to avoid infinite loop [CLI-162]: \" + text);\n<END_BUG>"
      }
    },
    "buggy_code": {
      "0": {
        "start_line": 805,
        "end_line": 841,
        "file": "src/java/org/apache/commons/cli/HelpFormatter.java",
        "code": "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        // all following lines must be padded with nextLineTabStop space \n        // characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            int lastPos = pos;\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            } else\n            if (pos == lastPos)\n            {\n                throw new RuntimeException(\"Text too long for line - throwing exception to avoid infinite loop [CLI-162]: \" + text);\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }",
        "javadoc": "/**\n * Render the specified text and return the rendered Options\n * in a StringBuffer.\n *\n * @param sb The StringBuffer to place the rendered text into.\n * @param width The number of characters to display per line\n * @param nextLineTabStop The position on the next line for the first tab.\n * @param text The text to be rendered.\n *\n * @return the StringBuffer with the rendered Options contents.\n */\n"
      }
    },
    "delineated_bug": {
      "0": {
        "start_line": 805,
        "end_line": 841,
        "file": "src/java/org/apache/commons/cli/HelpFormatter.java",
        "code": "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        // all following lines must be padded with nextLineTabStop space \n        // characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n<START_BUG>\n            int lastPos = pos;\n<END_BUG>\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n<START_BUG>\n            } else\n            if (pos == lastPos)\n            {\n                throw new RuntimeException(\"Text too long for line - throwing exception to avoid infinite loop [CLI-162]: \" + text);\n<END_BUG>\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }",
        "javadoc": "/**\n * Render the specified text and return the rendered Options\n * in a StringBuffer.\n *\n * @param sb The StringBuffer to place the rendered text into.\n * @param width The number of characters to display per line\n * @param nextLineTabStop The position on the next line for the first tab.\n * @param text The text to be rendered.\n *\n * @return the StringBuffer with the rendered Options contents.\n */\n"
      }
    },
    "contained_scope": "method",
    "bug_count": 1,
    "triggered_tests": {
      "0": {
        "test_path": "org.apache.commons.cli.bug.BugCLI162Test",
        "test_method": "testInfiniteLoop",
        "test_code": "testInfiniteLoop() {\n        HelpFormatter formatter = new HelpFormatter();\n        formatter.setWidth(20);\n        formatter.printHelp(\"app\", options); // used to hang & crash\n    }",
        "clean_err_msg": "java.lang.RuntimeException: Text too long for line - throwing exception to avoid infinite loop [CLI-162]:              looooong description"
      },
      "1": {
        "test_path": "org.apache.commons.cli.bug.BugCLI162Test",
        "test_method": "testPrintHelpLongLines",
        "test_code": "testPrintHelpLongLines() throws ParseException, IOException {\n        // Constants used for options\n        final String OPT = \"-\";\n\n        final String OPT_COLUMN_NAMES = \"l\";\n\n        final String OPT_CONNECTION = \"c\";\n\n        final String OPT_DESCRIPTION = \"e\";\n\n        final String OPT_DRIVER = \"d\";\n\n        final String OPT_DRIVER_INFO = \"n\";\n\n        final String OPT_FILE_BINDING = \"b\";\n\n        final String OPT_FILE_JDBC = \"j\";\n\n        final String OPT_FILE_SFMD = \"f\";\n\n        final String OPT_HELP = \"h\";\n\n        final String OPT_HELP_ = \"help\";\n\n        final String OPT_INTERACTIVE = \"i\";\n\n        final String OPT_JDBC_TO_SFMD = \"2\";\n\n        final String OPT_JDBC_TO_SFMD_L = \"jdbc2sfmd\";\n\n        final String OPT_METADATA = \"m\";\n\n        final String OPT_PARAM_MODES_INT = \"o\";\n\n        final String OPT_PARAM_MODES_NAME = \"O\";\n\n        final String OPT_PARAM_NAMES = \"a\";\n\n        final String OPT_PARAM_TYPES_INT = \"y\";\n\n        final String OPT_PARAM_TYPES_NAME = \"Y\";\n\n        final String OPT_PASSWORD = \"p\";\n\n        final String OPT_PASSWORD_L = \"password\";\n\n        final String OPT_SQL = \"s\";\n\n        final String OPT_SQL_L = \"sql\";\n\n        final String OPT_SQL_SPLIT_DEFAULT = \"###\";\n\n        final String OPT_SQL_SPLIT_L = \"splitSql\";\n\n        final String OPT_STACK_TRACE = \"t\";\n\n        final String OPT_TIMING = \"g\";\n\n        final String OPT_TRIM_L = \"trim\";\n\n        final String OPT_USER = \"u\";\n\n        final String OPT_WRITE_TO_FILE = \"w\";\n        \n        final String _PMODE_IN = \"IN\";\n\n        final String _PMODE_INOUT = \"INOUT\";\n\n        final String _PMODE_OUT = \"OUT\";\n        \n        final String _PMODE_UNK = \"Unknown\";\n        \n        final String PMODES = _PMODE_IN + \", \" + _PMODE_INOUT + \", \" + _PMODE_OUT + \", \" + _PMODE_UNK;\n        \n        // Options build\n        Options commandLineOptions;\n        commandLineOptions = new Options();\n        commandLineOptions.addOption(OPT_HELP, OPT_HELP_, false, \"Prints help and quits\");\n        commandLineOptions.addOption(OPT_DRIVER, \"driver\", true, \"JDBC driver class name\");\n        commandLineOptions.addOption(OPT_DRIVER_INFO, \"info\", false, \"Prints driver information and properties. If \"\n            + OPT\n            + OPT_CONNECTION\n            + \" is not specified, all drivers on the classpath are displayed.\");\n        commandLineOptions.addOption(OPT_CONNECTION, \"url\", true, \"Connection URL\");\n        commandLineOptions.addOption(OPT_USER, \"user\", true, \"A database user name\");\n        commandLineOptions\n                .addOption(\n                        OPT_PASSWORD,\n                        OPT_PASSWORD_L,\n                        true,\n                        \"The database password for the user specified with the \"\n                            + OPT\n                            + OPT_USER\n                            + \" option. You can obfuscate the password with org.mortbay.jetty.security.Password, see http://docs.codehaus.org/display/JETTY/Securing+Passwords\");\n        commandLineOptions.addOption(OPT_SQL, OPT_SQL_L, true, \"Runs SQL or {call stored_procedure(?, ?)} or {?=call function(?, ?)}\");\n        commandLineOptions.addOption(OPT_FILE_SFMD, \"sfmd\", true, \"Writes a SFMD file for the given SQL\");\n        commandLineOptions.addOption(OPT_FILE_BINDING, \"jdbc\", true, \"Writes a JDBC binding node file for the given SQL\");\n        commandLineOptions.addOption(OPT_FILE_JDBC, \"node\", true, \"Writes a JDBC node file for the given SQL (internal debugging)\");\n        commandLineOptions.addOption(OPT_WRITE_TO_FILE, \"outfile\", true, \"Writes the SQL output to the given file\");\n        commandLineOptions.addOption(OPT_DESCRIPTION, \"description\", true,\n                \"SFMD description. A default description is used if omited. Example: \" + OPT + OPT_DESCRIPTION + \" \\\"Runs such and such\\\"\");\n        commandLineOptions.addOption(OPT_INTERACTIVE, \"interactive\", false,\n                \"Runs in interactive mode, reading and writing from the console, 'go' or '/' sends a statement\");\n        commandLineOptions.addOption(OPT_TIMING, \"printTiming\", false, \"Prints timing information\");\n        commandLineOptions.addOption(OPT_METADATA, \"printMetaData\", false, \"Prints metadata information\");\n        commandLineOptions.addOption(OPT_STACK_TRACE, \"printStack\", false, \"Prints stack traces on errors\");\n        Option option = new Option(OPT_COLUMN_NAMES, \"columnNames\", true, \"Column XML names; default names column labels. Example: \"\n            + OPT\n            + OPT_COLUMN_NAMES\n            + \" \\\"cname1 cname2\\\"\");\n        commandLineOptions.addOption(option);\n        option = new Option(OPT_PARAM_NAMES, \"paramNames\", true, \"Parameter XML names; default names are param1, param2, etc. Example: \"\n            + OPT\n            + OPT_PARAM_NAMES\n            + \" \\\"pname1 pname2\\\"\");\n        commandLineOptions.addOption(option);\n        //\n        OptionGroup pOutTypesOptionGroup = new OptionGroup();\n        String pOutTypesOptionGroupDoc = OPT + OPT_PARAM_TYPES_INT + \" and \" + OPT + OPT_PARAM_TYPES_NAME + \" are mutually exclusive.\";\n        final String typesClassName = Types.class.getName();\n        option = new Option(OPT_PARAM_TYPES_INT, \"paramTypes\", true, \"Parameter types from \"\n            + typesClassName\n            + \". \"\n            + pOutTypesOptionGroupDoc\n            + \" Example: \"\n            + OPT\n            + OPT_PARAM_TYPES_INT\n            + \" \\\"-10 12\\\"\");\n        commandLineOptions.addOption(option);\n        option = new Option(OPT_PARAM_TYPES_NAME, \"paramTypeNames\", true, \"Parameter \"\n            + typesClassName\n            + \" names. \"\n            + pOutTypesOptionGroupDoc\n            + \" Example: \"\n            + OPT\n            + OPT_PARAM_TYPES_NAME\n            + \" \\\"CURSOR VARCHAR\\\"\");\n        commandLineOptions.addOption(option);\n        commandLineOptions.addOptionGroup(pOutTypesOptionGroup);\n        //\n        OptionGroup modesOptionGroup = new OptionGroup();\n        String modesOptionGroupDoc = OPT + OPT_PARAM_MODES_INT + \" and \" + OPT + OPT_PARAM_MODES_NAME + \" are mutually exclusive.\";\n        option = new Option(OPT_PARAM_MODES_INT, \"paramModes\", true, \"Parameters modes (\"\n            + ParameterMetaData.parameterModeIn\n            + \"=IN, \"\n            + ParameterMetaData.parameterModeInOut\n            + \"=INOUT, \"\n            + ParameterMetaData.parameterModeOut\n            + \"=OUT, \"\n            + ParameterMetaData.parameterModeUnknown\n            + \"=Unknown\"\n            + \"). \"\n            + modesOptionGroupDoc\n            + \" Example for 2 parameters, OUT and IN: \"\n            + OPT\n            + OPT_PARAM_MODES_INT\n            + \" \\\"\"\n            + ParameterMetaData.parameterModeOut\n            + \" \"\n            + ParameterMetaData.parameterModeIn\n            + \"\\\"\");\n        modesOptionGroup.addOption(option);\n        option = new Option(OPT_PARAM_MODES_NAME, \"paramModeNames\", true, \"Parameters mode names (\"\n            + PMODES\n            + \"). \"\n            + modesOptionGroupDoc\n            + \" Example for 2 parameters, OUT and IN: \"\n            + OPT\n            + OPT_PARAM_MODES_NAME\n            + \" \\\"\"\n            + _PMODE_OUT\n            + \" \"\n            + _PMODE_IN\n            + \"\\\"\");\n        modesOptionGroup.addOption(option);\n        commandLineOptions.addOptionGroup(modesOptionGroup);\n        option = new Option(null, OPT_TRIM_L, true,\n                \"Trims leading and trailing spaces from all column values. Column XML names can be optionally specified to set which columns to trim.\");\n        option.setOptionalArg(true);\n        commandLineOptions.addOption(option);\n        option = new Option(OPT_JDBC_TO_SFMD, OPT_JDBC_TO_SFMD_L, true,\n                \"Converts the JDBC file in the first argument to an SMFD file specified in the second argument.\");\n        option.setArgs(2);\n        commandLineOptions.addOption(option);\n        this.testPrintHelp(commandLineOptions);\n    }",
        "clean_err_msg": "java.lang.RuntimeException: Text too long for line - throwing exception to avoid infinite loop [CLI-162]:                              used if omited. Example: -e \"Runs such and such\""
      }
    },
    "buggy_files": {
      "0": "src/java/org/apache/commons/cli/HelpFormatter.java"
    },
    "hunk_type": "single_file_two_hunks",
    "hunk_mapping": {
      "0": [
        {
          "start_line": 824,
          "end_line": 824,
          "file": "src/java/org/apache/commons/cli/HelpFormatter.java",
          "code": "<START_BUG>\n            int lastPos = pos;\n<END_BUG>"
        },
        {
          "start_line": 833,
          "end_line": 836,
          "file": "src/java/org/apache/commons/cli/HelpFormatter.java",
          "code": "<START_BUG>\n            } else\n            if (pos == lastPos)\n            {\n                throw new RuntimeException(\"Text too long for line - throwing exception to avoid infinite loop [CLI-162]: \" + text);\n<END_BUG>"
        }
      ]
    },
    "bug_report": {
      "url": "https://issues.apache.org/jira/browse/CLI-162",
      "title": "infinite loop in the wrapping code of HelpFormatter",
      "bug_description": "If there is not enough space to display a word on a single line, HelpFormatter goes into a infinite loops until the JVM crashes with an OutOfMemoryError.\nTest case:\nOptions options =\nnew\nOptions();\noptions.addOption(\n\"h\"\n,\n\"help\"\n,\nfalse\n,\n\"This is a looooong description\"\n);\n\nHelpFormatter formatter =\nnew\nHelpFormatter();\nformatter.setWidth(20);\nformatter.printHelp(\n\"app\"\n, options);\n// hang & crash\nAn helpful exception indicating the insufficient width would be more appropriate than an OutOfMemoryError."
    }
  },
  "Cli_14": {
    "buggy_hunks": {
      "0": {
        "start_line": 250,
        "end_line": 252,
        "file": "src/java/org/apache/commons/cli2/option/GroupImpl.java",
        "code": "<START_BUG>\n            if (validate) {\n                option.validate(commandLine);\n            }\n<END_BUG>"
      },
      "1": {
        "start_line": 261,
        "end_line": 261,
        "file": "src/java/org/apache/commons/cli2/option/GroupImpl.java",
        "code": "<START_BUG>\n\n<END_BUG>"
      }
    },
    "buggy_code": {
      "0": {
        "start_line": 237,
        "end_line": 282,
        "file": "src/java/org/apache/commons/cli2/option/GroupImpl.java",
        "code": "public void validate(final WriteableCommandLine commandLine)\n        throws OptionException {\n        // number of options found\n        int present = 0;\n\n        // reference to first unexpected option\n        Option unexpected = null;\n\n        for (final Iterator i = options.iterator(); i.hasNext();) {\n            final Option option = (Option) i.next();\n\n            // needs validation?\n            boolean validate = option.isRequired() || option instanceof Group;\n            if (validate) {\n                option.validate(commandLine);\n            }\n\n            // if the child option is present then validate it\n            if (commandLine.hasOption(option)) {\n                if (++present > maximum) {\n                    unexpected = option;\n\n                    break;\n                }\n\n                option.validate(commandLine);\n            }\n        }\n\n        // too many options\n        if (unexpected != null) {\n            throw new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN,\n                                      unexpected.getPreferredName());\n        }\n\n        // too few option\n        if (present < minimum) {\n            throw new OptionException(this, ResourceConstants.MISSING_OPTION);\n        }\n\n        // validate each anonymous argument\n        for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n            final Option option = (Option) i.next();\n            option.validate(commandLine);\n        }\n    }",
        "javadoc": ""
      }
    },
    "delineated_bug": {
      "0": {
        "start_line": 237,
        "end_line": 282,
        "file": "src/java/org/apache/commons/cli2/option/GroupImpl.java",
        "code": "public void validate(final WriteableCommandLine commandLine)\n        throws OptionException {\n        // number of options found\n        int present = 0;\n\n        // reference to first unexpected option\n        Option unexpected = null;\n\n        for (final Iterator i = options.iterator(); i.hasNext();) {\n            final Option option = (Option) i.next();\n\n            // needs validation?\n            boolean validate = option.isRequired() || option instanceof Group;\n<START_BUG>\n            if (validate) {\n                option.validate(commandLine);\n            }\n<END_BUG>\n\n            // if the child option is present then validate it\n            if (commandLine.hasOption(option)) {\n                if (++present > maximum) {\n                    unexpected = option;\n\n                    break;\n                }\n<START_BUG>\n\n<END_BUG>\n                option.validate(commandLine);\n            }\n        }\n\n        // too many options\n        if (unexpected != null) {\n            throw new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN,\n                                      unexpected.getPreferredName());\n        }\n\n        // too few option\n        if (present < minimum) {\n            throw new OptionException(this, ResourceConstants.MISSING_OPTION);\n        }\n\n        // validate each anonymous argument\n        for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n            final Option option = (Option) i.next();\n            option.validate(commandLine);\n        }\n    }",
        "javadoc": ""
      }
    },
    "contained_scope": "method",
    "bug_count": 1,
    "triggered_tests": {
      "0": {
        "test_path": "org.apache.commons.cli2.bug.BugCLI144Test",
        "test_method": "testFileValidator",
        "test_code": "testFileValidator() {\n\t\tfinal DefaultOptionBuilder obuilder = new DefaultOptionBuilder();\n        final ArgumentBuilder abuilder = new ArgumentBuilder();\n        final GroupBuilder gbuilder = new GroupBuilder();\n        DefaultOption fileNameOption = obuilder.withShortName(\"f\")\n                .withLongName(\"file-name\").withRequired(true).withDescription(\n                        \"name of an existing file\").withArgument(\n                        abuilder.withName(\"file-name\").withValidator(\n                                FileValidator.getExistingFileInstance())\n                                .create()).create();\n        Group options = gbuilder.withName(\"options\").withOption(fileNameOption)\n                .create();\n        Parser parser = new Parser();\n        parser.setHelpTrigger(\"--help\");\n        parser.setGroup(options);\n\n        final String fileName = \"src/test/org/apache/commons/cli2/bug/BugCLI144Test.java\";\n        CommandLine cl = parser\n                .parseAndHelp(new String[] { \"--file-name\", fileName });\n        assertNotNull(cl);\n        assertEquals(\"Wrong file\", new File(fileName), cl.getValue(fileNameOption));\n\t}",
        "clean_err_msg": "java.lang.ClassCastException: java.io.File cannot be cast to java.lang.String"
      }
    },
    "buggy_files": {
      "0": "src/java/org/apache/commons/cli2/option/GroupImpl.java"
    },
    "hunk_type": "single_file_two_hunks",
    "hunk_mapping": {
      "0": [
        {
          "start_line": 250,
          "end_line": 252,
          "file": "src/java/org/apache/commons/cli2/option/GroupImpl.java",
          "code": "<START_BUG>\n            if (validate) {\n                option.validate(commandLine);\n            }\n<END_BUG>"
        },
        {
          "start_line": 261,
          "end_line": 261,
          "file": "src/java/org/apache/commons/cli2/option/GroupImpl.java",
          "code": "<START_BUG>\n\n<END_BUG>"
        }
      ]
    },
    "bug_report": {
      "url": "https://issues.apache.org/jira/browse/CLI-144",
      "title": "adding a FileValidator results in ClassCastException in parser.parseAndHelp(args)",
      "bug_description": "When I add a FileValidator.getExistingFileInstance() to an Argument, I get a ClassCastException when I parse args.\nBelow is a testcase invoke with\njava org.apache.commons.cli2.issues.CLI2Sample -classpath commons-cli-2.0-SNAPSHOT.jar --file-name path-to-an-existing-file\nRun it and you get:\nException in thread \"main\" java.lang.ClassCastException: java.io.File cannot be cast to java.lang.String\nat org.apache.commons.cli2.validation.FileValidator.validate(FileValidator.java:122)\nat org.apache.commons.cli2.option.ArgumentImpl.validate(ArgumentImpl.java:250)\nat org.apache.commons.cli2.option.ParentImpl.validate(ParentImpl.java:123)\nat org.apache.commons.cli2.option.DefaultOption.validate(DefaultOption.java:175)\nat org.apache.commons.cli2.option.GroupImpl.validate(GroupImpl.java:264)\nat org.apache.commons.cli2.commandline.Parser.parse(Parser.java:105)\nat org.apache.commons.cli2.commandline.Parser.parseAndHelp(Parser.java:125)\nat org.apache.commons.cli2.issues.CLI2Sample.main(CLI2Sample.java:38)\nComment out the withValidator call and it runs with no exception.\nI also get a similar ClassCastException if I add a\n.withValidator(NumberValidator.getIntegerInstance())\nto another option/argument.\nHere is the source\npackage org.apache.commons.cli2.issues;\nimport java.io.File;\nimport org.apache.commons.cli2.CommandLine;\nimport org.apache.commons.cli2.Group;\nimport org.apache.commons.cli2.builder.ArgumentBuilder;\nimport org.apache.commons.cli2.builder.DefaultOptionBuilder;\nimport org.apache.commons.cli2.builder.GroupBuilder;\nimport org.apache.commons.cli2.commandline.Parser;\nimport org.apache.commons.cli2.option.DefaultOption;\nimport org.apache.commons.cli2.validation.FileValidator;\npublic class CLI2Sample\n{\npublic static void main(String[] args)\n{\n      final DefaultOptionBuilder obuilder = new DefaultOptionBuilder();\n      final ArgumentBuilder abuilder = new ArgumentBuilder();\n      final GroupBuilder gbuilder = new GroupBuilder();\n      DefaultOption fileNameOption = obuilder\n            .withShortName(\"f\")\n            .withLongName(\"file-name\")\n            .withRequired(true)\n            .withDescription(\"name of an existing file\")\n            .withArgument(abuilder\n                  .withName(\"file-name\")\n                  .withValidator(FileValidator.getExistingFileInstance())\n                  .create())\n            .create();\n      Group options = gbuilder\n            .withName(\"options\")\n            .withOption(fileNameOption)\n            .create();\n      Parser parser = new Parser();\n      parser.setHelpTrigger(\"--help\");\n      parser.setGroup(options);\n      CommandLine cl = parser.parseAndHelp(args);\n     }\n}"
    }
  },
  "Time_23": {
    "buggy_hunks": {
      "0": {
        "start_line": 564,
        "end_line": 563,
        "file": "src/main/java/org/joda/time/DateTimeZone.java",
        "code": "<START_BUG>\n<END_BUG>"
      },
      "1": {
        "start_line": 572,
        "end_line": 588,
        "file": "src/main/java/org/joda/time/DateTimeZone.java",
        "code": "<START_BUG>\n            map.put(\"IET\", \"America/Indianapolis\");\n            map.put(\"PRT\", \"America/Puerto_Rico\");\n            map.put(\"CNT\", \"America/St_Johns\");\n            map.put(\"AGT\", \"America/Buenos_Aires\");\n            map.put(\"BET\", \"America/Sao_Paulo\");\n            map.put(\"WET\", \"Europe/London\");\n            map.put(\"ECT\", \"Europe/Paris\");\n            map.put(\"ART\", \"Africa/Cairo\");\n            map.put(\"CAT\", \"Africa/Harare\");\n            map.put(\"EET\", \"Europe/Bucharest\");\n            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n            map.put(\"MET\", \"Asia/Tehran\");\n            map.put(\"NET\", \"Asia/Yerevan\");\n            map.put(\"PLT\", \"Asia/Karachi\");\n            map.put(\"IST\", \"Asia/Calcutta\");\n            map.put(\"BST\", \"Asia/Dhaka\");\n            map.put(\"VST\", \"Asia/Saigon\");\n<END_BUG>"
      }
    },
    "buggy_code": {
      "0": {
        "start_line": 558,
        "end_line": 598,
        "file": "src/main/java/org/joda/time/DateTimeZone.java",
        "code": "private static synchronized String getConvertedId(String id) {\n        Map<String, String> map = cZoneIdConversion;\n        if (map == null) {\n            // Backwards compatibility with TimeZone.\n            map = new HashMap<String, String>();\n            map.put(\"GMT\", \"UTC\");\n            map.put(\"MIT\", \"Pacific/Apia\");\n            map.put(\"HST\", \"Pacific/Honolulu\");  // JDK 1.1 compatible\n            map.put(\"AST\", \"America/Anchorage\");\n            map.put(\"PST\", \"America/Los_Angeles\");\n            map.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\n            map.put(\"PNT\", \"America/Phoenix\");\n            map.put(\"CST\", \"America/Chicago\");\n            map.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\n            map.put(\"IET\", \"America/Indianapolis\");\n            map.put(\"PRT\", \"America/Puerto_Rico\");\n            map.put(\"CNT\", \"America/St_Johns\");\n            map.put(\"AGT\", \"America/Buenos_Aires\");\n            map.put(\"BET\", \"America/Sao_Paulo\");\n            map.put(\"WET\", \"Europe/London\");\n            map.put(\"ECT\", \"Europe/Paris\");\n            map.put(\"ART\", \"Africa/Cairo\");\n            map.put(\"CAT\", \"Africa/Harare\");\n            map.put(\"EET\", \"Europe/Bucharest\");\n            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n            map.put(\"MET\", \"Asia/Tehran\");\n            map.put(\"NET\", \"Asia/Yerevan\");\n            map.put(\"PLT\", \"Asia/Karachi\");\n            map.put(\"IST\", \"Asia/Calcutta\");\n            map.put(\"BST\", \"Asia/Dhaka\");\n            map.put(\"VST\", \"Asia/Saigon\");\n            map.put(\"CTT\", \"Asia/Shanghai\");\n            map.put(\"JST\", \"Asia/Tokyo\");\n            map.put(\"ACT\", \"Australia/Darwin\");\n            map.put(\"AET\", \"Australia/Sydney\");\n            map.put(\"SST\", \"Pacific/Guadalcanal\");\n            map.put(\"NST\", \"Pacific/Auckland\");\n            cZoneIdConversion = map;\n        }\n        return map.get(id);\n    }",
        "javadoc": "/**\n * Converts an old style id to a new style id.\n *\n * @param id  the old style id\n * @return the new style id, null if not found\n */\n"
      }
    },
    "delineated_bug": {
      "0": {
        "start_line": 558,
        "end_line": 598,
        "file": "src/main/java/org/joda/time/DateTimeZone.java",
        "code": "private static synchronized String getConvertedId(String id) {\n        Map<String, String> map = cZoneIdConversion;\n        if (map == null) {\n            // Backwards compatibility with TimeZone.\n            map = new HashMap<String, String>();\n            map.put(\"GMT\", \"UTC\");\n<END_BUG>\n<START_BUG>\n            map.put(\"MIT\", \"Pacific/Apia\");\n            map.put(\"HST\", \"Pacific/Honolulu\");  // JDK 1.1 compatible\n            map.put(\"AST\", \"America/Anchorage\");\n            map.put(\"PST\", \"America/Los_Angeles\");\n            map.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\n            map.put(\"PNT\", \"America/Phoenix\");\n            map.put(\"CST\", \"America/Chicago\");\n            map.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\n<START_BUG>\n            map.put(\"IET\", \"America/Indianapolis\");\n            map.put(\"PRT\", \"America/Puerto_Rico\");\n            map.put(\"CNT\", \"America/St_Johns\");\n            map.put(\"AGT\", \"America/Buenos_Aires\");\n            map.put(\"BET\", \"America/Sao_Paulo\");\n            map.put(\"WET\", \"Europe/London\");\n            map.put(\"ECT\", \"Europe/Paris\");\n            map.put(\"ART\", \"Africa/Cairo\");\n            map.put(\"CAT\", \"Africa/Harare\");\n            map.put(\"EET\", \"Europe/Bucharest\");\n            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n            map.put(\"MET\", \"Asia/Tehran\");\n            map.put(\"NET\", \"Asia/Yerevan\");\n            map.put(\"PLT\", \"Asia/Karachi\");\n            map.put(\"IST\", \"Asia/Calcutta\");\n            map.put(\"BST\", \"Asia/Dhaka\");\n            map.put(\"VST\", \"Asia/Saigon\");\n<END_BUG>\n            map.put(\"CTT\", \"Asia/Shanghai\");\n            map.put(\"JST\", \"Asia/Tokyo\");\n            map.put(\"ACT\", \"Australia/Darwin\");\n            map.put(\"AET\", \"Australia/Sydney\");\n            map.put(\"SST\", \"Pacific/Guadalcanal\");\n            map.put(\"NST\", \"Pacific/Auckland\");\n            cZoneIdConversion = map;\n        }\n        return map.get(id);\n    }",
        "javadoc": "/**\n * Converts an old style id to a new style id.\n *\n * @param id  the old style id\n * @return the new style id, null if not found\n */\n"
      }
    },
    "contained_scope": "method",
    "bug_count": 1,
    "triggered_tests": {
      "0": {
        "test_path": "org.joda.time.TestDateTimeZone",
        "test_method": "testForID_String_old",
        "test_code": "testForID_String_old() {\n        Map<String, String> map = new LinkedHashMap<String, String>();\n        map.put(\"GMT\", \"UTC\");\n        map.put(\"WET\", \"WET\");\n        map.put(\"CET\", \"CET\");\n        map.put(\"MET\", \"CET\");\n        map.put(\"ECT\", \"CET\");\n        map.put(\"EET\", \"EET\");\n        map.put(\"MIT\", \"Pacific/Apia\");\n        map.put(\"HST\", \"Pacific/Honolulu\");\n        map.put(\"AST\", \"America/Anchorage\");\n        map.put(\"PST\", \"America/Los_Angeles\");\n        map.put(\"MST\", \"America/Denver\");\n        map.put(\"PNT\", \"America/Phoenix\");\n        map.put(\"CST\", \"America/Chicago\");\n        map.put(\"EST\", \"America/New_York\");\n        map.put(\"IET\", \"America/Indiana/Indianapolis\");\n        map.put(\"PRT\", \"America/Puerto_Rico\");\n        map.put(\"CNT\", \"America/St_Johns\");\n        map.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\n        map.put(\"BET\", \"America/Sao_Paulo\");\n        map.put(\"ART\", \"Africa/Cairo\");\n        map.put(\"CAT\", \"Africa/Harare\");\n        map.put(\"EAT\", \"Africa/Addis_Ababa\");\n        map.put(\"NET\", \"Asia/Yerevan\");\n        map.put(\"PLT\", \"Asia/Karachi\");\n        map.put(\"IST\", \"Asia/Kolkata\");\n        map.put(\"BST\", \"Asia/Dhaka\");\n        map.put(\"VST\", \"Asia/Ho_Chi_Minh\");\n        map.put(\"CTT\", \"Asia/Shanghai\");\n        map.put(\"JST\", \"Asia/Tokyo\");\n        map.put(\"ACT\", \"Australia/Darwin\");\n        map.put(\"AET\", \"Australia/Sydney\");\n        map.put(\"SST\", \"Pacific/Guadalcanal\");\n        map.put(\"NST\", \"Pacific/Auckland\");\n        for (String key : map.keySet()) {\n            String value = map.get(key);\n            TimeZone juZone = TimeZone.getTimeZone(key);\n            DateTimeZone zone = DateTimeZone.forTimeZone(juZone);\n            assertEquals(value, zone.getID());\n//            System.out.println(juZone);\n//            System.out.println(juZone.getDisplayName());\n//            System.out.println(zone);\n//            System.out.println(\"------\");\n        }\n    }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<[WET]> but was:<[Europe/London]>"
      }
    },
    "buggy_files": {
      "0": "src/main/java/org/joda/time/DateTimeZone.java"
    },
    "hunk_type": "single_file_two_hunks",
    "hunk_mapping": {
      "0": [
        {
          "start_line": 564,
          "end_line": 563,
          "file": "src/main/java/org/joda/time/DateTimeZone.java",
          "code": "<START_BUG>\n<END_BUG>"
        },
        {
          "start_line": 572,
          "end_line": 588,
          "file": "src/main/java/org/joda/time/DateTimeZone.java",
          "code": "<START_BUG>\n            map.put(\"IET\", \"America/Indianapolis\");\n            map.put(\"PRT\", \"America/Puerto_Rico\");\n            map.put(\"CNT\", \"America/St_Johns\");\n            map.put(\"AGT\", \"America/Buenos_Aires\");\n            map.put(\"BET\", \"America/Sao_Paulo\");\n            map.put(\"WET\", \"Europe/London\");\n            map.put(\"ECT\", \"Europe/Paris\");\n            map.put(\"ART\", \"Africa/Cairo\");\n            map.put(\"CAT\", \"Africa/Harare\");\n            map.put(\"EET\", \"Europe/Bucharest\");\n            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n            map.put(\"MET\", \"Asia/Tehran\");\n            map.put(\"NET\", \"Asia/Yerevan\");\n            map.put(\"PLT\", \"Asia/Karachi\");\n            map.put(\"IST\", \"Asia/Calcutta\");\n            map.put(\"BST\", \"Asia/Dhaka\");\n            map.put(\"VST\", \"Asia/Saigon\");\n<END_BUG>"
        }
      ]
    },
    "bug_report": {
      "url": "https://sourceforge.net/p/joda-time/bugs/112",
      "title": "Incorrect mapping of the MET time zone",
      "bug_description": "This timezone is mapped to Asia/Tehran in DateTimeZone. It should be middle europena time."
    }
  },
  "Closure_53": {
    "buggy_hunks": {
      "0": {
        "start_line": 331,
        "end_line": 330,
        "file": "src/com/google/javascript/jscomp/InlineObjectLiterals.java",
        "code": "<START_BUG>\n<END_BUG>"
      },
      "1": {
        "start_line": 350,
        "end_line": 349,
        "file": "src/com/google/javascript/jscomp/InlineObjectLiterals.java",
        "code": "<START_BUG>\n<END_BUG>"
      }
    },
    "buggy_code": {
      "0": {
        "start_line": 303,
        "end_line": 360,
        "file": "src/com/google/javascript/jscomp/InlineObjectLiterals.java",
        "code": "private void replaceAssignmentExpression(Var v, Reference ref,\n                                             Map<String, String> varmap) {\n      // Compute all of the assignments necessary\n      List<Node> nodes = Lists.newArrayList();\n      Node val = ref.getAssignedValue();\n      blacklistVarReferencesInTree(val, v.scope);\n      Preconditions.checkState(val.getType() == Token.OBJECTLIT);\n      Set<String> all = Sets.newLinkedHashSet(varmap.keySet());\n      for (Node key = val.getFirstChild(); key != null;\n           key = key.getNext()) {\n        String var = key.getString();\n        Node value = key.removeFirstChild();\n        // TODO(user): Copy type information.\n        nodes.add(\n          new Node(Token.ASSIGN,\n                   Node.newString(Token.NAME, varmap.get(var)), value));\n        all.remove(var);\n      }\n\n      // TODO(user): Better source information.\n      for (String var : all) {\n        nodes.add(\n          new Node(Token.ASSIGN,\n                   Node.newString(Token.NAME, varmap.get(var)),\n                   NodeUtil.newUndefinedNode(null)));\n      }\n\n      Node replacement;\n        // All assignments evaluate to true, so make sure that the\n        // expr statement evaluates to true in case it matters.\n        nodes.add(new Node(Token.TRUE));\n\n        // Join these using COMMA.  A COMMA node must have 2 children, so we\n        // create a tree. In the tree the first child be the COMMA to match\n        // the parser, otherwise tree equality tests fail.\n        nodes = Lists.reverse(nodes);\n        replacement = new Node(Token.COMMA);\n        Node cur = replacement;\n        int i;\n        for (i = 0; i < nodes.size() - 2; i++) {\n          cur.addChildToFront(nodes.get(i));\n          Node t = new Node(Token.COMMA);\n          cur.addChildToFront(t);\n          cur = t;\n        }\n        cur.addChildToFront(nodes.get(i));\n        cur.addChildToFront(nodes.get(i + 1));\n\n      Node replace = ref.getParent();\n      replacement.copyInformationFromForTree(replace);\n\n      if (replace.getType() == Token.VAR) {\n        replace.getParent().replaceChild(\n            replace, NodeUtil.newExpr(replacement));\n      } else {\n        replace.getParent().replaceChild(replace, replacement);\n      }\n    }",
        "javadoc": "/**\n * Replaces an assignment like x = {...} with t1=a,t2=b,t3=c,true.\n * Note that the resulting expression will always evaluate to\n * true, as would the x = {...} expression.\n */\n"
      }
    },
    "delineated_bug": {
      "0": {
        "start_line": 303,
        "end_line": 360,
        "file": "src/com/google/javascript/jscomp/InlineObjectLiterals.java",
        "code": "private void replaceAssignmentExpression(Var v, Reference ref,\n                                             Map<String, String> varmap) {\n      // Compute all of the assignments necessary\n      List<Node> nodes = Lists.newArrayList();\n      Node val = ref.getAssignedValue();\n      blacklistVarReferencesInTree(val, v.scope);\n      Preconditions.checkState(val.getType() == Token.OBJECTLIT);\n      Set<String> all = Sets.newLinkedHashSet(varmap.keySet());\n      for (Node key = val.getFirstChild(); key != null;\n           key = key.getNext()) {\n        String var = key.getString();\n        Node value = key.removeFirstChild();\n        // TODO(user): Copy type information.\n        nodes.add(\n          new Node(Token.ASSIGN,\n                   Node.newString(Token.NAME, varmap.get(var)), value));\n        all.remove(var);\n      }\n\n      // TODO(user): Better source information.\n      for (String var : all) {\n        nodes.add(\n          new Node(Token.ASSIGN,\n                   Node.newString(Token.NAME, varmap.get(var)),\n                   NodeUtil.newUndefinedNode(null)));\n      }\n\n      Node replacement;\n<END_BUG>\n<START_BUG>\n        // All assignments evaluate to true, so make sure that the\n        // expr statement evaluates to true in case it matters.\n        nodes.add(new Node(Token.TRUE));\n\n        // Join these using COMMA.  A COMMA node must have 2 children, so we\n        // create a tree. In the tree the first child be the COMMA to match\n        // the parser, otherwise tree equality tests fail.\n        nodes = Lists.reverse(nodes);\n        replacement = new Node(Token.COMMA);\n        Node cur = replacement;\n        int i;\n        for (i = 0; i < nodes.size() - 2; i++) {\n          cur.addChildToFront(nodes.get(i));\n          Node t = new Node(Token.COMMA);\n          cur.addChildToFront(t);\n          cur = t;\n        }\n        cur.addChildToFront(nodes.get(i));\n        cur.addChildToFront(nodes.get(i + 1));\n<END_BUG>\n<START_BUG>\n\n      Node replace = ref.getParent();\n      replacement.copyInformationFromForTree(replace);\n\n      if (replace.getType() == Token.VAR) {\n        replace.getParent().replaceChild(\n            replace, NodeUtil.newExpr(replacement));\n      } else {\n        replace.getParent().replaceChild(replace, replacement);\n      }\n    }",
        "javadoc": "/**\n * Replaces an assignment like x = {...} with t1=a,t2=b,t3=c,true.\n * Note that the resulting expression will always evaluate to\n * true, as would the x = {...} expression.\n */\n"
      }
    },
    "contained_scope": "method",
    "bug_count": 1,
    "triggered_tests": {
      "0": {
        "test_path": "com.google.javascript.jscomp.InlineObjectLiteralsTest",
        "test_method": "testBug545",
        "test_code": "testBug545() {\n    testLocal(\"var a = {}\", \"\");\n    testLocal(\"var a; a = {}\", \"true\");\n  }",
        "clean_err_msg": "java.lang.RuntimeException: INTERNAL COMPILER ERROR."
      }
    },
    "buggy_files": {
      "0": "src/com/google/javascript/jscomp/InlineObjectLiterals.java"
    },
    "hunk_type": "single_file_two_hunks",
    "hunk_mapping": {
      "0": [
        {
          "start_line": 331,
          "end_line": 330,
          "file": "src/com/google/javascript/jscomp/InlineObjectLiterals.java",
          "code": "<START_BUG>\n<END_BUG>"
        },
        {
          "start_line": 350,
          "end_line": 349,
          "file": "src/com/google/javascript/jscomp/InlineObjectLiterals.java",
          "code": "<START_BUG>\n<END_BUG>"
        }
      ]
    },
    "bug_report": {
      "url": "https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-545.json",
      "bug_description": "compiler-20110811 crashes with index(1) must be less than size(1)",
      "title": ""
    }
  },
  "Closure_99": {
    "buggy_hunks": {
      "0": {
        "start_line": 92,
        "end_line": 91,
        "file": "src/com/google/javascript/jscomp/CheckGlobalThis.java",
        "code": "<START_BUG>\n<END_BUG>"
      },
      "1": {
        "start_line": 125,
        "end_line": 131,
        "file": "src/com/google/javascript/jscomp/CheckGlobalThis.java",
        "code": "<START_BUG>\n          if (lhs.getType() == Token.GETPROP &&\n              lhs.getLastChild().getString().equals(\"prototype\")) {\n            return false;\n          }\n          if (lhs.getQualifiedName() != null && lhs.getQualifiedName().contains(\".prototype.\")) {\n            return false;\n          }\n<END_BUG>"
      }
    },
    "buggy_code": {
      "0": {
        "start_line": 84,
        "end_line": 136,
        "file": "src/com/google/javascript/jscomp/CheckGlobalThis.java",
        "code": "public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n\n    if (n.getType() == Token.FUNCTION) {\n      // Don't traverse functions that are constructors or have the @this\n      // or @override annotation.\n      JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n      if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }\n\n      // Don't traverse functions unless they would normally\n      // be able to have a @this annotation associated with them. e.g.,\n      // var a = function() { }; // or\n      // function a() {} // or\n      // a.x = function() {};\n      int pType = parent.getType();\n      if (!(pType == Token.BLOCK ||\n            pType == Token.SCRIPT ||\n            pType == Token.NAME ||\n            pType == Token.ASSIGN)) {\n        return false;\n      }\n    }\n\n    if (parent != null && parent.getType() == Token.ASSIGN) {\n      Node lhs = parent.getFirstChild();\n      Node rhs = lhs.getNext();\n      \n      if (n == lhs) {\n        // Always traverse the left side of the assignment. To handle\n        // nested assignments properly (e.g., (a = this).property = c;),\n        // assignLhsChild should not be overridden.\n        if (assignLhsChild == null) {\n          assignLhsChild = lhs;\n        }\n      } else {\n        // Only traverse the right side if it's not an assignment to a prototype\n        // property or subproperty.\n          if (lhs.getType() == Token.GETPROP &&\n              lhs.getLastChild().getString().equals(\"prototype\")) {\n            return false;\n          }\n          if (lhs.getQualifiedName() != null && lhs.getQualifiedName().contains(\".prototype.\")) {\n            return false;\n          }\n      }\n    }\n\n    return true;\n  }",
        "javadoc": "/**\n * Since this pass reports errors only when a global {@code this} keyword\n * is encountered, there is no reason to traverse non global contexts.\n */\n"
      }
    },
    "delineated_bug": {
      "0": {
        "start_line": 84,
        "end_line": 136,
        "file": "src/com/google/javascript/jscomp/CheckGlobalThis.java",
        "code": "public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n\n    if (n.getType() == Token.FUNCTION) {\n      // Don't traverse functions that are constructors or have the @this\n      // or @override annotation.\n      JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n      if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n<END_BUG>\n<START_BUG>\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }\n\n      // Don't traverse functions unless they would normally\n      // be able to have a @this annotation associated with them. e.g.,\n      // var a = function() { }; // or\n      // function a() {} // or\n      // a.x = function() {};\n      int pType = parent.getType();\n      if (!(pType == Token.BLOCK ||\n            pType == Token.SCRIPT ||\n            pType == Token.NAME ||\n            pType == Token.ASSIGN)) {\n        return false;\n      }\n    }\n\n    if (parent != null && parent.getType() == Token.ASSIGN) {\n      Node lhs = parent.getFirstChild();\n      Node rhs = lhs.getNext();\n      \n      if (n == lhs) {\n        // Always traverse the left side of the assignment. To handle\n        // nested assignments properly (e.g., (a = this).property = c;),\n        // assignLhsChild should not be overridden.\n        if (assignLhsChild == null) {\n          assignLhsChild = lhs;\n        }\n      } else {\n        // Only traverse the right side if it's not an assignment to a prototype\n        // property or subproperty.\n<START_BUG>\n          if (lhs.getType() == Token.GETPROP &&\n              lhs.getLastChild().getString().equals(\"prototype\")) {\n            return false;\n          }\n          if (lhs.getQualifiedName() != null && lhs.getQualifiedName().contains(\".prototype.\")) {\n            return false;\n          }\n<END_BUG>\n      }\n    }\n\n    return true;\n  }",
        "javadoc": "/**\n * Since this pass reports errors only when a global {@code this} keyword\n * is encountered, there is no reason to traverse non global contexts.\n */\n"
      }
    },
    "contained_scope": "method",
    "bug_count": 1,
    "triggered_tests": {
      "0": {
        "test_path": "com.google.javascript.jscomp.CheckGlobalThisTest",
        "test_method": "testPropertyOfMethod",
        "test_code": "testPropertyOfMethod() {\n    testFailure(\"a.protoype.b = {}; \" +\n        \"a.prototype.b.c = function() { this.foo = 3; };\");\n  }",
        "clean_err_msg": "junit.framework.AssertionFailedError: There should be one error.  expected:<1> but was:<0>"
      },
      "1": {
        "test_path": "com.google.javascript.jscomp.CheckGlobalThisTest",
        "test_method": "testMethod4",
        "test_code": "testMethod4() {\n    testSame(\"a.prototype['x' + 'y'] =  function() { this.foo = 3; };\");\n  }",
        "clean_err_msg": "junit.framework.AssertionFailedError: Unexpected error(s): JSC_USED_GLOBAL_THIS. dangerous use of the global this object at testcode line 1 : 39 expected:<0> but was:<1>"
      },
      "2": {
        "test_path": "com.google.javascript.jscomp.CheckGlobalThisTest",
        "test_method": "testInterface1",
        "test_code": "testInterface1() {\n    testSame(\n        \"/** @interface */function A() { /** @type {string} */ this.m2; }\");\n  }",
        "clean_err_msg": "junit.framework.AssertionFailedError: Unexpected error(s): JSC_USED_GLOBAL_THIS. dangerous use of the global this object at testcode line 1 : 54 expected:<0> but was:<1>"
      }
    },
    "buggy_files": {
      "0": "src/com/google/javascript/jscomp/CheckGlobalThis.java"
    },
    "hunk_type": "single_file_two_hunks",
    "hunk_mapping": {
      "0": [
        {
          "start_line": 92,
          "end_line": 91,
          "file": "src/com/google/javascript/jscomp/CheckGlobalThis.java",
          "code": "<START_BUG>\n<END_BUG>"
        },
        {
          "start_line": 125,
          "end_line": 131,
          "file": "src/com/google/javascript/jscomp/CheckGlobalThis.java",
          "code": "<START_BUG>\n          if (lhs.getType() == Token.GETPROP &&\n              lhs.getLastChild().getString().equals(\"prototype\")) {\n            return false;\n          }\n          if (lhs.getQualifiedName() != null && lhs.getQualifiedName().contains(\".prototype.\")) {\n            return false;\n          }\n<END_BUG>"
        }
      ]
    },
    "bug_report": {
      "url": "https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-125.json",
      "bug_description": "Prototypes declared with quotes produce a JSC_USED_GLOBAL_THIS warning.",
      "title": ""
    }
  },
  "Jsoup_42": {
    "buggy_hunks": {
      "0": {
        "start_line": 80,
        "end_line": 79,
        "file": "src/main/java/org/jsoup/nodes/FormElement.java",
        "code": "<START_BUG>\n<END_BUG>"
      },
      "1": {
        "start_line": 99,
        "end_line": 99,
        "file": "src/main/java/org/jsoup/nodes/FormElement.java",
        "code": "<START_BUG>\n                    final String val = el.val();\n<END_BUG>"
      }
    },
    "buggy_code": {
      "0": {
        "start_line": 74,
        "end_line": 107,
        "file": "src/main/java/org/jsoup/nodes/FormElement.java",
        "code": "public List<Connection.KeyVal> formData() {\n        ArrayList<Connection.KeyVal> data = new ArrayList<Connection.KeyVal>();\n\n        // iterate the form control elements and accumulate their values\n        for (Element el: elements) {\n            if (!el.tag().isFormSubmittable()) continue; // contents are form listable, superset of submitable\n            String name = el.attr(\"name\");\n            if (name.length() == 0) continue;\n            String type = el.attr(\"type\");\n\n            if (\"select\".equals(el.tagName())) {\n                Elements options = el.select(\"option[selected]\");\n                boolean set = false;\n                for (Element option: options) {\n                    data.add(HttpConnection.KeyVal.create(name, option.val()));\n                    set = true;\n                }\n                if (!set) {\n                    Element option = el.select(\"option\").first();\n                    if (option != null)\n                        data.add(HttpConnection.KeyVal.create(name, option.val()));\n                }\n            } else if (\"checkbox\".equalsIgnoreCase(type) || \"radio\".equalsIgnoreCase(type)) {\n                // only add checkbox or radio if they have the checked attribute\n                if (el.hasAttr(\"checked\")) {\n                    final String val = el.val();\n                    data.add(HttpConnection.KeyVal.create(name, val));\n                }\n            } else {\n                data.add(HttpConnection.KeyVal.create(name, el.val()));\n            }\n        }\n        return data;\n    }",
        "javadoc": "/**\n * Get the data that this form submits. The returned list is a copy of the data, and changes to the contents of the\n * list will not be reflected in the DOM.\n * @return a list of key vals\n */\n"
      }
    },
    "delineated_bug": {
      "0": {
        "start_line": 74,
        "end_line": 107,
        "file": "src/main/java/org/jsoup/nodes/FormElement.java",
        "code": "public List<Connection.KeyVal> formData() {\n        ArrayList<Connection.KeyVal> data = new ArrayList<Connection.KeyVal>();\n\n        // iterate the form control elements and accumulate their values\n        for (Element el: elements) {\n            if (!el.tag().isFormSubmittable()) continue; // contents are form listable, superset of submitable\n<END_BUG>\n<START_BUG>\n            String name = el.attr(\"name\");\n            if (name.length() == 0) continue;\n            String type = el.attr(\"type\");\n\n            if (\"select\".equals(el.tagName())) {\n                Elements options = el.select(\"option[selected]\");\n                boolean set = false;\n                for (Element option: options) {\n                    data.add(HttpConnection.KeyVal.create(name, option.val()));\n                    set = true;\n                }\n                if (!set) {\n                    Element option = el.select(\"option\").first();\n                    if (option != null)\n                        data.add(HttpConnection.KeyVal.create(name, option.val()));\n                }\n            } else if (\"checkbox\".equalsIgnoreCase(type) || \"radio\".equalsIgnoreCase(type)) {\n                // only add checkbox or radio if they have the checked attribute\n                if (el.hasAttr(\"checked\")) {\n<START_BUG>\n                    final String val = el.val();\n<END_BUG>\n                    data.add(HttpConnection.KeyVal.create(name, val));\n                }\n            } else {\n                data.add(HttpConnection.KeyVal.create(name, el.val()));\n            }\n        }\n        return data;\n    }",
        "javadoc": "/**\n * Get the data that this form submits. The returned list is a copy of the data, and changes to the contents of the\n * list will not be reflected in the DOM.\n * @return a list of key vals\n */\n"
      }
    },
    "contained_scope": "method",
    "bug_count": 1,
    "triggered_tests": {
      "0": {
        "test_path": "org.jsoup.nodes.FormElementTest",
        "test_method": "createsFormData",
        "test_code": "createsFormData() {\n        String html = \"<form><input name='one' value='two'><select name='three'><option value='not'>\" +\n                \"<option value='four' selected><option value='five' selected><textarea name=six>seven</textarea>\" +\n                \"<input name='seven' type='radio' value='on' checked><input name='seven' type='radio' value='off'>\" +\n                \"<input name='eight' type='checkbox' checked><input name='nine' type='checkbox' value='unset'>\" +\n                \"<input name='ten' value='text' disabled>\" +\n                \"</form>\";\n        Document doc = Jsoup.parse(html);\n        FormElement form = (FormElement) doc.select(\"form\").first();\n        List<Connection.KeyVal> data = form.formData();\n\n        assertEquals(6, data.size());\n        assertEquals(\"one=two\", data.get(0).toString());\n        assertEquals(\"three=four\", data.get(1).toString());\n        assertEquals(\"three=five\", data.get(2).toString());\n        assertEquals(\"six=seven\", data.get(3).toString());\n        assertEquals(\"seven=on\", data.get(4).toString()); // set\n        assertEquals(\"eight=on\", data.get(5).toString()); // default\n        // nine should not appear, not checked checkbox\n        // ten should not appear, disabled\n    }",
        "clean_err_msg": "junit.framework.AssertionFailedError: expected:<6> but was:<7>"
      },
      "1": {
        "test_path": "org.jsoup.nodes.FormElementTest",
        "test_method": "usesOnForCheckboxValueIfNoValueSet",
        "test_code": "usesOnForCheckboxValueIfNoValueSet() {\n        Document doc = Jsoup.parse(\"<form><input type=checkbox checked name=foo></form>\");\n        FormElement form = (FormElement) doc.select(\"form\").first();\n        List<Connection.KeyVal> data = form.formData();\n        assertEquals(\"on\", data.get(0).value());\n        assertEquals(\"foo\", data.get(0).key());\n    }",
        "clean_err_msg": "junit.framework.AssertionFailedError: expected:<[on]> but was:<[]>"
      }
    },
    "buggy_files": {
      "0": "src/main/java/org/jsoup/nodes/FormElement.java"
    },
    "hunk_type": "single_file_two_hunks",
    "hunk_mapping": {
      "0": [
        {
          "start_line": 80,
          "end_line": 79,
          "file": "src/main/java/org/jsoup/nodes/FormElement.java",
          "code": "<START_BUG>\n<END_BUG>"
        },
        {
          "start_line": 99,
          "end_line": 99,
          "file": "src/main/java/org/jsoup/nodes/FormElement.java",
          "code": "<START_BUG>\n                    final String val = el.val();\n<END_BUG>"
        }
      ]
    },
    "bug_report": {
      "url": "https://github.com/jhy/jsoup/issues/489",
      "title": "FormElement's formData ignores input checkbox checked without value.",
      "bug_description": "When there is input:         \n\n```\n<input type=\"checkbox\" name=\"testCheckBox\" checked=\"checked\" />\n```\n\nThe \"formData()\" of FormElement's ignores that default value which should be \"on\" as submitted by browsers.\n\nHTML fragment:\n\n```\n<html>\n    <head>\n        <title>Test</title>\n    </head>\n\n    <body>\n\n    <form name=\"myForm\" method=\"POST\">\n        <input type=\"checkbox\" name=\"testCheckBox\" checked=\"checked\" /> Something<br/>\n\n        <input type=\"submit\" value=\"Submit\" />\n    </form>\n\n    </body>\n</html>\n```\n\nWhen submiting from Firefox it sends to sever: testCheckBox=on\n\nJava code:\n\n```\n    public static void main(String[] args)\n    {\n        final String html = \"<html>\\n\"\n                            + \"    <head>\\n\"\n                            + \"        <title>Test</title>\\n\"\n                            + \"    </head>\\n\"\n                            + \"    \\n\"\n                            + \"    <body>\\n\"\n                            + \"\\n\"\n                            + \"    <form name=\\\"myForm\\\" method=\\\"POST\\\">\\n\"\n                            + \"        <input type=\\\"checkbox\\\" name=\\\"testCheckBox\\\" checked=\\\"checked\\\" /> Something<br/>\\n\"\n                            + \"\\n\"\n                            + \"        <input type=\\\"submit\\\" value=\\\"Submit\\\" />\\n\"\n                            + \"    </form>\\n\"\n                            + \"\\n\"\n                            + \"    </body>\\n\"\n                            + \"</html>\";\n\n        final Document document = Jsoup.parse(html);\n\n        final FormElement formElement = (FormElement) document.select(\"form[name=myForm]\").first();\n\n        for (Connection.KeyVal keyVal : formElement.formData())\n        {\n            System.out.println(keyVal.key() + \"=\" + keyVal.value());\n        }\n\n    }\n```\n\nOutput: testCheckBox=\n\nExpected output: testCheckBox=on\n\nSeems like Jsoup doesn't add default value which is sent by browsers. The \"submit()\" method from FormElement also uses \"formData()\" method to get form's submission parameters. By sending the empty String for checkbox the server acts as it's not checked when in fact it was checked.\n\nAlso while testing noticed that it doesn't check the checkbox'es at all. If there is checkbox with value, but not checked, it will get the value no matter what, for example:\n\n```\n        <input type=\"checkbox\" name=\"textCheckBox2\" value=\"testVal\" /> \n```\n\nThis affects radio buttons as well. Not selected radion buttons should not be sent to server, but formData() add their values anyway.\n\nI'm not sure if that's done on purpose, but submit() method will get wrong parameters for submission since not checked input value is not sent to server at all.\n\nMoreover type button value and \"disabled\" inputs are not sent to server as well (by browsers). \n\nLooked at the source, one extra else if before the final else in \"formData()\" method could solve this:\n\n```\nelse if (\"input\".equals(el.tagName())) {\n                // Not disabled? Ignore disabled inputs.\n                if(!el.hasAttr(\"disabled\")) {\n\n                    // Deal with checkbox and radio (not checked should not be added to avoid sending to server)\n                    if(\"checkbox\".equals(el.attr(\"type\")) || \"radio\".equals(el.attr(\"type\"))) {\n\n                        // Checked, but no value? Default should be \"on\".\n                        if(el.hasAttr(\"checked\") && !el.hasAttr(\"value\")) {\n                            data.add(HttpConnection.KeyVal.create(name, \"on\"));\n                        } \n                        // Checked? Add it's value\n                        else if(el.hasAttr(\"checked\")) {\n                            data.add(HttpConnection.KeyVal.create(name, el.val()));\n                        }\n                    } \n                    // Buttons should be ignored.\n                    else if(!\"button\".equals(el.attr(\"type\"))){\n                        data.add(HttpConnection.KeyVal.create(name, el.val()));\n                    }\n                }\n            }\n```\n\nOne more thing. If form has multiple type submit inputs, only the clicked input's value should be sent to server, but I have no idea how this could be implemented. Sending all submit input's values can change the server's logic and be bad (result not as expected)."
    }
  },
  "Lang_65": {
    "buggy_hunks": {
      "0": {
        "start_line": 624,
        "end_line": 623,
        "file": "src/java/org/apache/commons/lang/time/DateUtils.java",
        "code": "<START_BUG>\n<END_BUG>"
      },
      "1": {
        "start_line": 631,
        "end_line": 638,
        "file": "src/java/org/apache/commons/lang/time/DateUtils.java",
        "code": "<START_BUG>\n\n        // truncate milliseconds\n\n        // truncate seconds\n\n        // truncate minutes\n\n        // reset time\n<END_BUG>"
      },
      "2": {
        "start_line": 709,
        "end_line": 709,
        "file": "src/java/org/apache/commons/lang/time/DateUtils.java",
        "code": "<START_BUG>\n                val.set(fields[i][0], val.get(fields[i][0]) - offset);\n<END_BUG>"
      }
    },
    "buggy_code": {
      "0": {
        "start_line": 619,
        "end_line": 713,
        "file": "src/java/org/apache/commons/lang/time/DateUtils.java",
        "code": "private static void modify(Calendar val, int field, boolean round) {\n        if (val.get(Calendar.YEAR) > 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n        }\n        \n\n        // ----------------- Fix for LANG-59 ---------------------- START ---------------\n        // see http://issues.apache.org/jira/browse/LANG-59\n        //\n        // Manually truncate milliseconds, seconds and minutes, rather than using\n        // Calendar methods.\n\n\n        // truncate milliseconds\n\n        // truncate seconds\n\n        // truncate minutes\n\n        // reset time\n        // ----------------- Fix for LANG-59 ----------------------- END ----------------\n\n        boolean roundUp = false;\n        for (int i = 0; i < fields.length; i++) {\n            for (int j = 0; j < fields[i].length; j++) {\n                if (fields[i][j] == field) {\n                    //This is our field... we stop looping\n                    if (round && roundUp) {\n                        if (field == DateUtils.SEMI_MONTH) {\n                            //This is a special case that's hard to generalize\n                            //If the date is 1, we round up to 16, otherwise\n                            //  we subtract 15 days and add 1 month\n                            if (val.get(Calendar.DATE) == 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n                        } else {\n                            //We need at add one to this field since the\n                            //  last number causes us to round up\n                            val.add(fields[i][0], 1);\n                        }\n                    }\n                    return;\n                }\n            }\n            //We have various fields that are not easy roundings\n            int offset = 0;\n            boolean offsetSet = false;\n            //These are special types of fields that require different rounding rules\n            switch (field) {\n                case DateUtils.SEMI_MONTH:\n                    if (fields[i][0] == Calendar.DATE) {\n                        //If we're going to drop the DATE field's value,\n                        //  we want to do this our own way.\n                        //We need to subtrace 1 since the date has a minimum of 1\n                        offset = val.get(Calendar.DATE) - 1;\n                        //If we're above 15 days adjustment, that means we're in the\n                        //  bottom half of the month and should stay accordingly.\n                        if (offset >= 15) {\n                            offset -= 15;\n                        }\n                        //Record whether we're in the top or bottom half of that range\n                        roundUp = offset > 7;\n                        offsetSet = true;\n                    }\n                    break;\n                case Calendar.AM_PM:\n                    if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n                        //If we're going to drop the HOUR field's value,\n                        //  we want to do this our own way.\n                        offset = val.get(Calendar.HOUR_OF_DAY);\n                        if (offset >= 12) {\n                            offset -= 12;\n                        }\n                        roundUp = offset > 6;\n                        offsetSet = true;\n                    }\n                    break;\n            }\n            if (!offsetSet) {\n                int min = val.getActualMinimum(fields[i][0]);\n                int max = val.getActualMaximum(fields[i][0]);\n                //Calculate the offset from the minimum allowed value\n                offset = val.get(fields[i][0]) - min;\n                //Set roundUp if this is more than half way between the minimum and maximum\n                roundUp = offset > ((max - min) / 2);\n            }\n            //We need to remove this field\n                val.set(fields[i][0], val.get(fields[i][0]) - offset);\n        }\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n\n    }",
        "javadoc": "/**\n * <p>Internal calculation method.</p>\n *\n * @param val  the calendar\n * @param field  the field constant\n * @param round  true to round, false to truncate\n * @throws ArithmeticException if the year is over 280 million\n */\n"
      }
    },
    "delineated_bug": {
      "0": {
        "start_line": 619,
        "end_line": 713,
        "file": "src/java/org/apache/commons/lang/time/DateUtils.java",
        "code": "private static void modify(Calendar val, int field, boolean round) {\n        if (val.get(Calendar.YEAR) > 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n        }\n        \n<END_BUG>\n<START_BUG>\n\n        // ----------------- Fix for LANG-59 ---------------------- START ---------------\n        // see http://issues.apache.org/jira/browse/LANG-59\n        //\n        // Manually truncate milliseconds, seconds and minutes, rather than using\n        // Calendar methods.\n\n<START_BUG>\n\n        // truncate milliseconds\n\n        // truncate seconds\n\n        // truncate minutes\n\n        // reset time\n<END_BUG>\n        // ----------------- Fix for LANG-59 ----------------------- END ----------------\n\n        boolean roundUp = false;\n        for (int i = 0; i < fields.length; i++) {\n            for (int j = 0; j < fields[i].length; j++) {\n                if (fields[i][j] == field) {\n                    //This is our field... we stop looping\n                    if (round && roundUp) {\n                        if (field == DateUtils.SEMI_MONTH) {\n                            //This is a special case that's hard to generalize\n                            //If the date is 1, we round up to 16, otherwise\n                            //  we subtract 15 days and add 1 month\n                            if (val.get(Calendar.DATE) == 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n                        } else {\n                            //We need at add one to this field since the\n                            //  last number causes us to round up\n                            val.add(fields[i][0], 1);\n                        }\n                    }\n                    return;\n                }\n            }\n            //We have various fields that are not easy roundings\n            int offset = 0;\n            boolean offsetSet = false;\n            //These are special types of fields that require different rounding rules\n            switch (field) {\n                case DateUtils.SEMI_MONTH:\n                    if (fields[i][0] == Calendar.DATE) {\n                        //If we're going to drop the DATE field's value,\n                        //  we want to do this our own way.\n                        //We need to subtrace 1 since the date has a minimum of 1\n                        offset = val.get(Calendar.DATE) - 1;\n                        //If we're above 15 days adjustment, that means we're in the\n                        //  bottom half of the month and should stay accordingly.\n                        if (offset >= 15) {\n                            offset -= 15;\n                        }\n                        //Record whether we're in the top or bottom half of that range\n                        roundUp = offset > 7;\n                        offsetSet = true;\n                    }\n                    break;\n                case Calendar.AM_PM:\n                    if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n                        //If we're going to drop the HOUR field's value,\n                        //  we want to do this our own way.\n                        offset = val.get(Calendar.HOUR_OF_DAY);\n                        if (offset >= 12) {\n                            offset -= 12;\n                        }\n                        roundUp = offset > 6;\n                        offsetSet = true;\n                    }\n                    break;\n            }\n            if (!offsetSet) {\n                int min = val.getActualMinimum(fields[i][0]);\n                int max = val.getActualMaximum(fields[i][0]);\n                //Calculate the offset from the minimum allowed value\n                offset = val.get(fields[i][0]) - min;\n                //Set roundUp if this is more than half way between the minimum and maximum\n                roundUp = offset > ((max - min) / 2);\n            }\n            //We need to remove this field\n<START_BUG>\n                val.set(fields[i][0], val.get(fields[i][0]) - offset);\n<END_BUG>\n        }\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n\n    }",
        "javadoc": "/**\n * <p>Internal calculation method.</p>\n *\n * @param val  the calendar\n * @param field  the field constant\n * @param round  true to round, false to truncate\n * @throws ArithmeticException if the year is over 280 million\n */\n"
      }
    },
    "contained_scope": "method",
    "bug_count": 1,
    "triggered_tests": {
      "0": {
        "test_path": "org.apache.commons.lang.time.DateUtilsTest",
        "test_method": "testTruncateLang59",
        "test_code": "testTruncateLang59() throws Exception {\n\n        // Set TimeZone to Mountain Time\n        TimeZone MST_MDT = TimeZone.getTimeZone(\"MST7MDT\");\n        TimeZone.setDefault(MST_MDT);\n        DateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS z\");\n        format.setTimeZone(MST_MDT);\n\n        Date oct31_01MDT = new Date(1099206000000L); \n\n        Date oct31MDT             = new Date(oct31_01MDT.getTime()       - 3600000L); // - 1 hour\n        Date oct31_01_02MDT       = new Date(oct31_01MDT.getTime()       + 120000L);  // + 2 minutes\n        Date oct31_01_02_03MDT    = new Date(oct31_01_02MDT.getTime()    + 3000L);    // + 3 seconds\n        Date oct31_01_02_03_04MDT = new Date(oct31_01_02_03MDT.getTime() + 4L);       // + 4 milliseconds\n\n        assertEquals(\"Check 00:00:00.000\", \"2004-10-31 00:00:00.000 MDT\", format.format(oct31MDT));\n        assertEquals(\"Check 01:00:00.000\", \"2004-10-31 01:00:00.000 MDT\", format.format(oct31_01MDT));\n        assertEquals(\"Check 01:02:00.000\", \"2004-10-31 01:02:00.000 MDT\", format.format(oct31_01_02MDT));\n        assertEquals(\"Check 01:02:03.000\", \"2004-10-31 01:02:03.000 MDT\", format.format(oct31_01_02_03MDT));\n        assertEquals(\"Check 01:02:03.004\", \"2004-10-31 01:02:03.004 MDT\", format.format(oct31_01_02_03_04MDT));\n\n        // ------- Demonstrate Problem -------\n        Calendar gval = Calendar.getInstance();\n        gval.setTime(new Date(oct31_01MDT.getTime()));\n        gval.set(Calendar.MINUTE, gval.get(Calendar.MINUTE)); // set minutes to the same value\n        assertEquals(\"Demonstrate Problem\", gval.getTime().getTime(), oct31_01MDT.getTime() + 3600000L);\n\n        // ---------- Test Truncate ----------\n        assertEquals(\"Truncate Calendar.MILLISECOND\",\n                oct31_01_02_03_04MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.MILLISECOND));\n\n        assertEquals(\"Truncate Calendar.SECOND\",\n                   oct31_01_02_03MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.SECOND));\n\n        assertEquals(\"Truncate Calendar.MINUTE\",\n                      oct31_01_02MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.MINUTE));\n\n        assertEquals(\"Truncate Calendar.HOUR_OF_DAY\",\n                         oct31_01MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.HOUR_OF_DAY));\n\n        assertEquals(\"Truncate Calendar.HOUR\",\n                         oct31_01MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.HOUR));\n\n        assertEquals(\"Truncate Calendar.DATE\",\n                            oct31MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.DATE));\n\n\n        // ---------- Test Round (down) ----------\n        assertEquals(\"Round Calendar.MILLISECOND\",\n                oct31_01_02_03_04MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.MILLISECOND));\n\n        assertEquals(\"Round Calendar.SECOND\",\n                   oct31_01_02_03MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.SECOND));\n\n        assertEquals(\"Round Calendar.MINUTE\",\n                      oct31_01_02MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.MINUTE));\n\n        assertEquals(\"Round Calendar.HOUR_OF_DAY\",\n                         oct31_01MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.HOUR_OF_DAY));\n\n        assertEquals(\"Round Calendar.HOUR\",\n                         oct31_01MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.HOUR));\n\n        assertEquals(\"Round Calendar.DATE\",\n                            oct31MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.DATE));\n\n        // restore default time zone\n        TimeZone.setDefault(defaultZone);\n    }",
        "clean_err_msg": "junit.framework.AssertionFailedError: Truncate Calendar.SECOND expected:<Sun Oct 31 01:02:03 MDT 2004> but was:<Sun Oct 31 01:02:03 MST 2004>"
      }
    },
    "buggy_files": {
      "0": "src/java/org/apache/commons/lang/time/DateUtils.java"
    },
    "hunk_type": "single_file_three_hunks",
    "hunk_mapping": {
      "0": [
        {
          "start_line": 624,
          "end_line": 623,
          "file": "src/java/org/apache/commons/lang/time/DateUtils.java",
          "code": "<START_BUG>\n<END_BUG>"
        },
        {
          "start_line": 631,
          "end_line": 638,
          "file": "src/java/org/apache/commons/lang/time/DateUtils.java",
          "code": "<START_BUG>\n\n        // truncate milliseconds\n\n        // truncate seconds\n\n        // truncate minutes\n\n        // reset time\n<END_BUG>"
        },
        {
          "start_line": 709,
          "end_line": 709,
          "file": "src/java/org/apache/commons/lang/time/DateUtils.java",
          "code": "<START_BUG>\n                val.set(fields[i][0], val.get(fields[i][0]) - offset);\n<END_BUG>"
        }
      ]
    },
    "bug_report": {
      "url": "https://issues.apache.org/jira/browse/LANG-59",
      "title": "[lang] DateUtils.truncate method is buggy when dealing with DST switching hours",
      "bug_description": "Try to truncate 2004-10-31 01:00:00 MDT by hour and you'll actually get 2004-10-\n31 01:00:00 MST, which is one hour after the input hour.\n// truncate 2004-10-31 01:00:00 MDT\nDate oct31_01MDT = new Date(1099206000000L);\nDate result = DateUtils.truncate(oct31_01MDT, Calendar.HOUR_OF_DAY);\nassertEquals(oct31_01MDT, result);"
    }
  },
  "Cli_31": {
    "buggy_hunks": {
      "0": {
        "start_line": 653,
        "end_line": 656,
        "file": "src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "code": "<START_BUG>\n        if (option.hasArg() && option.hasArgName())\n        {\n            buff.append(option.getOpt() == null ? longOptSeparator : \" \");\n            buff.append(\"<\").append(option.getArgName()).append(\">\");\n<END_BUG>"
      },
      "1": {
        "start_line": 57,
        "end_line": 57,
        "file": "src/main/java/org/apache/commons/cli/Option.java",
        "code": "<START_BUG>\n    private String argName = \"arg\";\n<END_BUG>"
      },
      "2": {
        "start_line": 80,
        "end_line": 80,
        "file": "src/main/java/org/apache/commons/cli/OptionBuilder.java",
        "code": "<START_BUG>\n        argName = \"arg\";\n<END_BUG>"
      }
    },
    "buggy_code": {
      "0": {
        "start_line": 636,
        "end_line": 664,
        "file": "src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "code": "private void appendOption(final StringBuffer buff, final Option option, final boolean required)\n    {\n        if (!required)\n        {\n            buff.append(\"[\");\n        }\n\n        if (option.getOpt() != null)\n        {\n            buff.append(\"-\").append(option.getOpt());\n        }\n        else\n        {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n        \n        // if the Option has a value and a non blank argname\n        if (option.hasArg() && option.hasArgName())\n        {\n            buff.append(option.getOpt() == null ? longOptSeparator : \" \");\n            buff.append(\"<\").append(option.getArgName()).append(\">\");\n        }\n        \n        // if the Option is not a required option\n        if (!required)\n        {\n            buff.append(\"]\");\n        }\n    }",
        "javadoc": "/**\n * Appends the usage clause for an Option to a StringBuffer.\n *\n * @param buff the StringBuffer to append to\n * @param option the Option to append\n * @param required whether the Option is required or not\n */\n"
      },
      "1": {
        "start_line": 57,
        "end_line": 57,
        "file": "src/main/java/org/apache/commons/cli/Option.java",
        "code": "private String argName = \"arg\";",
        "javadoc": "/**\n * Resets the member variables to their default values.\n */\n"
      },
      "2": {
        "start_line": 77,
        "end_line": 87,
        "file": "src/main/java/org/apache/commons/cli/OptionBuilder.java",
        "code": "private static void reset()\n    {\n        description = null;\n        argName = \"arg\";\n        longopt = null;\n        type = null;\n        required = false;\n        numberOfArgs = Option.UNINITIALIZED;\n        optionalArg = false;\n        valuesep = (char) 0;\n    }",
        "javadoc": ""
      }
    },
    "delineated_bug": {
      "0": {
        "start_line": 636,
        "end_line": 664,
        "file": "src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "code": "private void appendOption(final StringBuffer buff, final Option option, final boolean required)\n    {\n        if (!required)\n        {\n            buff.append(\"[\");\n        }\n\n        if (option.getOpt() != null)\n        {\n            buff.append(\"-\").append(option.getOpt());\n        }\n        else\n        {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n        \n        // if the Option has a value and a non blank argname\n<START_BUG>\n        if (option.hasArg() && option.hasArgName())\n        {\n            buff.append(option.getOpt() == null ? longOptSeparator : \" \");\n            buff.append(\"<\").append(option.getArgName()).append(\">\");\n<END_BUG>\n        }\n        \n        // if the Option is not a required option\n        if (!required)\n        {\n            buff.append(\"]\");\n        }\n    }",
        "javadoc": "/**\n * Appends the usage clause for an Option to a StringBuffer.\n *\n * @param buff the StringBuffer to append to\n * @param option the Option to append\n * @param required whether the Option is required or not\n */\n"
      },
      "1": {
        "start_line": 57,
        "end_line": 57,
        "file": "src/main/java/org/apache/commons/cli/Option.java",
        "code": "<START_BUG>\nprivate String argName = \"arg\";\n<END_BUG>",
        "javadoc": "/**\n * Resets the member variables to their default values.\n */\n"
      },
      "2": {
        "start_line": 77,
        "end_line": 87,
        "file": "src/main/java/org/apache/commons/cli/OptionBuilder.java",
        "code": "private static void reset()\n    {\n        description = null;\n<START_BUG>\n        argName = \"arg\";\n<END_BUG>\n        longopt = null;\n        type = null;\n        required = false;\n        numberOfArgs = Option.UNINITIALIZED;\n        optionalArg = false;\n        valuesep = (char) 0;\n    }",
        "javadoc": ""
      }
    },
    "contained_scope": "file",
    "bug_count": 3,
    "triggered_tests": {
      "0": {
        "test_path": "org.apache.commons.cli.HelpFormatterTest",
        "test_method": "testDefaultArgName",
        "test_code": "testDefaultArgName()\n    {\n        Option option = OptionBuilder.hasArg().isRequired().create(\"f\");\n        \n        Options options = new Options();\n        options.addOption(option);\n        \n        StringWriter out = new StringWriter();\n\n        HelpFormatter formatter = new HelpFormatter();\n        formatter.setArgName(\"argument\");\n        formatter.printUsage(new PrintWriter(out), 80, \"app\", options);\n\n        assertEquals(\"usage: app -f <argument>\" + EOL, out.toString());\n    }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<usage: app -f <arg[ument]>"
      }
    },
    "buggy_files": {
      "0": "src/main/java/org/apache/commons/cli/HelpFormatter.java",
      "1": "src/main/java/org/apache/commons/cli/Option.java",
      "2": "src/main/java/org/apache/commons/cli/OptionBuilder.java"
    },
    "hunk_type": "multi_file_three_hunks",
    "hunk_mapping": {
      "0": [
        {
          "start_line": 653,
          "end_line": 656,
          "file": "src/main/java/org/apache/commons/cli/HelpFormatter.java",
          "code": "<START_BUG>\n        if (option.hasArg() && option.hasArgName())\n        {\n            buff.append(option.getOpt() == null ? longOptSeparator : \" \");\n            buff.append(\"<\").append(option.getArgName()).append(\">\");\n<END_BUG>"
        }
      ],
      "1": [
        {
          "start_line": 57,
          "end_line": 57,
          "file": "src/main/java/org/apache/commons/cli/Option.java",
          "code": "<START_BUG>\n    private String argName = \"arg\";\n<END_BUG>"
        }
      ],
      "2": [
        {
          "start_line": 80,
          "end_line": 80,
          "file": "src/main/java/org/apache/commons/cli/OptionBuilder.java",
          "code": "<START_BUG>\n        argName = \"arg\";\n<END_BUG>"
        }
      ]
    },
    "bug_report": {
      "url": "https://issues.apache.org/jira/browse/CLI-205",
      "title": "HelpFormatter.setArgName() has no effect",
      "bug_description": "The default argument name set on the HelpFormatter has no effect because the Option and the OptionBuilder bring automatically a default value 'arg'."
    }
  },
  "Closure_162": {
    "buggy_hunks": {
      "0": {
        "start_line": 568,
        "end_line": 567,
        "file": "src/com/google/javascript/jscomp/Scope.java",
        "code": "<START_BUG>\n<END_BUG>"
      },
      "1": {
        "start_line": 226,
        "end_line": 225,
        "file": "src/com/google/javascript/jscomp/ScopedAliases.java",
        "code": "<START_BUG>\n<END_BUG>"
      },
      "2": {
        "start_line": 271,
        "end_line": 272,
        "file": "src/com/google/javascript/jscomp/ScopedAliases.java",
        "code": "<START_BUG>\n\n            // TODO(robbyw): Support using locals for private variables.\n<END_BUG>"
      },
      "3": {
        "start_line": 303,
        "end_line": 328,
        "file": "src/com/google/javascript/jscomp/ScopedAliases.java",
        "code": "<START_BUG>\n\n\n      // Validate the top level of the goog.scope block.\n      if (t.getScopeDepth() == 2) {\n        int type = n.getType();\n        if (type == Token.NAME && parent.getType() == Token.VAR) {\n          if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n            String name = n.getString();\n            Var aliasVar = t.getScope().getVar(name);\n            aliases.put(name, aliasVar);\n            aliasDefinitionsInOrder.add(n);\n\n            String qualifiedName =\n                aliasVar.getInitialValue().getQualifiedName();\n            transformation.addAlias(name, qualifiedName);\n            // Return early, to ensure that we don't record a definition\n            // twice.\n            return;\n          } else {\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n          }\n        }\n        if (type == Token.NAME && NodeUtil.isAssignmentOp(parent) &&\n            n == parent.getFirstChild()) {\n            report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n        }\n<END_BUG>"
      },
      "4": {
        "start_line": 342,
        "end_line": 346,
        "file": "src/com/google/javascript/jscomp/ScopedAliases.java",
        "code": "<START_BUG>\n        if (n.getType() == Token.NAME) {\n          String name = n.getString();\n          Var aliasVar = aliases.get(name);\n          if (aliasVar != null &&\n              t.getScope().getVar(name) == aliasVar) {\n<END_BUG>"
      },
      "5": {
        "start_line": 355,
        "end_line": 355,
        "file": "src/com/google/javascript/jscomp/ScopedAliases.java",
        "code": "<START_BUG>\n          }\n<END_BUG>"
      }
    },
    "buggy_code": {
      "0": {
        "start_line": 568,
        "end_line": 568,
        "file": "src/com/google/javascript/jscomp/Scope.java",
        "code": "",
        "javadoc": ""
      },
      "1": {
        "start_line": 220,
        "end_line": 227,
        "file": "src/com/google/javascript/jscomp/ScopedAliases.java",
        "code": "@Override\n    public void enterScope(NodeTraversal t) {\n      Node n = t.getCurrentNode().getParent();\n      if (n != null && isCallToScopeMethod(n)) {\n        transformation = transformationHandler.logAliasTransformation(\n            n.getSourceFileName(), getSourceRegion(n));\n      }\n    }",
        "javadoc": ""
      },
      "2": {
        "start_line": 271,
        "end_line": 272,
        "file": "src/com/google/javascript/jscomp/ScopedAliases.java",
        "code": "// TODO(robbyw): Support using locals for private variables.",
        "javadoc": ""
      },
      "3": {
        "start_line": 297,
        "end_line": 367,
        "file": "src/com/google/javascript/jscomp/ScopedAliases.java",
        "code": "@Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, n.getParent());\n      }\n\n\n\n      // Validate the top level of the goog.scope block.\n      if (t.getScopeDepth() == 2) {\n        int type = n.getType();\n        if (type == Token.NAME && parent.getType() == Token.VAR) {\n          if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n            String name = n.getString();\n            Var aliasVar = t.getScope().getVar(name);\n            aliases.put(name, aliasVar);\n            aliasDefinitionsInOrder.add(n);\n\n            String qualifiedName =\n                aliasVar.getInitialValue().getQualifiedName();\n            transformation.addAlias(name, qualifiedName);\n            // Return early, to ensure that we don't record a definition\n            // twice.\n            return;\n          } else {\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n          }\n        }\n        if (type == Token.NAME && NodeUtil.isAssignmentOp(parent) &&\n            n == parent.getFirstChild()) {\n            report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n        }\n\n        if (type == Token.RETURN) {\n          report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n          report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n          report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n      }\n\n      // Validate all descendent scopes of the goog.scope block.\n      if (t.getScopeDepth() >= 2) {\n        // Check if this name points to an alias.\n        if (n.getType() == Token.NAME) {\n          String name = n.getString();\n          Var aliasVar = aliases.get(name);\n          if (aliasVar != null &&\n              t.getScope().getVar(name) == aliasVar) {\n          // Note, to support the transitive case, it's important we don't\n          // clone aliasedNode here.  For example,\n          // var g = goog; var d = g.dom; d.createElement('DIV');\n          // The node in aliasedNode (which is \"g\") will be replaced in the\n          // changes pass above with \"goog\".  If we cloned here, we'd end up\n          // with <code>g.dom.createElement('DIV')</code>.\n          Node aliasedNode = aliasVar.getInitialValue();\n          aliasUsages.add(new AliasedNode(n, aliasedNode));\n          }\n        }\n\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n          for (Node node : info.getTypeNodes()) {\n            fixTypeNode(node);\n          }\n        }\n\n        // TODO(robbyw): Error for goog.scope not at root.\n      }\n    }",
        "javadoc": ""
      }
    },
    "delineated_bug": {
      "0": {
        "start_line": 568,
        "end_line": 568,
        "file": "src/com/google/javascript/jscomp/Scope.java",
        "code": "<START_BUG>\n\n<END_BUG>",
        "javadoc": ""
      },
      "1": {
        "start_line": 220,
        "end_line": 227,
        "file": "src/com/google/javascript/jscomp/ScopedAliases.java",
        "code": "@Override\n    public void enterScope(NodeTraversal t) {\n      Node n = t.getCurrentNode().getParent();\n      if (n != null && isCallToScopeMethod(n)) {\n        transformation = transformationHandler.logAliasTransformation(\n            n.getSourceFileName(), getSourceRegion(n));\n<END_BUG>\n<START_BUG>\n      }\n    }",
        "javadoc": ""
      },
      "2": {
        "start_line": 271,
        "end_line": 272,
        "file": "src/com/google/javascript/jscomp/ScopedAliases.java",
        "code": "<START_BUG>\n// TODO(robbyw): Support using locals for private variables.\n<END_BUG>",
        "javadoc": ""
      },
      "3": {
        "start_line": 297,
        "end_line": 367,
        "file": "src/com/google/javascript/jscomp/ScopedAliases.java",
        "code": "@Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, n.getParent());\n      }\n\n<START_BUG>\n\n\n      // Validate the top level of the goog.scope block.\n      if (t.getScopeDepth() == 2) {\n        int type = n.getType();\n        if (type == Token.NAME && parent.getType() == Token.VAR) {\n          if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n            String name = n.getString();\n            Var aliasVar = t.getScope().getVar(name);\n            aliases.put(name, aliasVar);\n            aliasDefinitionsInOrder.add(n);\n\n            String qualifiedName =\n                aliasVar.getInitialValue().getQualifiedName();\n            transformation.addAlias(name, qualifiedName);\n            // Return early, to ensure that we don't record a definition\n            // twice.\n            return;\n          } else {\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n          }\n        }\n        if (type == Token.NAME && NodeUtil.isAssignmentOp(parent) &&\n            n == parent.getFirstChild()) {\n            report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n        }\n<END_BUG>\n\n        if (type == Token.RETURN) {\n          report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n          report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n          report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n      }\n\n      // Validate all descendent scopes of the goog.scope block.\n      if (t.getScopeDepth() >= 2) {\n        // Check if this name points to an alias.\n<START_BUG>\n        if (n.getType() == Token.NAME) {\n          String name = n.getString();\n          Var aliasVar = aliases.get(name);\n          if (aliasVar != null &&\n              t.getScope().getVar(name) == aliasVar) {\n<END_BUG>\n          // Note, to support the transitive case, it's important we don't\n          // clone aliasedNode here.  For example,\n          // var g = goog; var d = g.dom; d.createElement('DIV');\n          // The node in aliasedNode (which is \"g\") will be replaced in the\n          // changes pass above with \"goog\".  If we cloned here, we'd end up\n          // with <code>g.dom.createElement('DIV')</code>.\n          Node aliasedNode = aliasVar.getInitialValue();\n          aliasUsages.add(new AliasedNode(n, aliasedNode));\n<START_BUG>\n          }\n<END_BUG>\n        }\n\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n          for (Node node : info.getTypeNodes()) {\n            fixTypeNode(node);\n          }\n        }\n\n        // TODO(robbyw): Error for goog.scope not at root.\n      }\n    }",
        "javadoc": ""
      }
    },
    "contained_scope": "file",
    "bug_count": 4,
    "triggered_tests": {
      "0": {
        "test_path": "com.google.javascript.jscomp.ScopedAliasesTest",
        "test_method": "testForwardJsDoc",
        "test_code": "testForwardJsDoc() {\n    testScoped(\n        \"/**\\n\" +\n        \" * @constructor\\n\" +\n        \" */\\n\" +\n        \"foo.Foo = function() {};\" +\n        \"/** @param {Foo.Bar} x */ function actual(x) {3}\" +\n        \"var Foo = foo.Foo;\" +\n        \"/** @constructor */ Foo.Bar = function() {};\" +\n        \"/** @param {foo.Foo.Bar} x */ function expected(x) {}\",\n\n        \"/**\\n\" +\n        \" * @constructor\\n\" +\n        \" */\\n\" +\n        \"foo.Foo = function() {};\" +\n        \"/** @param {foo.Foo.Bar} x */ function actual(x) {3}\" +\n        \"/** @constructor */ foo.Foo.Bar = function() {};\" +\n        \"/** @param {foo.Foo.Bar} x */ function expected(x) {}\");\n    verifyTypes();\n  }",
        "clean_err_msg": "junit.framework.AssertionFailedError: expected:<[STRING foo.Foo.Bar 4 [source_file: testcode]"
      }
    },
    "buggy_files": {
      "0": "src/com/google/javascript/jscomp/Scope.java",
      "1": "src/com/google/javascript/jscomp/ScopedAliases.java"
    },
    "hunk_type": "multi_file_four_or_more_hunks",
    "hunk_mapping": {
      "0": [
        {
          "start_line": 568,
          "end_line": 567,
          "file": "src/com/google/javascript/jscomp/Scope.java",
          "code": "<START_BUG>\n<END_BUG>"
        }
      ],
      "1": [
        {
          "start_line": 226,
          "end_line": 225,
          "file": "src/com/google/javascript/jscomp/ScopedAliases.java",
          "code": "<START_BUG>\n<END_BUG>"
        }
      ],
      "2": [
        {
          "start_line": 271,
          "end_line": 272,
          "file": "src/com/google/javascript/jscomp/ScopedAliases.java",
          "code": "<START_BUG>\n\n            // TODO(robbyw): Support using locals for private variables.\n<END_BUG>"
        }
      ],
      "3": [
        {
          "start_line": 303,
          "end_line": 328,
          "file": "src/com/google/javascript/jscomp/ScopedAliases.java",
          "code": "<START_BUG>\n\n\n      // Validate the top level of the goog.scope block.\n      if (t.getScopeDepth() == 2) {\n        int type = n.getType();\n        if (type == Token.NAME && parent.getType() == Token.VAR) {\n          if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n            String name = n.getString();\n            Var aliasVar = t.getScope().getVar(name);\n            aliases.put(name, aliasVar);\n            aliasDefinitionsInOrder.add(n);\n\n            String qualifiedName =\n                aliasVar.getInitialValue().getQualifiedName();\n            transformation.addAlias(name, qualifiedName);\n            // Return early, to ensure that we don't record a definition\n            // twice.\n            return;\n          } else {\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n          }\n        }\n        if (type == Token.NAME && NodeUtil.isAssignmentOp(parent) &&\n            n == parent.getFirstChild()) {\n            report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n        }\n<END_BUG>"
        },
        {
          "start_line": 342,
          "end_line": 346,
          "file": "src/com/google/javascript/jscomp/ScopedAliases.java",
          "code": "<START_BUG>\n        if (n.getType() == Token.NAME) {\n          String name = n.getString();\n          Var aliasVar = aliases.get(name);\n          if (aliasVar != null &&\n              t.getScope().getVar(name) == aliasVar) {\n<END_BUG>"
        },
        {
          "start_line": 355,
          "end_line": 355,
          "file": "src/com/google/javascript/jscomp/ScopedAliases.java",
          "code": "<START_BUG>\n          }\n<END_BUG>"
        }
      ]
    },
    "bug_report": {
      "url": "https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-548.json",
      "bug_description": "Type aliases cannot be used in type annotations before their definitions",
      "title": ""
    }
  },
  "Jsoup_31": {
    "buggy_hunks": {
      "0": {
        "start_line": 171,
        "end_line": 170,
        "file": "src/main/java/org/jsoup/parser/Token.java",
        "code": "<START_BUG>\n<END_BUG>"
      },
      "1": {
        "start_line": 1094,
        "end_line": 1093,
        "file": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "code": "<START_BUG>\n<END_BUG>"
      },
      "2": {
        "start_line": 67,
        "end_line": 66,
        "file": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java",
        "code": "<START_BUG>\n<END_BUG>"
      }
    },
    "buggy_code": {
      "0": {
        "start_line": 171,
        "end_line": 171,
        "file": "src/main/java/org/jsoup/parser/Token.java",
        "code": "",
        "javadoc": ""
      },
      "1": {
        "start_line": 1089,
        "end_line": 1098,
        "file": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "code": "void read(Tokeniser t, CharacterReader r) {\n            // todo: handle bogus comment starting from eof. when does that trigger?\n            // rewind to capture character that lead us here\n            r.unconsume();\n            Token.Comment comment = new Token.Comment();\n            comment.data.append(r.consumeTo('>'));\n            // todo: replace nullChar with replaceChar\n            t.emit(comment);\n            t.advanceTransition(Data);\n        }",
        "javadoc": ""
      },
      "2": {
        "start_line": 64,
        "end_line": 68,
        "file": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java",
        "code": "void insert(Token.Comment commentToken) {\n        Comment comment = new Comment(commentToken.getData(), baseUri);\n        Node insert = comment;\n        insertNode(insert);\n    }",
        "javadoc": ""
      }
    },
    "delineated_bug": {
      "0": {
        "start_line": 171,
        "end_line": 171,
        "file": "src/main/java/org/jsoup/parser/Token.java",
        "code": "<START_BUG>\n\n<END_BUG>",
        "javadoc": ""
      },
      "1": {
        "start_line": 1089,
        "end_line": 1098,
        "file": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "code": "void read(Tokeniser t, CharacterReader r) {\n            // todo: handle bogus comment starting from eof. when does that trigger?\n            // rewind to capture character that lead us here\n            r.unconsume();\n            Token.Comment comment = new Token.Comment();\n<END_BUG>\n<START_BUG>\n            comment.data.append(r.consumeTo('>'));\n            // todo: replace nullChar with replaceChar\n            t.emit(comment);\n            t.advanceTransition(Data);\n        }",
        "javadoc": ""
      },
      "2": {
        "start_line": 64,
        "end_line": 68,
        "file": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java",
        "code": "void insert(Token.Comment commentToken) {\n        Comment comment = new Comment(commentToken.getData(), baseUri);\n        Node insert = comment;\n<END_BUG>\n<START_BUG>\n        insertNode(insert);\n    }",
        "javadoc": ""
      }
    },
    "contained_scope": "file",
    "bug_count": 3,
    "triggered_tests": {
      "0": {
        "test_path": "org.jsoup.parser.XmlTreeBuilderTest",
        "test_method": "handlesXmlDeclarationAsDeclaration",
        "test_code": "handlesXmlDeclarationAsDeclaration() {\n        String html = \"<?xml encoding='UTF-8' ?><body>One</body><!-- comment -->\";\n        Document doc = Jsoup.parse(html, \"\", Parser.xmlParser());\n        assertEquals(\"<?xml encoding='UTF-8' ?> <body> One </body> <!-- comment -->\",\n                StringUtil.normaliseWhitespace(doc.outerHtml()));\n        assertEquals(\"#declaration\", doc.childNode(0).nodeName());\n        assertEquals(\"#comment\", doc.childNode(2).nodeName());\n    }",
        "clean_err_msg": "junit.framework.AssertionFailedError: expected:<<[?xml encoding='UTF-8' ?]> <body> One </body>...> but was:<<[!--?xml encoding='UTF-8' ?--]> <body> One </body>...>"
      }
    },
    "buggy_files": {
      "0": "src/main/java/org/jsoup/parser/Token.java",
      "1": "src/main/java/org/jsoup/parser/TokeniserState.java",
      "2": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java"
    },
    "hunk_type": "multi_file_three_hunks",
    "hunk_mapping": {
      "0": [
        {
          "start_line": 171,
          "end_line": 170,
          "file": "src/main/java/org/jsoup/parser/Token.java",
          "code": "<START_BUG>\n<END_BUG>"
        }
      ],
      "1": [
        {
          "start_line": 1094,
          "end_line": 1093,
          "file": "src/main/java/org/jsoup/parser/TokeniserState.java",
          "code": "<START_BUG>\n<END_BUG>"
        }
      ],
      "2": [
        {
          "start_line": 67,
          "end_line": 66,
          "file": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java",
          "code": "<START_BUG>\n<END_BUG>"
        }
      ]
    },
    "bug_report": {
      "url": "https://github.com/jhy/jsoup/issues/242",
      "title": "Xml declaration is parsed as a comment",
      "bug_description": "Using jsoup 1.6.3, the following snippet\n\n``` java\nSystem.out.println(\n  Jsoup.parse(\n    \"<?xml encoding='UTF-8' version='1.0'?>\" +\n    \"<html>\" +\n    \"<head><title></title></head>\" +\n    \"<body>Document content</body>\" +\n    \"</html>\").outerHtml());\n```\n\nprints :\n\n``` html\n<!--?xml encoding='UTF-8' version='1.0'?-->\n<html>\n <head>\n  <title></title>\n </head>\n <body>\n  Document content\n </body>\n</html>\n```\n\nwhile I expect :\n\n``` html\n<?xml encoding='UTF-8' version='1.0'?>\n<html>\n <head>\n  <title></title>\n </head>\n <body>\n  Document content\n </body>\n</html>\n```"
    }
  },
  "Closure_169": {
    "buggy_hunks": {
      "0": {
        "start_line": 177,
        "end_line": 177,
        "file": "src/com/google/javascript/rhino/jstype/ArrowType.java",
        "code": "<START_BUG>\n  boolean hasEqualParameters(ArrowType that, boolean tolerateUnknowns) {\n<END_BUG>"
      },
      "1": {
        "start_line": 187,
        "end_line": 187,
        "file": "src/com/google/javascript/rhino/jstype/ArrowType.java",
        "code": "<START_BUG>\n                otherParamType, tolerateUnknowns)) {\n<END_BUG>"
      },
      "2": {
        "start_line": 204,
        "end_line": 209,
        "file": "src/com/google/javascript/rhino/jstype/ArrowType.java",
        "code": "<START_BUG>\n      ArrowType that, boolean tolerateUnknowns) {\n    // Please keep this method in sync with the hashCode() method below.\n    if (!returnType.checkEquivalenceHelper(that.returnType, tolerateUnknowns)) {\n      return false;\n    }\n    return hasEqualParameters(that, tolerateUnknowns);\n<END_BUG>"
      },
      "3": {
        "start_line": 792,
        "end_line": 792,
        "file": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "code": "<START_BUG>\n    if (call.hasEqualParameters(other.call, false)) {\n<END_BUG>"
      },
      "4": {
        "start_line": 890,
        "end_line": 890,
        "file": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "code": "<START_BUG>\n      FunctionType that, boolean tolerateUnknowns) {\n<END_BUG>"
      },
      "5": {
        "start_line": 908,
        "end_line": 909,
        "file": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "code": "<START_BUG>\n        that.typeOfThis, tolerateUnknowns) &&\n        call.checkArrowEquivalenceHelper(that.call, tolerateUnknowns);\n<END_BUG>"
      },
      "6": {
        "start_line": 918,
        "end_line": 918,
        "file": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "code": "<START_BUG>\n    return this.call.checkArrowEquivalenceHelper(otherType.call, false);\n<END_BUG>"
      },
      "7": {
        "start_line": 492,
        "end_line": 492,
        "file": "src/com/google/javascript/rhino/jstype/JSType.java",
        "code": "<START_BUG>\n    return checkEquivalenceHelper(that, false);\n<END_BUG>"
      },
      "8": {
        "start_line": 500,
        "end_line": 500,
        "file": "src/com/google/javascript/rhino/jstype/JSType.java",
        "code": "<START_BUG>\n    return checkEquivalenceHelper(that, false);\n<END_BUG>"
      },
      "9": {
        "start_line": 514,
        "end_line": 520,
        "file": "src/com/google/javascript/rhino/jstype/JSType.java",
        "code": "<START_BUG>\n    return !checkEquivalenceHelper(that, true);\n  }\n\n  /**\n   * An equivalence visitor.\n   */\n  boolean checkEquivalenceHelper(JSType that, boolean tolerateUnknowns) {\n<END_BUG>"
      },
      "10": {
        "start_line": 528,
        "end_line": 530,
        "file": "src/com/google/javascript/rhino/jstype/JSType.java",
        "code": "<START_BUG>\n      if (tolerateUnknowns) {\n        // If we're checking for invariance, the unknown type is invariant\n        // with everyone.\n<END_BUG>"
      },
      "11": {
        "start_line": 545,
        "end_line": 555,
        "file": "src/com/google/javascript/rhino/jstype/JSType.java",
        "code": "<START_BUG>\n          that.toMaybeUnionType(), tolerateUnknowns);\n    }\n\n    if (isFunctionType() && that.isFunctionType()) {\n      return this.toMaybeFunctionType().checkFunctionEquivalenceHelper(\n          that.toMaybeFunctionType(), tolerateUnknowns);\n    }\n\n    if (isRecordType() && that.isRecordType()) {\n      return this.toMaybeRecordType().checkRecordEquivalenceHelper(\n          that.toMaybeRecordType(), tolerateUnknowns);\n<END_BUG>"
      },
      "12": {
        "start_line": 565,
        "end_line": 572,
        "file": "src/com/google/javascript/rhino/jstype/JSType.java",
        "code": "<START_BUG>\n            thatParamType.getParameterType(), tolerateUnknowns);\n      } else if (tolerateUnknowns) {\n        // If one of the type parameters is unknown, but the other is not,\n        // then we consider these the same for the purposes of data flow\n        // and invariance.\n        paramsMatch = true;\n      } else {\n        paramsMatch = false;\n<END_BUG>"
      },
      "13": {
        "start_line": 580,
        "end_line": 580,
        "file": "src/com/google/javascript/rhino/jstype/JSType.java",
        "code": "<START_BUG>\n          thisRootType.checkEquivalenceHelper(thatRootType, tolerateUnknowns);\n<END_BUG>"
      },
      "14": {
        "start_line": 592,
        "end_line": 598,
        "file": "src/com/google/javascript/rhino/jstype/JSType.java",
        "code": "<START_BUG>\n              that, tolerateUnknowns);\n    }\n\n    if (that instanceof ProxyObjectType) {\n      return checkEquivalenceHelper(\n          ((ProxyObjectType) that).getReferencedTypeInternal(),\n          tolerateUnknowns);\n<END_BUG>"
      },
      "15": {
        "start_line": 118,
        "end_line": 118,
        "file": "src/com/google/javascript/rhino/jstype/RecordType.java",
        "code": "<START_BUG>\n      RecordType otherRecord, boolean tolerateUnknowns) {\n<END_BUG>"
      },
      "16": {
        "start_line": 126,
        "end_line": 126,
        "file": "src/com/google/javascript/rhino/jstype/RecordType.java",
        "code": "<START_BUG>\n              properties.get(key), tolerateUnknowns)) {\n<END_BUG>"
      },
      "17": {
        "start_line": 204,
        "end_line": 205,
        "file": "src/com/google/javascript/rhino/jstype/RecordType.java",
        "code": "<START_BUG>\n              (propType.isUnknownType() || altPropType.isUnknownType() ||\n                  altPropType.isEquivalentTo(propType))) {\n<END_BUG>"
      },
      "18": {
        "start_line": 268,
        "end_line": 268,
        "file": "src/com/google/javascript/rhino/jstype/RecordType.java",
        "code": "<START_BUG>\n      if (!propA.isUnknownType() && !propB.isUnknownType()) {\n<END_BUG>"
      },
      "19": {
        "start_line": 280,
        "end_line": 280,
        "file": "src/com/google/javascript/rhino/jstype/RecordType.java",
        "code": "<START_BUG>\n          }\n<END_BUG>"
      },
      "20": {
        "start_line": 334,
        "end_line": 349,
        "file": "src/com/google/javascript/rhino/jstype/UnionType.java",
        "code": "<START_BUG>\n      UnionType that, boolean tolerateUnknowns) {\n    if (!tolerateUnknowns\n        && alternates.size() != that.alternates.size()) {\n      return false;\n    }\n    for (JSType alternate : that.alternates) {\n      if (!hasAlternate(alternate, tolerateUnknowns)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private boolean hasAlternate(JSType type, boolean tolerateUnknowns) {\n    for (JSType alternate : alternates) {\n      if (alternate.checkEquivalenceHelper(type, tolerateUnknowns)) {\n<END_BUG>"
      }
    },
    "buggy_code": {
      "0": {
        "start_line": 177,
        "end_line": 201,
        "file": "src/com/google/javascript/rhino/jstype/ArrowType.java",
        "code": "boolean hasEqualParameters(ArrowType that, boolean tolerateUnknowns) {\n    Node thisParam = parameters.getFirstChild();\n    Node otherParam = that.parameters.getFirstChild();\n    while (thisParam != null && otherParam != null) {\n      JSType thisParamType = thisParam.getJSType();\n      JSType otherParamType = otherParam.getJSType();\n      if (thisParamType != null) {\n        // Both parameter lists give a type for this param, it should be equal\n        if (otherParamType != null &&\n            !thisParamType.checkEquivalenceHelper(\n                otherParamType, tolerateUnknowns)) {\n          return false;\n        }\n      } else {\n        if (otherParamType != null) {\n          return false;\n        }\n      }\n      thisParam = thisParam.getNext();\n      otherParam = otherParam.getNext();\n    }\n    // One of the parameters is null, so the types are only equal if both\n    // parameter lists are null (they are equal).\n    return thisParam == otherParam;\n  }",
        "javadoc": "/**\n * An equivalence visitor.\n */\n"
      },
      "1": {
        "start_line": 203,
        "end_line": 210,
        "file": "src/com/google/javascript/rhino/jstype/ArrowType.java",
        "code": "boolean checkArrowEquivalenceHelper(\n      ArrowType that, boolean tolerateUnknowns) {\n    // Please keep this method in sync with the hashCode() method below.\n    if (!returnType.checkEquivalenceHelper(that.returnType, tolerateUnknowns)) {\n      return false;\n    }\n    return hasEqualParameters(that, tolerateUnknowns);\n  }",
        "javadoc": "/**\n * An equivalence visitor.\n */\n"
      },
      "2": {
        "start_line": 789,
        "end_line": 828,
        "file": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "code": "private FunctionType tryMergeFunctionPiecewise(\n      FunctionType other, boolean leastSuper) {\n    Node newParamsNode = null;\n    if (call.hasEqualParameters(other.call, false)) {\n      newParamsNode = call.parameters;\n    } else {\n      // If the parameters are not equal, don't try to merge them.\n      // Someday, we should try to merge the individual params.\n      return null;\n    }\n\n    JSType newReturnType = leastSuper ?\n        call.returnType.getLeastSupertype(other.call.returnType) :\n        call.returnType.getGreatestSubtype(other.call.returnType);\n\n    ObjectType newTypeOfThis = null;\n    if (isEquivalent(typeOfThis, other.typeOfThis)) {\n      newTypeOfThis = typeOfThis;\n    } else {\n      JSType maybeNewTypeOfThis = leastSuper ?\n          typeOfThis.getLeastSupertype(other.typeOfThis) :\n          typeOfThis.getGreatestSubtype(other.typeOfThis);\n      if (maybeNewTypeOfThis instanceof ObjectType) {\n        newTypeOfThis = (ObjectType) maybeNewTypeOfThis;\n      } else {\n        newTypeOfThis = leastSuper ?\n            registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE) :\n            registry.getNativeObjectType(JSTypeNative.NO_OBJECT_TYPE);\n      }\n    }\n\n    boolean newReturnTypeInferred =\n        call.returnTypeInferred || other.call.returnTypeInferred;\n\n    return new FunctionType(\n        registry, null, null,\n        new ArrowType(\n            registry, newParamsNode, newReturnType, newReturnTypeInferred),\n        newTypeOfThis, null, false, false);\n  }",
        "javadoc": "/**\n * An equivalence visitor.\n */\n"
      },
      "3": {
        "start_line": 889,
        "end_line": 910,
        "file": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "code": "boolean checkFunctionEquivalenceHelper(\n      FunctionType that, boolean tolerateUnknowns) {\n    if (isConstructor()) {\n      if (that.isConstructor()) {\n        return this == that;\n      }\n      return false;\n    }\n    if (isInterface()) {\n      if (that.isInterface()) {\n        return getReferenceName().equals(that.getReferenceName());\n      }\n      return false;\n    }\n    if (that.isInterface()) {\n      return false;\n    }\n\n    return typeOfThis.checkEquivalenceHelper(\n        that.typeOfThis, tolerateUnknowns) &&\n        call.checkArrowEquivalenceHelper(that.call, tolerateUnknowns);\n  }",
        "javadoc": "/**\n * An equivalence visitor.\n */\n"
      },
      "4": {
        "start_line": 917,
        "end_line": 919,
        "file": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "code": "public boolean hasEqualCallType(FunctionType otherType) {\n    return this.call.checkArrowEquivalenceHelper(otherType.call, false);\n  }",
        "javadoc": ""
      },
      "5": {
        "start_line": 491,
        "end_line": 493,
        "file": "src/com/google/javascript/rhino/jstype/JSType.java",
        "code": "public final boolean isEquivalentTo(JSType that) {\n    return checkEquivalenceHelper(that, false);\n  }",
        "javadoc": ""
      },
      "6": {
        "start_line": 499,
        "end_line": 501,
        "file": "src/com/google/javascript/rhino/jstype/JSType.java",
        "code": "public final boolean isInvariant(JSType that) {\n    return checkEquivalenceHelper(that, false);\n  }",
        "javadoc": ""
      },
      "7": {
        "start_line": 513,
        "end_line": 606,
        "file": "src/com/google/javascript/rhino/jstype/JSType.java",
        "code": "public final boolean differsFrom(JSType that) {\n    return !checkEquivalenceHelper(that, true);\n  }\n\n  /**\n   * An equivalence visitor.\n   */\n  boolean checkEquivalenceHelper(JSType that, boolean tolerateUnknowns) {\n    if (this == that) {\n      return true;\n    }\n\n    boolean thisUnknown = isUnknownType();\n    boolean thatUnknown = that.isUnknownType();\n    if (thisUnknown || thatUnknown) {\n      if (tolerateUnknowns) {\n        // If we're checking for invariance, the unknown type is invariant\n        // with everyone.\n        // If we're checking data flow, then two types are the same if they're\n        // both unknown.\n        return thisUnknown && thatUnknown;\n      } else if (thisUnknown && thatUnknown &&\n          (isNominalType() ^ that.isNominalType())) {\n        // If they're both unknown, but one is a nominal type and the other\n        // is not, then we should fail out immediately. This ensures that\n        // we won't unbox the unknowns further down.\n        return false;\n      }\n    }\n\n    if (isUnionType() && that.isUnionType()) {\n      return this.toMaybeUnionType().checkUnionEquivalenceHelper(\n          that.toMaybeUnionType(), tolerateUnknowns);\n    }\n\n    if (isFunctionType() && that.isFunctionType()) {\n      return this.toMaybeFunctionType().checkFunctionEquivalenceHelper(\n          that.toMaybeFunctionType(), tolerateUnknowns);\n    }\n\n    if (isRecordType() && that.isRecordType()) {\n      return this.toMaybeRecordType().checkRecordEquivalenceHelper(\n          that.toMaybeRecordType(), tolerateUnknowns);\n    }\n\n    ParameterizedType thisParamType = toMaybeParameterizedType();\n    ParameterizedType thatParamType = that.toMaybeParameterizedType();\n    if (thisParamType != null || thatParamType != null) {\n      // Check if one type is parameterized, but the other is not.\n      boolean paramsMatch = false;\n      if (thisParamType != null && thatParamType != null) {\n        paramsMatch = thisParamType.getParameterType().checkEquivalenceHelper(\n            thatParamType.getParameterType(), tolerateUnknowns);\n      } else if (tolerateUnknowns) {\n        // If one of the type parameters is unknown, but the other is not,\n        // then we consider these the same for the purposes of data flow\n        // and invariance.\n        paramsMatch = true;\n      } else {\n        paramsMatch = false;\n      }\n\n      JSType thisRootType = thisParamType == null ?\n          this : thisParamType.getReferencedTypeInternal();\n      JSType thatRootType = thatParamType == null ?\n          that : thatParamType.getReferencedTypeInternal();\n      return paramsMatch &&\n          thisRootType.checkEquivalenceHelper(thatRootType, tolerateUnknowns);\n    }\n\n    if (isNominalType() && that.isNominalType()) {\n      return toObjectType().getReferenceName().equals(\n          that.toObjectType().getReferenceName());\n    }\n\n    // Unbox other proxies.\n    if (this instanceof ProxyObjectType) {\n      return ((ProxyObjectType) this)\n          .getReferencedTypeInternal().checkEquivalenceHelper(\n              that, tolerateUnknowns);\n    }\n\n    if (that instanceof ProxyObjectType) {\n      return checkEquivalenceHelper(\n          ((ProxyObjectType) that).getReferencedTypeInternal(),\n          tolerateUnknowns);\n    }\n\n    // Relies on the fact that for the base {@link JSType}, only one\n    // instance of each sub-type will ever be created in a given registry, so\n    // there is no need to verify members. If the object pointers are not\n    // identical, then the type member must be different.\n    return this == that;\n  }",
        "javadoc": "/**\n * Determines if typeA is a subtype of typeB\n */\n"
      },
      "8": {
        "start_line": 117,
        "end_line": 131,
        "file": "src/com/google/javascript/rhino/jstype/RecordType.java",
        "code": "boolean checkRecordEquivalenceHelper(\n      RecordType otherRecord, boolean tolerateUnknowns) {\n    Set<String> keySet = properties.keySet();\n    Map<String, JSType> otherProps = otherRecord.properties;\n    if (!otherProps.keySet().equals(keySet)) {\n      return false;\n    }\n    for (String key : keySet) {\n      if (!otherProps.get(key).checkEquivalenceHelper(\n              properties.get(key), tolerateUnknowns)) {\n        return false;\n      }\n    }\n    return true;\n  }",
        "javadoc": "/**\n * Determines if typeA is a subtype of typeB\n */\n"
      },
      "9": {
        "start_line": 153,
        "end_line": 213,
        "file": "src/com/google/javascript/rhino/jstype/RecordType.java",
        "code": "JSType getGreatestSubtypeHelper(JSType that) {\n    if (that.isRecordType()) {\n      RecordType thatRecord = that.toMaybeRecordType();\n      RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n      builder.setSynthesized(true);\n\n      // The greatest subtype consists of those *unique* properties of both\n      // record types. If any property conflicts, then the NO_TYPE type\n      // is returned.\n      for (String property : properties.keySet()) {\n        if (thatRecord.hasProperty(property) &&\n            !thatRecord.getPropertyType(property).isInvariant(\n                getPropertyType(property))) {\n          return registry.getNativeObjectType(JSTypeNative.NO_TYPE);\n        }\n\n        builder.addProperty(property, getPropertyType(property),\n            getPropertyNode(property));\n      }\n\n      for (String property : thatRecord.properties.keySet()) {\n        if (!hasProperty(property)) {\n          builder.addProperty(property, thatRecord.getPropertyType(property),\n              thatRecord.getPropertyNode(property));\n        }\n      }\n\n      return builder.build();\n    }\n\n    JSType greatestSubtype = registry.getNativeType(\n        JSTypeNative.NO_OBJECT_TYPE);\n    JSType thatRestrictedToObj =\n        registry.getNativeType(JSTypeNative.OBJECT_TYPE)\n        .getGreatestSubtype(that);\n    if (!thatRestrictedToObj.isEmptyType()) {\n      // In this branch, the other type is some object type. We find\n      // the greatest subtype with the following algorithm:\n      // 1) For each property \"x\" of this record type, take the union\n      //    of all classes with a property \"x\" with a compatible property type.\n      //    and which are a subtype of {@code that}.\n      // 2) Take the intersection of all of these unions.\n      for (Map.Entry<String, JSType> entry : properties.entrySet()) {\n        String propName = entry.getKey();\n        JSType propType = entry.getValue();\n        UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n        for (ObjectType alt :\n                 registry.getEachReferenceTypeWithProperty(propName)) {\n          JSType altPropType = alt.getPropertyType(propName);\n          if (altPropType != null && !alt.isEquivalentTo(this) &&\n              alt.isSubtype(that) &&\n              (propType.isUnknownType() || altPropType.isUnknownType() ||\n                  altPropType.isEquivalentTo(propType))) {\n            builder.addAlternate(alt);\n          }\n        }\n        greatestSubtype = greatestSubtype.getLeastSupertype(builder.build());\n      }\n    }\n    return greatestSubtype;\n  }",
        "javadoc": "/**\n * @return True if our parameter spec is equal to {@code that}'s parameter\n *     spec.\n */\n"
      },
      "10": {
        "start_line": 243,
        "end_line": 286,
        "file": "src/com/google/javascript/rhino/jstype/RecordType.java",
        "code": "static boolean isSubtype(ObjectType typeA, RecordType typeB) {\n    // typeA is a subtype of record type typeB iff:\n    // 1) typeA has all the properties declared in typeB.\n    // 2) And for each property of typeB,\n    //    2a) if the property of typeA is declared, it must be equal\n    //        to the type of the property of typeB,\n    //    2b) otherwise, it must be a subtype of the property of typeB.\n    //\n    // To figure out why this is true, consider the following pseudo-code:\n    // /** @type {{a: (Object,null)}} */ var x;\n    // /** @type {{a: !Object}} */ var y;\n    // var z = {a: {}};\n    // x.a = null;\n    //\n    // y cannot be assigned to x, because line 4 would violate y's declared\n    // properties. But z can be assigned to x. Even though z and y are the\n    // same type, the properties of z are inferred--and so an assignment\n    // to the property of z would not violate any restrictions on it.\n    for (String property : typeB.properties.keySet()) {\n      if (!typeA.hasProperty(property)) {\n        return false;\n      }\n\n      JSType propA = typeA.getPropertyType(property);\n      JSType propB = typeB.getPropertyType(property);\n      if (!propA.isUnknownType() && !propB.isUnknownType()) {\n      if (typeA.isPropertyTypeDeclared(property)) {\n        // If one declared property isn't invariant,\n        // then the whole record isn't covariant.\n        if (!propA.isInvariant(propB)) {\n          return false;\n        }\n      } else {\n        // If one inferred property isn't a subtype,\n        // then the whole record isn't covariant.\n        if (!propA.isSubtype(propB)) {\n          return false;\n          }\n        }\n      }\n    }\n\n    return true;\n  }",
        "javadoc": "/**\n * @return True if our parameter spec is equal to {@code that}'s parameter\n *     spec.\n */\n"
      },
      "11": {
        "start_line": 333,
        "end_line": 354,
        "file": "src/com/google/javascript/rhino/jstype/UnionType.java",
        "code": "boolean checkUnionEquivalenceHelper(\n      UnionType that, boolean tolerateUnknowns) {\n    if (!tolerateUnknowns\n        && alternates.size() != that.alternates.size()) {\n      return false;\n    }\n    for (JSType alternate : that.alternates) {\n      if (!hasAlternate(alternate, tolerateUnknowns)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private boolean hasAlternate(JSType type, boolean tolerateUnknowns) {\n    for (JSType alternate : alternates) {\n      if (alternate.checkEquivalenceHelper(type, tolerateUnknowns)) {\n        return true;\n      }\n    }\n    return false;\n  }",
        "javadoc": ""
      }
    },
    "delineated_bug": {
      "0": {
        "start_line": 177,
        "end_line": 201,
        "file": "src/com/google/javascript/rhino/jstype/ArrowType.java",
        "code": "<START_BUG>\nboolean hasEqualParameters(ArrowType that, boolean tolerateUnknowns) {\n<END_BUG>\n    Node thisParam = parameters.getFirstChild();\n    Node otherParam = that.parameters.getFirstChild();\n    while (thisParam != null && otherParam != null) {\n      JSType thisParamType = thisParam.getJSType();\n      JSType otherParamType = otherParam.getJSType();\n      if (thisParamType != null) {\n        // Both parameter lists give a type for this param, it should be equal\n        if (otherParamType != null &&\n            !thisParamType.checkEquivalenceHelper(\n<START_BUG>\n                otherParamType, tolerateUnknowns)) {\n<END_BUG>\n          return false;\n        }\n      } else {\n        if (otherParamType != null) {\n          return false;\n        }\n      }\n      thisParam = thisParam.getNext();\n      otherParam = otherParam.getNext();\n    }\n    // One of the parameters is null, so the types are only equal if both\n    // parameter lists are null (they are equal).\n    return thisParam == otherParam;\n  }",
        "javadoc": "/**\n * An equivalence visitor.\n */\n"
      },
      "1": {
        "start_line": 203,
        "end_line": 210,
        "file": "src/com/google/javascript/rhino/jstype/ArrowType.java",
        "code": "boolean checkArrowEquivalenceHelper(\n<START_BUG>\n      ArrowType that, boolean tolerateUnknowns) {\n    // Please keep this method in sync with the hashCode() method below.\n    if (!returnType.checkEquivalenceHelper(that.returnType, tolerateUnknowns)) {\n      return false;\n    }\n    return hasEqualParameters(that, tolerateUnknowns);\n<END_BUG>\n  }",
        "javadoc": "/**\n * An equivalence visitor.\n */\n"
      },
      "2": {
        "start_line": 789,
        "end_line": 828,
        "file": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "code": "private FunctionType tryMergeFunctionPiecewise(\n      FunctionType other, boolean leastSuper) {\n    Node newParamsNode = null;\n<START_BUG>\n    if (call.hasEqualParameters(other.call, false)) {\n<END_BUG>\n      newParamsNode = call.parameters;\n    } else {\n      // If the parameters are not equal, don't try to merge them.\n      // Someday, we should try to merge the individual params.\n      return null;\n    }\n\n    JSType newReturnType = leastSuper ?\n        call.returnType.getLeastSupertype(other.call.returnType) :\n        call.returnType.getGreatestSubtype(other.call.returnType);\n\n    ObjectType newTypeOfThis = null;\n    if (isEquivalent(typeOfThis, other.typeOfThis)) {\n      newTypeOfThis = typeOfThis;\n    } else {\n      JSType maybeNewTypeOfThis = leastSuper ?\n          typeOfThis.getLeastSupertype(other.typeOfThis) :\n          typeOfThis.getGreatestSubtype(other.typeOfThis);\n      if (maybeNewTypeOfThis instanceof ObjectType) {\n        newTypeOfThis = (ObjectType) maybeNewTypeOfThis;\n      } else {\n        newTypeOfThis = leastSuper ?\n            registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE) :\n            registry.getNativeObjectType(JSTypeNative.NO_OBJECT_TYPE);\n      }\n    }\n\n    boolean newReturnTypeInferred =\n        call.returnTypeInferred || other.call.returnTypeInferred;\n\n    return new FunctionType(\n        registry, null, null,\n        new ArrowType(\n            registry, newParamsNode, newReturnType, newReturnTypeInferred),\n        newTypeOfThis, null, false, false);\n  }",
        "javadoc": "/**\n * An equivalence visitor.\n */\n"
      },
      "3": {
        "start_line": 889,
        "end_line": 910,
        "file": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "code": "boolean checkFunctionEquivalenceHelper(\n<START_BUG>\n      FunctionType that, boolean tolerateUnknowns) {\n<END_BUG>\n    if (isConstructor()) {\n      if (that.isConstructor()) {\n        return this == that;\n      }\n      return false;\n    }\n    if (isInterface()) {\n      if (that.isInterface()) {\n        return getReferenceName().equals(that.getReferenceName());\n      }\n      return false;\n    }\n    if (that.isInterface()) {\n      return false;\n    }\n\n    return typeOfThis.checkEquivalenceHelper(\n<START_BUG>\n        that.typeOfThis, tolerateUnknowns) &&\n        call.checkArrowEquivalenceHelper(that.call, tolerateUnknowns);\n<END_BUG>\n  }",
        "javadoc": "/**\n * An equivalence visitor.\n */\n"
      },
      "4": {
        "start_line": 917,
        "end_line": 919,
        "file": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "code": "public boolean hasEqualCallType(FunctionType otherType) {\n<START_BUG>\n    return this.call.checkArrowEquivalenceHelper(otherType.call, false);\n<END_BUG>\n  }",
        "javadoc": ""
      },
      "5": {
        "start_line": 491,
        "end_line": 493,
        "file": "src/com/google/javascript/rhino/jstype/JSType.java",
        "code": "public final boolean isEquivalentTo(JSType that) {\n<START_BUG>\n    return checkEquivalenceHelper(that, false);\n<END_BUG>\n  }",
        "javadoc": ""
      },
      "6": {
        "start_line": 499,
        "end_line": 501,
        "file": "src/com/google/javascript/rhino/jstype/JSType.java",
        "code": "public final boolean isInvariant(JSType that) {\n<START_BUG>\n    return checkEquivalenceHelper(that, false);\n<END_BUG>\n  }",
        "javadoc": ""
      },
      "7": {
        "start_line": 513,
        "end_line": 606,
        "file": "src/com/google/javascript/rhino/jstype/JSType.java",
        "code": "public final boolean differsFrom(JSType that) {\n<START_BUG>\n    return !checkEquivalenceHelper(that, true);\n  }\n\n  /**\n   * An equivalence visitor.\n   */\n  boolean checkEquivalenceHelper(JSType that, boolean tolerateUnknowns) {\n<END_BUG>\n    if (this == that) {\n      return true;\n    }\n\n    boolean thisUnknown = isUnknownType();\n    boolean thatUnknown = that.isUnknownType();\n    if (thisUnknown || thatUnknown) {\n<START_BUG>\n      if (tolerateUnknowns) {\n        // If we're checking for invariance, the unknown type is invariant\n        // with everyone.\n<END_BUG>\n        // If we're checking data flow, then two types are the same if they're\n        // both unknown.\n        return thisUnknown && thatUnknown;\n      } else if (thisUnknown && thatUnknown &&\n          (isNominalType() ^ that.isNominalType())) {\n        // If they're both unknown, but one is a nominal type and the other\n        // is not, then we should fail out immediately. This ensures that\n        // we won't unbox the unknowns further down.\n        return false;\n      }\n    }\n\n    if (isUnionType() && that.isUnionType()) {\n      return this.toMaybeUnionType().checkUnionEquivalenceHelper(\n<START_BUG>\n          that.toMaybeUnionType(), tolerateUnknowns);\n    }\n\n    if (isFunctionType() && that.isFunctionType()) {\n      return this.toMaybeFunctionType().checkFunctionEquivalenceHelper(\n          that.toMaybeFunctionType(), tolerateUnknowns);\n    }\n\n    if (isRecordType() && that.isRecordType()) {\n      return this.toMaybeRecordType().checkRecordEquivalenceHelper(\n          that.toMaybeRecordType(), tolerateUnknowns);\n<END_BUG>\n    }\n\n    ParameterizedType thisParamType = toMaybeParameterizedType();\n    ParameterizedType thatParamType = that.toMaybeParameterizedType();\n    if (thisParamType != null || thatParamType != null) {\n      // Check if one type is parameterized, but the other is not.\n      boolean paramsMatch = false;\n      if (thisParamType != null && thatParamType != null) {\n        paramsMatch = thisParamType.getParameterType().checkEquivalenceHelper(\n<START_BUG>\n            thatParamType.getParameterType(), tolerateUnknowns);\n      } else if (tolerateUnknowns) {\n        // If one of the type parameters is unknown, but the other is not,\n        // then we consider these the same for the purposes of data flow\n        // and invariance.\n        paramsMatch = true;\n      } else {\n        paramsMatch = false;\n<END_BUG>\n      }\n\n      JSType thisRootType = thisParamType == null ?\n          this : thisParamType.getReferencedTypeInternal();\n      JSType thatRootType = thatParamType == null ?\n          that : thatParamType.getReferencedTypeInternal();\n      return paramsMatch &&\n<START_BUG>\n          thisRootType.checkEquivalenceHelper(thatRootType, tolerateUnknowns);\n<END_BUG>\n    }\n\n    if (isNominalType() && that.isNominalType()) {\n      return toObjectType().getReferenceName().equals(\n          that.toObjectType().getReferenceName());\n    }\n\n    // Unbox other proxies.\n    if (this instanceof ProxyObjectType) {\n      return ((ProxyObjectType) this)\n          .getReferencedTypeInternal().checkEquivalenceHelper(\n<START_BUG>\n              that, tolerateUnknowns);\n    }\n\n    if (that instanceof ProxyObjectType) {\n      return checkEquivalenceHelper(\n          ((ProxyObjectType) that).getReferencedTypeInternal(),\n          tolerateUnknowns);\n<END_BUG>\n    }\n\n    // Relies on the fact that for the base {@link JSType}, only one\n    // instance of each sub-type will ever be created in a given registry, so\n    // there is no need to verify members. If the object pointers are not\n    // identical, then the type member must be different.\n    return this == that;\n  }",
        "javadoc": "/**\n * Determines if typeA is a subtype of typeB\n */\n"
      },
      "8": {
        "start_line": 117,
        "end_line": 131,
        "file": "src/com/google/javascript/rhino/jstype/RecordType.java",
        "code": "boolean checkRecordEquivalenceHelper(\n<START_BUG>\n      RecordType otherRecord, boolean tolerateUnknowns) {\n<END_BUG>\n    Set<String> keySet = properties.keySet();\n    Map<String, JSType> otherProps = otherRecord.properties;\n    if (!otherProps.keySet().equals(keySet)) {\n      return false;\n    }\n    for (String key : keySet) {\n      if (!otherProps.get(key).checkEquivalenceHelper(\n<START_BUG>\n              properties.get(key), tolerateUnknowns)) {\n<END_BUG>\n        return false;\n      }\n    }\n    return true;\n  }",
        "javadoc": "/**\n * Determines if typeA is a subtype of typeB\n */\n"
      },
      "9": {
        "start_line": 153,
        "end_line": 213,
        "file": "src/com/google/javascript/rhino/jstype/RecordType.java",
        "code": "JSType getGreatestSubtypeHelper(JSType that) {\n    if (that.isRecordType()) {\n      RecordType thatRecord = that.toMaybeRecordType();\n      RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n      builder.setSynthesized(true);\n\n      // The greatest subtype consists of those *unique* properties of both\n      // record types. If any property conflicts, then the NO_TYPE type\n      // is returned.\n      for (String property : properties.keySet()) {\n        if (thatRecord.hasProperty(property) &&\n            !thatRecord.getPropertyType(property).isInvariant(\n                getPropertyType(property))) {\n          return registry.getNativeObjectType(JSTypeNative.NO_TYPE);\n        }\n\n        builder.addProperty(property, getPropertyType(property),\n            getPropertyNode(property));\n      }\n\n      for (String property : thatRecord.properties.keySet()) {\n        if (!hasProperty(property)) {\n          builder.addProperty(property, thatRecord.getPropertyType(property),\n              thatRecord.getPropertyNode(property));\n        }\n      }\n\n      return builder.build();\n    }\n\n    JSType greatestSubtype = registry.getNativeType(\n        JSTypeNative.NO_OBJECT_TYPE);\n    JSType thatRestrictedToObj =\n        registry.getNativeType(JSTypeNative.OBJECT_TYPE)\n        .getGreatestSubtype(that);\n    if (!thatRestrictedToObj.isEmptyType()) {\n      // In this branch, the other type is some object type. We find\n      // the greatest subtype with the following algorithm:\n      // 1) For each property \"x\" of this record type, take the union\n      //    of all classes with a property \"x\" with a compatible property type.\n      //    and which are a subtype of {@code that}.\n      // 2) Take the intersection of all of these unions.\n      for (Map.Entry<String, JSType> entry : properties.entrySet()) {\n        String propName = entry.getKey();\n        JSType propType = entry.getValue();\n        UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n        for (ObjectType alt :\n                 registry.getEachReferenceTypeWithProperty(propName)) {\n          JSType altPropType = alt.getPropertyType(propName);\n          if (altPropType != null && !alt.isEquivalentTo(this) &&\n              alt.isSubtype(that) &&\n<START_BUG>\n              (propType.isUnknownType() || altPropType.isUnknownType() ||\n                  altPropType.isEquivalentTo(propType))) {\n<END_BUG>\n            builder.addAlternate(alt);\n          }\n        }\n        greatestSubtype = greatestSubtype.getLeastSupertype(builder.build());\n      }\n    }\n    return greatestSubtype;\n  }",
        "javadoc": "/**\n * @return True if our parameter spec is equal to {@code that}'s parameter\n *     spec.\n */\n"
      },
      "10": {
        "start_line": 243,
        "end_line": 286,
        "file": "src/com/google/javascript/rhino/jstype/RecordType.java",
        "code": "static boolean isSubtype(ObjectType typeA, RecordType typeB) {\n    // typeA is a subtype of record type typeB iff:\n    // 1) typeA has all the properties declared in typeB.\n    // 2) And for each property of typeB,\n    //    2a) if the property of typeA is declared, it must be equal\n    //        to the type of the property of typeB,\n    //    2b) otherwise, it must be a subtype of the property of typeB.\n    //\n    // To figure out why this is true, consider the following pseudo-code:\n    // /** @type {{a: (Object,null)}} */ var x;\n    // /** @type {{a: !Object}} */ var y;\n    // var z = {a: {}};\n    // x.a = null;\n    //\n    // y cannot be assigned to x, because line 4 would violate y's declared\n    // properties. But z can be assigned to x. Even though z and y are the\n    // same type, the properties of z are inferred--and so an assignment\n    // to the property of z would not violate any restrictions on it.\n    for (String property : typeB.properties.keySet()) {\n      if (!typeA.hasProperty(property)) {\n        return false;\n      }\n\n      JSType propA = typeA.getPropertyType(property);\n      JSType propB = typeB.getPropertyType(property);\n<START_BUG>\n      if (!propA.isUnknownType() && !propB.isUnknownType()) {\n<END_BUG>\n      if (typeA.isPropertyTypeDeclared(property)) {\n        // If one declared property isn't invariant,\n        // then the whole record isn't covariant.\n        if (!propA.isInvariant(propB)) {\n          return false;\n        }\n      } else {\n        // If one inferred property isn't a subtype,\n        // then the whole record isn't covariant.\n        if (!propA.isSubtype(propB)) {\n          return false;\n<START_BUG>\n          }\n<END_BUG>\n        }\n      }\n    }\n\n    return true;\n  }",
        "javadoc": "/**\n * @return True if our parameter spec is equal to {@code that}'s parameter\n *     spec.\n */\n"
      },
      "11": {
        "start_line": 333,
        "end_line": 354,
        "file": "src/com/google/javascript/rhino/jstype/UnionType.java",
        "code": "boolean checkUnionEquivalenceHelper(\n<START_BUG>\n      UnionType that, boolean tolerateUnknowns) {\n    if (!tolerateUnknowns\n        && alternates.size() != that.alternates.size()) {\n      return false;\n    }\n    for (JSType alternate : that.alternates) {\n      if (!hasAlternate(alternate, tolerateUnknowns)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private boolean hasAlternate(JSType type, boolean tolerateUnknowns) {\n    for (JSType alternate : alternates) {\n      if (alternate.checkEquivalenceHelper(type, tolerateUnknowns)) {\n<END_BUG>\n        return true;\n      }\n    }\n    return false;\n  }",
        "javadoc": ""
      }
    },
    "contained_scope": "method",
    "bug_count": 12,
    "triggered_tests": {
      "0": {
        "test_path": "com.google.javascript.jscomp.TypeCheckTest",
        "test_method": "testIssue791",
        "test_code": "testIssue791() throws Exception {\n    testTypes(\n        \"/** @param {{func: function()}} obj */\" +\n        \"function test1(obj) {}\" +\n        \"var fnStruc1 = {};\" +\n        \"fnStruc1.func = function() {};\" +\n        \"test1(fnStruc1);\");\n  }",
        "clean_err_msg": "junit.framework.AssertionFailedError: unexpected warnings(s):"
      },
      "1": {
        "test_path": "com.google.javascript.rhino.jstype.RecordTypeTest",
        "test_method": "testSubtypeWithUnknowns2",
        "test_code": "testSubtypeWithUnknowns2() throws Exception {\n    JSType recordA = new RecordTypeBuilder(registry)\n        .addProperty(\"a\",\n            new FunctionBuilder(registry)\n            .withReturnType(NUMBER_TYPE)\n            .build(),\n            null)\n        .build();\n    JSType recordB = new RecordTypeBuilder(registry)\n        .addProperty(\"a\",\n            new FunctionBuilder(registry)\n            .withReturnType(UNKNOWN_TYPE)\n            .build(),\n            null)\n        .build();\n    assertTrue(recordA.isSubtype(recordB));\n    assertTrue(recordB.isSubtype(recordA));\n  }",
        "clean_err_msg": "junit.framework.AssertionFailedError"
      }
    },
    "buggy_files": {
      "0": "src/com/google/javascript/rhino/jstype/ArrowType.java",
      "1": "src/com/google/javascript/rhino/jstype/EquivalenceMethod.java",
      "2": "src/com/google/javascript/rhino/jstype/FunctionType.java",
      "3": "src/com/google/javascript/rhino/jstype/JSType.java",
      "4": "src/com/google/javascript/rhino/jstype/RecordType.java",
      "5": "src/com/google/javascript/rhino/jstype/UnionType.java"
    },
    "hunk_type": "multi_file_four_or_more_hunks",
    "hunk_mapping": {
      "0": [
        {
          "start_line": 177,
          "end_line": 177,
          "file": "src/com/google/javascript/rhino/jstype/ArrowType.java",
          "code": "<START_BUG>\n  boolean hasEqualParameters(ArrowType that, boolean tolerateUnknowns) {\n<END_BUG>"
        },
        {
          "start_line": 187,
          "end_line": 187,
          "file": "src/com/google/javascript/rhino/jstype/ArrowType.java",
          "code": "<START_BUG>\n                otherParamType, tolerateUnknowns)) {\n<END_BUG>"
        }
      ],
      "1": [
        {
          "start_line": 204,
          "end_line": 209,
          "file": "src/com/google/javascript/rhino/jstype/ArrowType.java",
          "code": "<START_BUG>\n      ArrowType that, boolean tolerateUnknowns) {\n    // Please keep this method in sync with the hashCode() method below.\n    if (!returnType.checkEquivalenceHelper(that.returnType, tolerateUnknowns)) {\n      return false;\n    }\n    return hasEqualParameters(that, tolerateUnknowns);\n<END_BUG>"
        }
      ],
      "2": [
        {
          "start_line": 792,
          "end_line": 792,
          "file": "src/com/google/javascript/rhino/jstype/FunctionType.java",
          "code": "<START_BUG>\n    if (call.hasEqualParameters(other.call, false)) {\n<END_BUG>"
        }
      ],
      "3": [
        {
          "start_line": 890,
          "end_line": 890,
          "file": "src/com/google/javascript/rhino/jstype/FunctionType.java",
          "code": "<START_BUG>\n      FunctionType that, boolean tolerateUnknowns) {\n<END_BUG>"
        },
        {
          "start_line": 908,
          "end_line": 909,
          "file": "src/com/google/javascript/rhino/jstype/FunctionType.java",
          "code": "<START_BUG>\n        that.typeOfThis, tolerateUnknowns) &&\n        call.checkArrowEquivalenceHelper(that.call, tolerateUnknowns);\n<END_BUG>"
        }
      ],
      "4": [
        {
          "start_line": 918,
          "end_line": 918,
          "file": "src/com/google/javascript/rhino/jstype/FunctionType.java",
          "code": "<START_BUG>\n    return this.call.checkArrowEquivalenceHelper(otherType.call, false);\n<END_BUG>"
        }
      ],
      "5": [
        {
          "start_line": 492,
          "end_line": 492,
          "file": "src/com/google/javascript/rhino/jstype/JSType.java",
          "code": "<START_BUG>\n    return checkEquivalenceHelper(that, false);\n<END_BUG>"
        }
      ],
      "6": [
        {
          "start_line": 500,
          "end_line": 500,
          "file": "src/com/google/javascript/rhino/jstype/JSType.java",
          "code": "<START_BUG>\n    return checkEquivalenceHelper(that, false);\n<END_BUG>"
        }
      ],
      "7": [
        {
          "start_line": 514,
          "end_line": 520,
          "file": "src/com/google/javascript/rhino/jstype/JSType.java",
          "code": "<START_BUG>\n    return !checkEquivalenceHelper(that, true);\n  }\n\n  /**\n   * An equivalence visitor.\n   */\n  boolean checkEquivalenceHelper(JSType that, boolean tolerateUnknowns) {\n<END_BUG>"
        },
        {
          "start_line": 528,
          "end_line": 530,
          "file": "src/com/google/javascript/rhino/jstype/JSType.java",
          "code": "<START_BUG>\n      if (tolerateUnknowns) {\n        // If we're checking for invariance, the unknown type is invariant\n        // with everyone.\n<END_BUG>"
        },
        {
          "start_line": 545,
          "end_line": 555,
          "file": "src/com/google/javascript/rhino/jstype/JSType.java",
          "code": "<START_BUG>\n          that.toMaybeUnionType(), tolerateUnknowns);\n    }\n\n    if (isFunctionType() && that.isFunctionType()) {\n      return this.toMaybeFunctionType().checkFunctionEquivalenceHelper(\n          that.toMaybeFunctionType(), tolerateUnknowns);\n    }\n\n    if (isRecordType() && that.isRecordType()) {\n      return this.toMaybeRecordType().checkRecordEquivalenceHelper(\n          that.toMaybeRecordType(), tolerateUnknowns);\n<END_BUG>"
        },
        {
          "start_line": 565,
          "end_line": 572,
          "file": "src/com/google/javascript/rhino/jstype/JSType.java",
          "code": "<START_BUG>\n            thatParamType.getParameterType(), tolerateUnknowns);\n      } else if (tolerateUnknowns) {\n        // If one of the type parameters is unknown, but the other is not,\n        // then we consider these the same for the purposes of data flow\n        // and invariance.\n        paramsMatch = true;\n      } else {\n        paramsMatch = false;\n<END_BUG>"
        },
        {
          "start_line": 580,
          "end_line": 580,
          "file": "src/com/google/javascript/rhino/jstype/JSType.java",
          "code": "<START_BUG>\n          thisRootType.checkEquivalenceHelper(thatRootType, tolerateUnknowns);\n<END_BUG>"
        },
        {
          "start_line": 592,
          "end_line": 598,
          "file": "src/com/google/javascript/rhino/jstype/JSType.java",
          "code": "<START_BUG>\n              that, tolerateUnknowns);\n    }\n\n    if (that instanceof ProxyObjectType) {\n      return checkEquivalenceHelper(\n          ((ProxyObjectType) that).getReferencedTypeInternal(),\n          tolerateUnknowns);\n<END_BUG>"
        }
      ],
      "8": [
        {
          "start_line": 118,
          "end_line": 118,
          "file": "src/com/google/javascript/rhino/jstype/RecordType.java",
          "code": "<START_BUG>\n      RecordType otherRecord, boolean tolerateUnknowns) {\n<END_BUG>"
        },
        {
          "start_line": 126,
          "end_line": 126,
          "file": "src/com/google/javascript/rhino/jstype/RecordType.java",
          "code": "<START_BUG>\n              properties.get(key), tolerateUnknowns)) {\n<END_BUG>"
        }
      ],
      "9": [
        {
          "start_line": 204,
          "end_line": 205,
          "file": "src/com/google/javascript/rhino/jstype/RecordType.java",
          "code": "<START_BUG>\n              (propType.isUnknownType() || altPropType.isUnknownType() ||\n                  altPropType.isEquivalentTo(propType))) {\n<END_BUG>"
        }
      ],
      "10": [
        {
          "start_line": 268,
          "end_line": 268,
          "file": "src/com/google/javascript/rhino/jstype/RecordType.java",
          "code": "<START_BUG>\n      if (!propA.isUnknownType() && !propB.isUnknownType()) {\n<END_BUG>"
        },
        {
          "start_line": 280,
          "end_line": 280,
          "file": "src/com/google/javascript/rhino/jstype/RecordType.java",
          "code": "<START_BUG>\n          }\n<END_BUG>"
        }
      ],
      "11": [
        {
          "start_line": 334,
          "end_line": 349,
          "file": "src/com/google/javascript/rhino/jstype/UnionType.java",
          "code": "<START_BUG>\n      UnionType that, boolean tolerateUnknowns) {\n    if (!tolerateUnknowns\n        && alternates.size() != that.alternates.size()) {\n      return false;\n    }\n    for (JSType alternate : that.alternates) {\n      if (!hasAlternate(alternate, tolerateUnknowns)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private boolean hasAlternate(JSType type, boolean tolerateUnknowns) {\n    for (JSType alternate : alternates) {\n      if (alternate.checkEquivalenceHelper(type, tolerateUnknowns)) {\n<END_BUG>"
        }
      ]
    },
    "bug_report": {
      "url": "https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-791.json",
      "bug_description": "Strange \"wrong parameter\" warning for callback function",
      "title": ""
    }
  },
  "Math_77": {
    "buggy_hunks": {
      "0": {
        "start_line": 721,
        "end_line": 721,
        "file": "src/main/java/org/apache/commons/math/linear/ArrayRealVector.java",
        "code": "<START_BUG>\n            max += Math.max(max, Math.abs(a));\n<END_BUG>"
      },
      "1": {
        "start_line": 498,
        "end_line": 506,
        "file": "src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java",
        "code": "<START_BUG>\n    public double getLInfNorm() {\n        double max = 0;\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            max += iter.value();\n        }\n        return max;\n    }\n<END_BUG>"
      }
    },
    "buggy_code": {
      "0": {
        "start_line": 717,
        "end_line": 724,
        "file": "src/main/java/org/apache/commons/math/linear/ArrayRealVector.java",
        "code": "@Override\n    public double getLInfNorm() {\n        double max = 0;\n        for (double a : data) {\n            max += Math.max(max, Math.abs(a));\n        }\n        return max;\n    }",
        "javadoc": "/**\n * {@inheritDoc}\n */\n"
      },
      "1": {
        "start_line": 498,
        "end_line": 506,
        "file": "src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java",
        "code": "public double getLInfNorm() {\n        double max = 0;\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            max += iter.value();\n        }\n        return max;\n    }",
        "javadoc": ""
      }
    },
    "delineated_bug": {
      "0": {
        "start_line": 717,
        "end_line": 724,
        "file": "src/main/java/org/apache/commons/math/linear/ArrayRealVector.java",
        "code": "@Override\n    public double getLInfNorm() {\n        double max = 0;\n        for (double a : data) {\n<START_BUG>\n            max += Math.max(max, Math.abs(a));\n<END_BUG>\n        }\n        return max;\n    }",
        "javadoc": "/**\n * {@inheritDoc}\n */\n"
      },
      "1": {
        "start_line": 498,
        "end_line": 506,
        "file": "src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java",
        "code": "<START_BUG>\npublic double getLInfNorm() {\n        double max = 0;\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            max += iter.value();\n        }\n        return max;\n    }\n<END_BUG>",
        "javadoc": ""
      }
    },
    "contained_scope": "method",
    "bug_count": 2,
    "triggered_tests": {
      "0": {
        "test_path": "org.apache.commons.math.linear.ArrayRealVectorTest",
        "test_method": "testBasicFunctions",
        "test_code": "testBasicFunctions() {\n        ArrayRealVector v1 = new ArrayRealVector(vec1);\n        ArrayRealVector v2 = new ArrayRealVector(vec2);\n        ArrayRealVector v5 = new ArrayRealVector(vec5);\n        ArrayRealVector v_null = new ArrayRealVector(vec_null);\n\n        RealVectorTestImpl v2_t = new RealVectorTestImpl(vec2);\n\n        // emacs calc: [-4, 0, 3, 1, -6, 3] A --> 8.4261497731763586307\n        double d_getNorm = v5.getNorm();\n        assertEquals(\"compare values  \", 8.4261497731763586307, d_getNorm);\n\n        // emacs calc: [-4, 0, 3, 1, -6, 3] vN --> 17\n        double d_getL1Norm = v5.getL1Norm();\n        assertEquals(\"compare values  \", 17.0, d_getL1Norm);\n\n        // emacs calc: [-4, 0, 3, 1, -6, 3] vn --> 6\n        double d_getLInfNorm = v5.getLInfNorm();\n        assertEquals(\"compare values  \", 6.0, d_getLInfNorm);\n\n\n        //octave =  sqrt(sumsq(v1-v2))\n        double dist = v1.getDistance(v2);\n        assertEquals(\"compare values  \",v1.subtract(v2).getNorm(), dist );\n\n        //octave =  sqrt(sumsq(v1-v2))\n        double dist_2 = v1.getDistance(v2_t);\n        assertEquals(\"compare values  \", v1.subtract(v2).getNorm(),dist_2 );\n\n        //octave =  sqrt(sumsq(v1-v2))\n        double dist_3 = v1.getDistance((RealVector) v2);\n        assertEquals(\"compare values  \", v1.subtract(v2).getNorm(),dist_3 );\n\n        //octave =  ???\n        double d_getL1Distance = v1. getL1Distance(v2);\n        assertEquals(\"compare values  \",9d, d_getL1Distance );\n\n        double d_getL1Distance_2 = v1. getL1Distance(v2_t);\n        assertEquals(\"compare values  \",9d, d_getL1Distance_2 );\n\n        double d_getL1Distance_3 = v1. getL1Distance((RealVector) v2);\n        assertEquals(\"compare values  \",9d, d_getL1Distance_3 );\n\n        //octave =  ???\n        double d_getLInfDistance = v1. getLInfDistance(v2);\n        assertEquals(\"compare values  \",3d, d_getLInfDistance );\n\n        double d_getLInfDistance_2 = v1. getLInfDistance(v2_t);\n        assertEquals(\"compare values  \",3d, d_getLInfDistance_2 );\n\n        double d_getLInfDistance_3 = v1. getLInfDistance((RealVector) v2);\n        assertEquals(\"compare values  \",3d, d_getLInfDistance_3 );\n\n        //octave =  v1 + v2\n        ArrayRealVector v_add = v1.add(v2);\n        double[] result_add = {5d, 7d, 9d};\n        assertClose(\"compare vect\" ,v_add.getData(),result_add,normTolerance);\n\n        RealVectorTestImpl vt2 = new RealVectorTestImpl(vec2);\n        RealVector v_add_i = v1.add(vt2);\n        double[] result_add_i = {5d, 7d, 9d};\n        assertClose(\"compare vect\" ,v_add_i.getData(),result_add_i,normTolerance);\n\n        //octave =  v1 - v2\n        ArrayRealVector v_subtract = v1.subtract(v2);\n        double[] result_subtract = {-3d, -3d, -3d};\n        assertClose(\"compare vect\" ,v_subtract.getData(),result_subtract,normTolerance);\n\n        RealVector v_subtract_i = v1.subtract(vt2);\n        double[] result_subtract_i = {-3d, -3d, -3d};\n        assertClose(\"compare vect\" ,v_subtract_i.getData(),result_subtract_i,normTolerance);\n\n        // octave v1 .* v2\n        ArrayRealVector  v_ebeMultiply = v1.ebeMultiply(v2);\n        double[] result_ebeMultiply = {4d, 10d, 18d};\n        assertClose(\"compare vect\" ,v_ebeMultiply.getData(),result_ebeMultiply,normTolerance);\n\n        RealVector  v_ebeMultiply_2 = v1.ebeMultiply(v2_t);\n        double[] result_ebeMultiply_2 = {4d, 10d, 18d};\n        assertClose(\"compare vect\" ,v_ebeMultiply_2.getData(),result_ebeMultiply_2,normTolerance);\n\n        RealVector  v_ebeMultiply_3 = v1.ebeMultiply((RealVector) v2);\n        double[] result_ebeMultiply_3 = {4d, 10d, 18d};\n        assertClose(\"compare vect\" ,v_ebeMultiply_3.getData(),result_ebeMultiply_3,normTolerance);\n\n        // octave v1 ./ v2\n        ArrayRealVector  v_ebeDivide = v1.ebeDivide(v2);\n        double[] result_ebeDivide = {0.25d, 0.4d, 0.5d};\n        assertClose(\"compare vect\" ,v_ebeDivide.getData(),result_ebeDivide,normTolerance);\n\n        RealVector  v_ebeDivide_2 = v1.ebeDivide(v2_t);\n        double[] result_ebeDivide_2 = {0.25d, 0.4d, 0.5d};\n        assertClose(\"compare vect\" ,v_ebeDivide_2.getData(),result_ebeDivide_2,normTolerance);\n\n        RealVector  v_ebeDivide_3 = v1.ebeDivide((RealVector) v2);\n        double[] result_ebeDivide_3 = {0.25d, 0.4d, 0.5d};\n        assertClose(\"compare vect\" ,v_ebeDivide_3.getData(),result_ebeDivide_3,normTolerance);\n\n        // octave  dot(v1,v2)\n        double dot =  v1.dotProduct(v2);\n        assertEquals(\"compare val \",32d, dot);\n\n        // octave  dot(v1,v2_t)\n        double dot_2 =  v1.dotProduct(v2_t);\n        assertEquals(\"compare val \",32d, dot_2);\n\n        RealMatrix m_outerProduct = v1.outerProduct(v2);\n        assertEquals(\"compare val \",4d, m_outerProduct.getEntry(0,0));\n\n        RealMatrix m_outerProduct_2 = v1.outerProduct(v2_t);\n        assertEquals(\"compare val \",4d, m_outerProduct_2.getEntry(0,0));\n\n        RealMatrix m_outerProduct_3 = v1.outerProduct((RealVector) v2);\n        assertEquals(\"compare val \",4d, m_outerProduct_3.getEntry(0,0));\n\n        RealVector v_unitVector = v1.unitVector();\n        RealVector v_unitVector_2 = v1.mapDivide(v1.getNorm());\n        assertClose(\"compare vect\" ,v_unitVector.getData(),v_unitVector_2.getData(),normTolerance);\n\n        try {\n            v_null.unitVector();\n            fail(\"Expecting ArithmeticException\");\n        } catch (ArithmeticException ex) {\n            // expected behavior\n        } catch (Exception e) {\n            fail(\"wrong exception caught\");\n        }\n\n        ArrayRealVector v_unitize = (ArrayRealVector)v1.copy();\n        v_unitize.unitize();\n        assertClose(\"compare vect\" ,v_unitVector_2.getData(),v_unitize.getData(),normTolerance);\n        try {\n            v_null.unitize();\n            fail(\"Expecting ArithmeticException\");\n        } catch (ArithmeticException ex) {\n            // expected behavior\n        } catch (Exception e) {\n            fail(\"wrong exception caught\");\n        }\n\n        ArrayRealVector v_projection = v1.projection(v2);\n        double[] result_projection = {1.662337662337662, 2.0779220779220777, 2.493506493506493};\n        assertClose(\"compare vect\", v_projection.getData(), result_projection, normTolerance);\n\n        RealVector v_projection_2 = v1.projection(v2_t);\n        double[] result_projection_2 = {1.662337662337662, 2.0779220779220777, 2.493506493506493};\n        assertClose(\"compare vect\", v_projection_2.getData(), result_projection_2, normTolerance);\n\n        RealVector v_projection_3 = v1.projection(v2.getData());\n        double[] result_projection_3 = {1.662337662337662, 2.0779220779220777, 2.493506493506493};\n        assertClose(\"compare vect\", v_projection_3.getData(), result_projection_3, normTolerance);\n\n    }",
        "clean_err_msg": "junit.framework.AssertionFailedError: compare values   expected:<6.0> but was:<128.0>"
      },
      "1": {
        "test_path": "org.apache.commons.math.linear.SparseRealVectorTest",
        "test_method": "testBasicFunctions",
        "test_code": "testBasicFunctions() {\n        OpenMapRealVector v1 = new OpenMapRealVector(vec1);\n        OpenMapRealVector v2 = new OpenMapRealVector(vec2);\n        OpenMapRealVector v5 = new OpenMapRealVector(vec5);\n        OpenMapRealVector v_null = new OpenMapRealVector(vec_null);\n\n        SparseRealVectorTestImpl v2_t = new SparseRealVectorTestImpl(vec2);\n\n        // emacs calc: [-4, 0, 3, 1, -6, 3] A --> 8.4261497731763586307\n        double d_getNorm = v5.getNorm();\n        assertEquals(\"compare values  \", 8.4261497731763586307, d_getNorm);\n\n        // emacs calc: [-4, 0, 3, 1, -6, 3] vN --> 17\n        double d_getL1Norm = v5.getL1Norm();\n        assertEquals(\"compare values  \", 17.0, d_getL1Norm);\n\n        // emacs calc: [-4, 0, 3, 1, -6, 3] vn --> 6\n        double d_getLInfNorm = v5.getLInfNorm();\n        assertEquals(\"compare values  \", 6.0, d_getLInfNorm);\n\n        //octave =  sqrt(sumsq(v1-v2))\n        double dist = v1.getDistance(v2);\n        assertEquals(\"compare values  \",v1.subtract(v2).getNorm(), dist );\n\n        //octave =  sqrt(sumsq(v1-v2))\n        double dist_2 = v1.getDistance(v2_t);\n        assertEquals(\"compare values  \", v1.subtract(v2).getNorm(),dist_2 );\n\n        //octave =  ???\n        double d_getL1Distance = v1. getL1Distance(v2);\n        assertEquals(\"compare values  \",9d, d_getL1Distance );\n\n        double d_getL1Distance_2 = v1. getL1Distance(v2_t);\n        assertEquals(\"compare values  \",9d, d_getL1Distance_2 );\n\n        //octave =  ???\n        double d_getLInfDistance = v1. getLInfDistance(v2);\n        assertEquals(\"compare values  \",3d, d_getLInfDistance );\n\n        double d_getLInfDistance_2 = v1. getLInfDistance(v2_t);\n        assertEquals(\"compare values  \",3d, d_getLInfDistance_2 );\n\n        //octave =  v1 + v2\n        OpenMapRealVector v_add = v1.add(v2);\n        double[] result_add = {5d, 7d, 9d};\n        assertClose(\"compare vect\" ,v_add.getData(),result_add,normTolerance);\n\n        SparseRealVectorTestImpl vt2 = new SparseRealVectorTestImpl(vec2);\n        RealVector v_add_i = v1.add(vt2);\n        double[] result_add_i = {5d, 7d, 9d};\n        assertClose(\"compare vect\" ,v_add_i.getData(),result_add_i,normTolerance);\n\n        //octave =  v1 - v2\n        OpenMapRealVector v_subtract = v1.subtract(v2);\n        double[] result_subtract = {-3d, -3d, -3d};\n        assertClose(\"compare vect\" ,v_subtract.getData(),result_subtract,normTolerance);\n\n        RealVector v_subtract_i = v1.subtract(vt2);\n        double[] result_subtract_i = {-3d, -3d, -3d};\n        assertClose(\"compare vect\" ,v_subtract_i.getData(),result_subtract_i,normTolerance);\n\n        // octave v1 .* v2\n        RealVector  v_ebeMultiply = v1.ebeMultiply(v2);\n        double[] result_ebeMultiply = {4d, 10d, 18d};\n        assertClose(\"compare vect\" ,v_ebeMultiply.getData(),result_ebeMultiply,normTolerance);\n\n        RealVector  v_ebeMultiply_2 = v1.ebeMultiply(v2_t);\n        double[] result_ebeMultiply_2 = {4d, 10d, 18d};\n        assertClose(\"compare vect\" ,v_ebeMultiply_2.getData(),result_ebeMultiply_2,normTolerance);\n\n        // octave v1 ./ v2\n        RealVector  v_ebeDivide = v1.ebeDivide(v2);\n        double[] result_ebeDivide = {0.25d, 0.4d, 0.5d};\n        assertClose(\"compare vect\" ,v_ebeDivide.getData(),result_ebeDivide,normTolerance);\n\n        RealVector  v_ebeDivide_2 = v1.ebeDivide(v2_t);\n        double[] result_ebeDivide_2 = {0.25d, 0.4d, 0.5d};\n        assertClose(\"compare vect\" ,v_ebeDivide_2.getData(),result_ebeDivide_2,normTolerance);\n\n        // octave  dot(v1,v2)\n        double dot =  v1.dotProduct(v2);\n        assertEquals(\"compare val \",32d, dot);\n\n        // octave  dot(v1,v2_t)\n        double dot_2 =  v1.dotProduct(v2_t);\n        assertEquals(\"compare val \",32d, dot_2);\n\n        RealMatrix m_outerProduct = v1.outerProduct(v2);\n        assertEquals(\"compare val \",4d, m_outerProduct.getEntry(0,0));\n\n        RealMatrix m_outerProduct_2 = v1.outerProduct(v2_t);\n        assertEquals(\"compare val \",4d, m_outerProduct_2.getEntry(0,0));\n\n        RealVector v_unitVector = v1.unitVector();\n        RealVector v_unitVector_2 = v1.mapDivide(v1.getNorm());\n        assertClose(\"compare vect\" ,v_unitVector.getData(),v_unitVector_2.getData(),normTolerance);\n\n        try {\n            v_null.unitVector();\n            fail(\"Expecting ArithmeticException\");\n        } catch (ArithmeticException ex) {\n            // expected behavior\n        } catch (Exception e) {\n            fail(\"wrong exception caught\");\n        }\n\n        OpenMapRealVector v_unitize = v1.copy();\n        v_unitize.unitize();\n        assertClose(\"compare vect\" ,v_unitVector_2.getData(),v_unitize.getData(),normTolerance);\n        try {\n            v_null.unitize();\n            fail(\"Expecting ArithmeticException\");\n        } catch (ArithmeticException ex) {\n            // expected behavior\n        } catch (Exception e) {\n            fail(\"wrong exception caught\");\n        }\n\n        RealVector v_projection = v1.projection(v2);\n        double[] result_projection = {1.662337662337662, 2.0779220779220777, 2.493506493506493};\n        assertClose(\"compare vect\", v_projection.getData(), result_projection, normTolerance);\n\n        RealVector v_projection_2 = v1.projection(v2_t);\n        double[] result_projection_2 = {1.662337662337662, 2.0779220779220777, 2.493506493506493};\n        assertClose(\"compare vect\", v_projection_2.getData(), result_projection_2, normTolerance);\n\n    }",
        "clean_err_msg": "junit.framework.AssertionFailedError: compare values   expected:<6.0> but was:<-3.0>"
      }
    },
    "buggy_files": {
      "0": "src/main/java/org/apache/commons/math/linear/ArrayRealVector.java",
      "1": "src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java"
    },
    "hunk_type": "multi_file_two_hunks",
    "hunk_mapping": {
      "0": [
        {
          "start_line": 721,
          "end_line": 721,
          "file": "src/main/java/org/apache/commons/math/linear/ArrayRealVector.java",
          "code": "<START_BUG>\n            max += Math.max(max, Math.abs(a));\n<END_BUG>"
        }
      ],
      "1": [
        {
          "start_line": 498,
          "end_line": 506,
          "file": "src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java",
          "code": "<START_BUG>\n    public double getLInfNorm() {\n        double max = 0;\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            max += iter.value();\n        }\n        return max;\n    }\n<END_BUG>"
        }
      ]
    },
    "bug_report": {
      "url": "https://issues.apache.org/jira/browse/MATH-326",
      "title": "getLInfNorm() uses wrong formula in both ArrayRealVector and OpenMapRealVector (in different ways)",
      "bug_description": "the L_infinity norm of a finite dimensional vector is just the max of the absolute value of its entries.\nThe current implementation in ArrayRealVector has a typo:\npublic\ndouble\ngetLInfNorm() {\ndouble\nmax = 0;\nfor\n(\ndouble\na : data) {\n            max +=\nMath\n.max(max,\nMath\n.abs(a));\n        }\nreturn\nmax;\n    }\nthe += should just be an =.\nThere is sadly a unit test assuring us that this is the correct behavior (effectively a regression-only test, not a test for correctness).\nWorse, the implementation in OpenMapRealVector is not even positive semi-definite:\npublic\ndouble\ngetLInfNorm() {\ndouble\nmax = 0;\n        Iterator iter = entries.iterator();\nwhile\n(iter.hasNext()) {\n            iter.advance();\n            max += iter.value();\n        }\nreturn\nmax;\n    }\nI would suggest that this method be moved up to the AbstractRealVector superclass and implemented using the sparseIterator():\npublic\ndouble\ngetLInfNorm() {\ndouble\nnorm = 0;\n    Iterator<Entry> it = sparseIterator();\n    Entry e;\nwhile\n(it.hasNext() && (e = it.next()) !=\nnull\n) {\n      norm =\nMath\n.max(norm,\nMath\n.abs(e.getValue()));\n    }\nreturn\nnorm;\n  }\nUnit tests with negative valued vectors would be helpful to check for this kind of thing in the future."
    }
  },
  "Gson_4": {
    "buggy_hunks": {
      "0": {
        "start_line": 574,
        "end_line": 576,
        "file": "gson/src/main/java/com/google/gson/stream/JsonReader.java",
        "code": "<START_BUG>\n      if (stackSize == 1) {\n        checkLenient();\n      }\n<END_BUG>"
      },
      "1": {
        "start_line": 585,
        "end_line": 587,
        "file": "gson/src/main/java/com/google/gson/stream/JsonReader.java",
        "code": "<START_BUG>\n    if (stackSize == 1) {\n      checkLenient();\n    }\n<END_BUG>"
      },
      "2": {
        "start_line": 325,
        "end_line": 325,
        "file": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
        "code": "<START_BUG>\n    beforeValue(true);\n<END_BUG>"
      },
      "3": {
        "start_line": 418,
        "end_line": 418,
        "file": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
        "code": "<START_BUG>\n    beforeValue(false);\n<END_BUG>"
      },
      "4": {
        "start_line": 435,
        "end_line": 435,
        "file": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
        "code": "<START_BUG>\n    beforeValue(false);\n<END_BUG>"
      },
      "5": {
        "start_line": 454,
        "end_line": 454,
        "file": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
        "code": "<START_BUG>\n    beforeValue(false);\n<END_BUG>"
      },
      "6": {
        "start_line": 466,
        "end_line": 466,
        "file": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
        "code": "<START_BUG>\n    beforeValue(false);\n<END_BUG>"
      },
      "7": {
        "start_line": 483,
        "end_line": 483,
        "file": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
        "code": "<START_BUG>\n    beforeValue(false);\n<END_BUG>"
      },
      "8": {
        "start_line": 495,
        "end_line": 495,
        "file": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
        "code": "<START_BUG>\n    beforeValue(false);\n<END_BUG>"
      },
      "9": {
        "start_line": 518,
        "end_line": 518,
        "file": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
        "code": "<START_BUG>\n    beforeValue(false);\n<END_BUG>"
      },
      "10": {
        "start_line": 613,
        "end_line": 613,
        "file": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
        "code": "<START_BUG>\n  private void beforeValue(boolean root) throws IOException {\n<END_BUG>"
      },
      "11": {
        "start_line": 622,
        "end_line": 625,
        "file": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
        "code": "<START_BUG>\n      if (!lenient && !root) {\n        throw new IllegalStateException(\n            \"JSON must start with an array or an object.\");\n      }\n<END_BUG>"
      }
    },
    "buggy_code": {
      "0": {
        "start_line": 465,
        "end_line": 605,
        "file": "gson/src/main/java/com/google/gson/stream/JsonReader.java",
        "code": "int doPeek() throws IOException {\n    int peekStack = stack[stackSize - 1];\n    if (peekStack == JsonScope.EMPTY_ARRAY) {\n      stack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;\n    } else if (peekStack == JsonScope.NONEMPTY_ARRAY) {\n      // Look for a comma before the next element.\n      int c = nextNonWhitespace(true);\n      switch (c) {\n      case ']':\n        return peeked = PEEKED_END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    } else if (peekStack == JsonScope.EMPTY_OBJECT || peekStack == JsonScope.NONEMPTY_OBJECT) {\n      stack[stackSize - 1] = JsonScope.DANGLING_NAME;\n      // Look for a comma before the next element.\n      if (peekStack == JsonScope.NONEMPTY_OBJECT) {\n        int c = nextNonWhitespace(true);\n        switch (c) {\n        case '}':\n          return peeked = PEEKED_END_OBJECT;\n        case ';':\n          checkLenient(); // fall-through\n        case ',':\n          break;\n        default:\n          throw syntaxError(\"Unterminated object\");\n        }\n      }\n      int c = nextNonWhitespace(true);\n      switch (c) {\n      case '\"':\n        return peeked = PEEKED_DOUBLE_QUOTED_NAME;\n      case '\\'':\n        checkLenient();\n        return peeked = PEEKED_SINGLE_QUOTED_NAME;\n      case '}':\n        if (peekStack != JsonScope.NONEMPTY_OBJECT) {\n          return peeked = PEEKED_END_OBJECT;\n        } else {\n          throw syntaxError(\"Expected name\");\n        }\n      default:\n        checkLenient();\n        pos--; // Don't consume the first character in an unquoted string.\n        if (isLiteral((char) c)) {\n          return peeked = PEEKED_UNQUOTED_NAME;\n        } else {\n          throw syntaxError(\"Expected name\");\n        }\n      }\n    } else if (peekStack == JsonScope.DANGLING_NAME) {\n      stack[stackSize - 1] = JsonScope.NONEMPTY_OBJECT;\n      // Look for a colon before the value.\n      int c = nextNonWhitespace(true);\n      switch (c) {\n      case ':':\n        break;\n      case '=':\n        checkLenient();\n        if ((pos < limit || fillBuffer(1)) && buffer[pos] == '>') {\n          pos++;\n        }\n        break;\n      default:\n        throw syntaxError(\"Expected ':'\");\n      }\n    } else if (peekStack == JsonScope.EMPTY_DOCUMENT) {\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      stack[stackSize - 1] = JsonScope.NONEMPTY_DOCUMENT;\n    } else if (peekStack == JsonScope.NONEMPTY_DOCUMENT) {\n      int c = nextNonWhitespace(false);\n      if (c == -1) {\n        return peeked = PEEKED_EOF;\n      } else {\n        checkLenient();\n        pos--;\n      }\n    } else if (peekStack == JsonScope.CLOSED) {\n      throw new IllegalStateException(\"JsonReader is closed\");\n    }\n\n    int c = nextNonWhitespace(true);\n    switch (c) {\n    case ']':\n      if (peekStack == JsonScope.EMPTY_ARRAY) {\n        return peeked = PEEKED_END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      // In lenient mode, a 0-length literal in an array means 'null'.\n      if (peekStack == JsonScope.EMPTY_ARRAY || peekStack == JsonScope.NONEMPTY_ARRAY) {\n        checkLenient();\n        pos--;\n        return peeked = PEEKED_NULL;\n      } else {\n        throw syntaxError(\"Unexpected value\");\n      }\n    case '\\'':\n      checkLenient();\n      return peeked = PEEKED_SINGLE_QUOTED;\n    case '\"':\n      if (stackSize == 1) {\n        checkLenient();\n      }\n      return peeked = PEEKED_DOUBLE_QUOTED;\n    case '[':\n      return peeked = PEEKED_BEGIN_ARRAY;\n    case '{':\n      return peeked = PEEKED_BEGIN_OBJECT;\n    default:\n      pos--; // Don't consume the first character in a literal value.\n    }\n    if (stackSize == 1) {\n      checkLenient();\n    }\n\n    int result = peekKeyword();\n    if (result != PEEKED_NONE) {\n      return result;\n    }\n\n    result = peekNumber();\n    if (result != PEEKED_NONE) {\n      return result;\n    }\n\n    if (!isLiteral(buffer[pos])) {\n      throw syntaxError(\"Expected value\");\n    }\n\n    checkLenient();\n    return peeked = PEEKED_UNQUOTED;\n  }",
        "javadoc": ""
      },
      "1": {
        "start_line": 324,
        "end_line": 329,
        "file": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
        "code": "private JsonWriter open(int empty, String openBracket) throws IOException {\n    beforeValue(true);\n    push(empty);\n    out.write(openBracket);\n    return this;\n  }",
        "javadoc": "/**\n * Inserts any necessary separators and whitespace before a literal value,\n * inline array, or inline object. Also adjusts the stack to expect either a\n * closing bracket or another element.\n */\n"
      },
      "2": {
        "start_line": 413,
        "end_line": 421,
        "file": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
        "code": "public JsonWriter value(String value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n    writeDeferredName();\n    beforeValue(false);\n    string(value);\n    return this;\n  }",
        "javadoc": ""
      },
      "3": {
        "start_line": 430,
        "end_line": 438,
        "file": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
        "code": "public JsonWriter jsonValue(String value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n    writeDeferredName();\n    beforeValue(false);\n    out.append(value);\n    return this;\n  }",
        "javadoc": "/**\n * Enters a new scope by appending any necessary whitespace and the given\n * bracket.\n */\n"
      },
      "4": {
        "start_line": 445,
        "end_line": 457,
        "file": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
        "code": "public JsonWriter nullValue() throws IOException {\n    if (deferredName != null) {\n      if (serializeNulls) {\n        writeDeferredName();\n      } else {\n        deferredName = null;\n        return this; // skip the name and the value\n      }\n    }\n    beforeValue(false);\n    out.write(\"null\");\n    return this;\n  }",
        "javadoc": "/**\n * Encodes {@code value}.\n *\n * @param value the literal string value, or null to encode a null literal.\n * @return this writer.\n */\n"
      },
      "5": {
        "start_line": 464,
        "end_line": 469,
        "file": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
        "code": "public JsonWriter value(boolean value) throws IOException {\n    writeDeferredName();\n    beforeValue(false);\n    out.write(value ? \"true\" : \"false\");\n    return this;\n  }",
        "javadoc": "/**\n * Writes {@code value} directly to the writer without quoting or\n * escaping.\n *\n * @param value the literal string value, or null to encode a null literal.\n * @return this writer.\n */\n"
      },
      "6": {
        "start_line": 478,
        "end_line": 486,
        "file": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
        "code": "public JsonWriter value(double value) throws IOException {\n    if (Double.isNaN(value) || Double.isInfinite(value)) {\n      throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n    }\n    writeDeferredName();\n    beforeValue(false);\n    out.append(Double.toString(value));\n    return this;\n  }",
        "javadoc": "/**\n * Encodes {@code null}.\n *\n * @return this writer.\n */\n"
      },
      "7": {
        "start_line": 493,
        "end_line": 498,
        "file": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
        "code": "public JsonWriter value(long value) throws IOException {\n    writeDeferredName();\n    beforeValue(false);\n    out.write(Long.toString(value));\n    return this;\n  }",
        "javadoc": "/**\n * Encodes {@code value}.\n *\n * @return this writer.\n */\n"
      },
      "8": {
        "start_line": 507,
        "end_line": 521,
        "file": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
        "code": "public JsonWriter value(Number value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n\n    writeDeferredName();\n    String string = value.toString();\n    if (!lenient\n        && (string.equals(\"-Infinity\") || string.equals(\"Infinity\") || string.equals(\"NaN\"))) {\n      throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n    }\n    beforeValue(false);\n    out.append(string);\n    return this;\n  }",
        "javadoc": "/**\n * Encodes {@code value}.\n *\n * @param value a finite value. May not be {@link Double#isNaN() NaNs} or\n *     {@link Double#isInfinite() infinities}.\n * @return this writer.\n */\n"
      },
      "9": {
        "start_line": 612,
        "end_line": 647,
        "file": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
        "code": "@SuppressWarnings(\"fallthrough\")\n  private void beforeValue(boolean root) throws IOException {\n    switch (peek()) {\n    case NONEMPTY_DOCUMENT:\n      if (!lenient) {\n        throw new IllegalStateException(\n            \"JSON must have only one top-level value.\");\n      }\n      // fall-through\n    case EMPTY_DOCUMENT: // first in document\n      if (!lenient && !root) {\n        throw new IllegalStateException(\n            \"JSON must start with an array or an object.\");\n      }\n      replaceTop(NONEMPTY_DOCUMENT);\n      break;\n\n    case EMPTY_ARRAY: // first in array\n      replaceTop(NONEMPTY_ARRAY);\n      newline();\n      break;\n\n    case NONEMPTY_ARRAY: // another in array\n      out.append(',');\n      newline();\n      break;\n\n    case DANGLING_NAME: // value for name\n      out.append(separator);\n      replaceTop(NONEMPTY_OBJECT);\n      break;\n\n    default:\n      throw new IllegalStateException(\"Nesting problem.\");\n    }\n  }",
        "javadoc": "/**\n * Encodes {@code value}.\n *\n * @return this writer.\n */\n"
      }
    },
    "delineated_bug": {
      "0": {
        "start_line": 465,
        "end_line": 605,
        "file": "gson/src/main/java/com/google/gson/stream/JsonReader.java",
        "code": "int doPeek() throws IOException {\n    int peekStack = stack[stackSize - 1];\n    if (peekStack == JsonScope.EMPTY_ARRAY) {\n      stack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;\n    } else if (peekStack == JsonScope.NONEMPTY_ARRAY) {\n      // Look for a comma before the next element.\n      int c = nextNonWhitespace(true);\n      switch (c) {\n      case ']':\n        return peeked = PEEKED_END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    } else if (peekStack == JsonScope.EMPTY_OBJECT || peekStack == JsonScope.NONEMPTY_OBJECT) {\n      stack[stackSize - 1] = JsonScope.DANGLING_NAME;\n      // Look for a comma before the next element.\n      if (peekStack == JsonScope.NONEMPTY_OBJECT) {\n        int c = nextNonWhitespace(true);\n        switch (c) {\n        case '}':\n          return peeked = PEEKED_END_OBJECT;\n        case ';':\n          checkLenient(); // fall-through\n        case ',':\n          break;\n        default:\n          throw syntaxError(\"Unterminated object\");\n        }\n      }\n      int c = nextNonWhitespace(true);\n      switch (c) {\n      case '\"':\n        return peeked = PEEKED_DOUBLE_QUOTED_NAME;\n      case '\\'':\n        checkLenient();\n        return peeked = PEEKED_SINGLE_QUOTED_NAME;\n      case '}':\n        if (peekStack != JsonScope.NONEMPTY_OBJECT) {\n          return peeked = PEEKED_END_OBJECT;\n        } else {\n          throw syntaxError(\"Expected name\");\n        }\n      default:\n        checkLenient();\n        pos--; // Don't consume the first character in an unquoted string.\n        if (isLiteral((char) c)) {\n          return peeked = PEEKED_UNQUOTED_NAME;\n        } else {\n          throw syntaxError(\"Expected name\");\n        }\n      }\n    } else if (peekStack == JsonScope.DANGLING_NAME) {\n      stack[stackSize - 1] = JsonScope.NONEMPTY_OBJECT;\n      // Look for a colon before the value.\n      int c = nextNonWhitespace(true);\n      switch (c) {\n      case ':':\n        break;\n      case '=':\n        checkLenient();\n        if ((pos < limit || fillBuffer(1)) && buffer[pos] == '>') {\n          pos++;\n        }\n        break;\n      default:\n        throw syntaxError(\"Expected ':'\");\n      }\n    } else if (peekStack == JsonScope.EMPTY_DOCUMENT) {\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      stack[stackSize - 1] = JsonScope.NONEMPTY_DOCUMENT;\n    } else if (peekStack == JsonScope.NONEMPTY_DOCUMENT) {\n      int c = nextNonWhitespace(false);\n      if (c == -1) {\n        return peeked = PEEKED_EOF;\n      } else {\n        checkLenient();\n        pos--;\n      }\n    } else if (peekStack == JsonScope.CLOSED) {\n      throw new IllegalStateException(\"JsonReader is closed\");\n    }\n\n    int c = nextNonWhitespace(true);\n    switch (c) {\n    case ']':\n      if (peekStack == JsonScope.EMPTY_ARRAY) {\n        return peeked = PEEKED_END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      // In lenient mode, a 0-length literal in an array means 'null'.\n      if (peekStack == JsonScope.EMPTY_ARRAY || peekStack == JsonScope.NONEMPTY_ARRAY) {\n        checkLenient();\n        pos--;\n        return peeked = PEEKED_NULL;\n      } else {\n        throw syntaxError(\"Unexpected value\");\n      }\n    case '\\'':\n      checkLenient();\n      return peeked = PEEKED_SINGLE_QUOTED;\n    case '\"':\n<START_BUG>\n      if (stackSize == 1) {\n        checkLenient();\n      }\n<END_BUG>\n      return peeked = PEEKED_DOUBLE_QUOTED;\n    case '[':\n      return peeked = PEEKED_BEGIN_ARRAY;\n    case '{':\n      return peeked = PEEKED_BEGIN_OBJECT;\n    default:\n      pos--; // Don't consume the first character in a literal value.\n    }\n<START_BUG>\n    if (stackSize == 1) {\n      checkLenient();\n    }\n<END_BUG>\n\n    int result = peekKeyword();\n    if (result != PEEKED_NONE) {\n      return result;\n    }\n\n    result = peekNumber();\n    if (result != PEEKED_NONE) {\n      return result;\n    }\n\n    if (!isLiteral(buffer[pos])) {\n      throw syntaxError(\"Expected value\");\n    }\n\n    checkLenient();\n    return peeked = PEEKED_UNQUOTED;\n  }",
        "javadoc": ""
      },
      "1": {
        "start_line": 324,
        "end_line": 329,
        "file": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
        "code": "private JsonWriter open(int empty, String openBracket) throws IOException {\n<START_BUG>\n    beforeValue(true);\n<END_BUG>\n    push(empty);\n    out.write(openBracket);\n    return this;\n  }",
        "javadoc": "/**\n * Inserts any necessary separators and whitespace before a literal value,\n * inline array, or inline object. Also adjusts the stack to expect either a\n * closing bracket or another element.\n */\n"
      },
      "2": {
        "start_line": 413,
        "end_line": 421,
        "file": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
        "code": "public JsonWriter value(String value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n    writeDeferredName();\n<START_BUG>\n    beforeValue(false);\n<END_BUG>\n    string(value);\n    return this;\n  }",
        "javadoc": ""
      },
      "3": {
        "start_line": 430,
        "end_line": 438,
        "file": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
        "code": "public JsonWriter jsonValue(String value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n    writeDeferredName();\n<START_BUG>\n    beforeValue(false);\n<END_BUG>\n    out.append(value);\n    return this;\n  }",
        "javadoc": "/**\n * Enters a new scope by appending any necessary whitespace and the given\n * bracket.\n */\n"
      },
      "4": {
        "start_line": 445,
        "end_line": 457,
        "file": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
        "code": "public JsonWriter nullValue() throws IOException {\n    if (deferredName != null) {\n      if (serializeNulls) {\n        writeDeferredName();\n      } else {\n        deferredName = null;\n        return this; // skip the name and the value\n      }\n    }\n<START_BUG>\n    beforeValue(false);\n<END_BUG>\n    out.write(\"null\");\n    return this;\n  }",
        "javadoc": "/**\n * Encodes {@code value}.\n *\n * @param value the literal string value, or null to encode a null literal.\n * @return this writer.\n */\n"
      },
      "5": {
        "start_line": 464,
        "end_line": 469,
        "file": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
        "code": "public JsonWriter value(boolean value) throws IOException {\n    writeDeferredName();\n<START_BUG>\n    beforeValue(false);\n<END_BUG>\n    out.write(value ? \"true\" : \"false\");\n    return this;\n  }",
        "javadoc": "/**\n * Writes {@code value} directly to the writer without quoting or\n * escaping.\n *\n * @param value the literal string value, or null to encode a null literal.\n * @return this writer.\n */\n"
      },
      "6": {
        "start_line": 478,
        "end_line": 486,
        "file": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
        "code": "public JsonWriter value(double value) throws IOException {\n    if (Double.isNaN(value) || Double.isInfinite(value)) {\n      throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n    }\n    writeDeferredName();\n<START_BUG>\n    beforeValue(false);\n<END_BUG>\n    out.append(Double.toString(value));\n    return this;\n  }",
        "javadoc": "/**\n * Encodes {@code null}.\n *\n * @return this writer.\n */\n"
      },
      "7": {
        "start_line": 493,
        "end_line": 498,
        "file": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
        "code": "public JsonWriter value(long value) throws IOException {\n    writeDeferredName();\n<START_BUG>\n    beforeValue(false);\n<END_BUG>\n    out.write(Long.toString(value));\n    return this;\n  }",
        "javadoc": "/**\n * Encodes {@code value}.\n *\n * @return this writer.\n */\n"
      },
      "8": {
        "start_line": 507,
        "end_line": 521,
        "file": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
        "code": "public JsonWriter value(Number value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n\n    writeDeferredName();\n    String string = value.toString();\n    if (!lenient\n        && (string.equals(\"-Infinity\") || string.equals(\"Infinity\") || string.equals(\"NaN\"))) {\n      throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n    }\n<START_BUG>\n    beforeValue(false);\n<END_BUG>\n    out.append(string);\n    return this;\n  }",
        "javadoc": "/**\n * Encodes {@code value}.\n *\n * @param value a finite value. May not be {@link Double#isNaN() NaNs} or\n *     {@link Double#isInfinite() infinities}.\n * @return this writer.\n */\n"
      },
      "9": {
        "start_line": 612,
        "end_line": 647,
        "file": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
        "code": "@SuppressWarnings(\"fallthrough\")\n<START_BUG>\n  private void beforeValue(boolean root) throws IOException {\n<END_BUG>\n    switch (peek()) {\n    case NONEMPTY_DOCUMENT:\n      if (!lenient) {\n        throw new IllegalStateException(\n            \"JSON must have only one top-level value.\");\n      }\n      // fall-through\n    case EMPTY_DOCUMENT: // first in document\n<START_BUG>\n      if (!lenient && !root) {\n        throw new IllegalStateException(\n            \"JSON must start with an array or an object.\");\n      }\n<END_BUG>\n      replaceTop(NONEMPTY_DOCUMENT);\n      break;\n\n    case EMPTY_ARRAY: // first in array\n      replaceTop(NONEMPTY_ARRAY);\n      newline();\n      break;\n\n    case NONEMPTY_ARRAY: // another in array\n      out.append(',');\n      newline();\n      break;\n\n    case DANGLING_NAME: // value for name\n      out.append(separator);\n      replaceTop(NONEMPTY_OBJECT);\n      break;\n\n    default:\n      throw new IllegalStateException(\"Nesting problem.\");\n    }\n  }",
        "javadoc": "/**\n * Encodes {@code value}.\n *\n * @return this writer.\n */\n"
      }
    },
    "contained_scope": "method",
    "bug_count": 10,
    "triggered_tests": {
      "0": {
        "test_path": "com.google.gson.stream.JsonReaderTest",
        "test_method": "testTopLevelValueTypeWithSkipValue",
        "test_code": "testTopLevelValueTypeWithSkipValue() throws IOException {\n    JsonReader reader = new JsonReader(reader(\"true\"));\n    reader.skipValue();\n    assertEquals(JsonToken.END_DOCUMENT, reader.peek());\n  }",
        "clean_err_msg": "com.google.gson.stream.MalformedJsonException: Use JsonReader.setLenient(true) to accept malformed JSON at line 1 column 1 path $"
      },
      "1": {
        "test_path": "com.google.gson.stream.JsonReaderTest",
        "test_method": "testTopLevelValueTypes",
        "test_code": "testTopLevelValueTypes() throws IOException {\n    JsonReader reader1 = new JsonReader(reader(\"true\"));\n    assertTrue(reader1.nextBoolean());\n    assertEquals(JsonToken.END_DOCUMENT, reader1.peek());\n\n    JsonReader reader2 = new JsonReader(reader(\"false\"));\n    assertFalse(reader2.nextBoolean());\n    assertEquals(JsonToken.END_DOCUMENT, reader2.peek());\n\n    JsonReader reader3 = new JsonReader(reader(\"null\"));\n    assertEquals(JsonToken.NULL, reader3.peek());\n    reader3.nextNull();\n    assertEquals(JsonToken.END_DOCUMENT, reader3.peek());\n\n    JsonReader reader4 = new JsonReader(reader(\"123\"));\n    assertEquals(123, reader4.nextInt());\n    assertEquals(JsonToken.END_DOCUMENT, reader4.peek());\n\n    JsonReader reader5 = new JsonReader(reader(\"123.4\"));\n    assertEquals(123.4, reader5.nextDouble());\n    assertEquals(JsonToken.END_DOCUMENT, reader5.peek());\n\n    JsonReader reader6 = new JsonReader(reader(\"\\\"a\\\"\"));\n    assertEquals(\"a\", reader6.nextString());\n    assertEquals(JsonToken.END_DOCUMENT, reader6.peek());\n  }",
        "clean_err_msg": "com.google.gson.stream.MalformedJsonException: Use JsonReader.setLenient(true) to accept malformed JSON at line 1 column 1 path $"
      },
      "2": {
        "test_path": "com.google.gson.stream.JsonWriterTest",
        "test_method": "testTopLevelValueTypes",
        "test_code": "testTopLevelValueTypes() throws IOException {\n    StringWriter string1 = new StringWriter();\n    JsonWriter writer1 = new JsonWriter(string1);\n    writer1.value(true);\n    writer1.close();\n    assertEquals(\"true\", string1.toString());\n\n    StringWriter string2 = new StringWriter();\n    JsonWriter writer2 = new JsonWriter(string2);\n    writer2.nullValue();\n    writer2.close();\n    assertEquals(\"null\", string2.toString());\n\n    StringWriter string3 = new StringWriter();\n    JsonWriter writer3 = new JsonWriter(string3);\n    writer3.value(123);\n    writer3.close();\n    assertEquals(\"123\", string3.toString());\n\n    StringWriter string4 = new StringWriter();\n    JsonWriter writer4 = new JsonWriter(string4);\n    writer4.value(123.4);\n    writer4.close();\n    assertEquals(\"123.4\", string4.toString());\n\n    StringWriter string5 = new StringWriter();\n    JsonWriter writert = new JsonWriter(string5);\n    writert.value(\"a\");\n    writert.close();\n    assertEquals(\"\\\"a\\\"\", string5.toString());\n  }",
        "clean_err_msg": "java.lang.IllegalStateException: JSON must start with an array or an object."
      }
    },
    "buggy_files": {
      "0": "gson/src/main/java/com/google/gson/stream/JsonReader.java",
      "1": "gson/src/main/java/com/google/gson/stream/JsonWriter.java"
    },
    "hunk_type": "multi_file_four_or_more_hunks",
    "hunk_mapping": {
      "0": [
        {
          "start_line": 574,
          "end_line": 576,
          "file": "gson/src/main/java/com/google/gson/stream/JsonReader.java",
          "code": "<START_BUG>\n      if (stackSize == 1) {\n        checkLenient();\n      }\n<END_BUG>"
        },
        {
          "start_line": 585,
          "end_line": 587,
          "file": "gson/src/main/java/com/google/gson/stream/JsonReader.java",
          "code": "<START_BUG>\n    if (stackSize == 1) {\n      checkLenient();\n    }\n<END_BUG>"
        }
      ],
      "1": [
        {
          "start_line": 325,
          "end_line": 325,
          "file": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
          "code": "<START_BUG>\n    beforeValue(true);\n<END_BUG>"
        }
      ],
      "2": [
        {
          "start_line": 418,
          "end_line": 418,
          "file": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
          "code": "<START_BUG>\n    beforeValue(false);\n<END_BUG>"
        }
      ],
      "3": [
        {
          "start_line": 435,
          "end_line": 435,
          "file": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
          "code": "<START_BUG>\n    beforeValue(false);\n<END_BUG>"
        }
      ],
      "4": [
        {
          "start_line": 454,
          "end_line": 454,
          "file": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
          "code": "<START_BUG>\n    beforeValue(false);\n<END_BUG>"
        }
      ],
      "5": [
        {
          "start_line": 466,
          "end_line": 466,
          "file": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
          "code": "<START_BUG>\n    beforeValue(false);\n<END_BUG>"
        }
      ],
      "6": [
        {
          "start_line": 483,
          "end_line": 483,
          "file": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
          "code": "<START_BUG>\n    beforeValue(false);\n<END_BUG>"
        }
      ],
      "7": [
        {
          "start_line": 495,
          "end_line": 495,
          "file": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
          "code": "<START_BUG>\n    beforeValue(false);\n<END_BUG>"
        }
      ],
      "8": [
        {
          "start_line": 518,
          "end_line": 518,
          "file": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
          "code": "<START_BUG>\n    beforeValue(false);\n<END_BUG>"
        }
      ],
      "9": [
        {
          "start_line": 613,
          "end_line": 613,
          "file": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
          "code": "<START_BUG>\n  private void beforeValue(boolean root) throws IOException {\n<END_BUG>"
        },
        {
          "start_line": 622,
          "end_line": 625,
          "file": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
          "code": "<START_BUG>\n      if (!lenient && !root) {\n        throw new IllegalStateException(\n            \"JSON must start with an array or an object.\");\n      }\n<END_BUG>"
        }
      ]
    },
    "bug_report": {
      "url": "https://github.com/google/gson/pull/773",
      "title": "Update reader and writer for RFC 7159.",
      "bug_description": "This allows for top-level value types without the requirement of leniency."
    }
  },
  "Closure_143": {
    "buggy_hunks": {
      "0": {
        "start_line": 871,
        "end_line": 871,
        "file": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "code": "<START_BUG>\n            )) {\n<END_BUG>"
      },
      "1": {
        "start_line": 91,
        "end_line": 91,
        "file": "src/com/google/javascript/jscomp/RemoveConstantExpressions.java",
        "code": "<START_BUG>\n      ) {\n<END_BUG>"
      }
    },
    "buggy_code": {
      "0": {
        "start_line": 847,
        "end_line": 895,
        "file": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "code": "@VisibleForTesting\n  static void createDefineReplacements(List<String> definitions,\n      CompilerOptions options) {\n    // Parse the definitions\n    for (String override : definitions) {\n      String[] assignment = override.split(\"=\", 2);\n      String defName = assignment[0];\n\n      if (defName.length() > 0) {\n        if (assignment.length == 1) {\n          options.setDefineToBooleanLiteral(defName, true);\n          continue;\n        } else {\n          String defValue = assignment[1];\n\n          if (defValue.equals(\"true\")) {\n            options.setDefineToBooleanLiteral(defName, true);\n            continue;\n          } else if (defValue.equals(\"false\")) {\n            options.setDefineToBooleanLiteral(defName, false);\n            continue;\n          } else if (defValue.length() > 1\n              && ((defValue.charAt(0) == '\\'' &&\n                  defValue.charAt(defValue.length() - 1) == '\\'')\n            )) {\n            // If the value starts and ends with a single quote,\n            // we assume that it's a string.\n            String maybeStringVal =\n                defValue.substring(1, defValue.length() - 1);\n            if (maybeStringVal.indexOf(defValue.charAt(0)) == -1) {\n              options.setDefineToStringLiteral(defName, maybeStringVal);\n              continue;\n            }\n          } else {\n            try {\n              options.setDefineToDoubleLiteral(defName,\n                  Double.parseDouble(defValue));\n              continue;\n            } catch (NumberFormatException e) {\n              // do nothing, it will be caught at the end\n            }\n          }\n        }\n      }\n\n      throw new RuntimeException(\n          \"--define flag syntax invalid: \" + override);\n    }\n  }",
        "javadoc": "/**\n * Create a map of constant names to constant values from a textual\n * description of the map.\n *\n * @param definitions A list of overriding definitions for defines in\n *     the form <name>[=<val>], where <val> is a number, boolean, or\n *     single-quoted string without single quotes.\n */\n"
      },
      "1": {
        "start_line": 84,
        "end_line": 94,
        "file": "src/com/google/javascript/jscomp/RemoveConstantExpressions.java",
        "code": "private void trySimplify(Node parent, Node node) {\n      if (node.getType() != Token.EXPR_RESULT) {\n        return;\n      }\n\n      Node exprBody = node.getFirstChild();\n      if (!NodeUtil.nodeTypeMayHaveSideEffects(exprBody)\n      ) {\n        changeProxy.replaceWith(parent, node, getSideEffectNodes(exprBody));\n      }\n    }",
        "javadoc": "/**\n * Attempts to replace the input node with a simpler but functionally\n * equivalent set of nodes.\n */\n"
      }
    },
    "delineated_bug": {
      "0": {
        "start_line": 847,
        "end_line": 895,
        "file": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "code": "@VisibleForTesting\n  static void createDefineReplacements(List<String> definitions,\n      CompilerOptions options) {\n    // Parse the definitions\n    for (String override : definitions) {\n      String[] assignment = override.split(\"=\", 2);\n      String defName = assignment[0];\n\n      if (defName.length() > 0) {\n        if (assignment.length == 1) {\n          options.setDefineToBooleanLiteral(defName, true);\n          continue;\n        } else {\n          String defValue = assignment[1];\n\n          if (defValue.equals(\"true\")) {\n            options.setDefineToBooleanLiteral(defName, true);\n            continue;\n          } else if (defValue.equals(\"false\")) {\n            options.setDefineToBooleanLiteral(defName, false);\n            continue;\n          } else if (defValue.length() > 1\n              && ((defValue.charAt(0) == '\\'' &&\n                  defValue.charAt(defValue.length() - 1) == '\\'')\n<START_BUG>\n            )) {\n<END_BUG>\n            // If the value starts and ends with a single quote,\n            // we assume that it's a string.\n            String maybeStringVal =\n                defValue.substring(1, defValue.length() - 1);\n            if (maybeStringVal.indexOf(defValue.charAt(0)) == -1) {\n              options.setDefineToStringLiteral(defName, maybeStringVal);\n              continue;\n            }\n          } else {\n            try {\n              options.setDefineToDoubleLiteral(defName,\n                  Double.parseDouble(defValue));\n              continue;\n            } catch (NumberFormatException e) {\n              // do nothing, it will be caught at the end\n            }\n          }\n        }\n      }\n\n      throw new RuntimeException(\n          \"--define flag syntax invalid: \" + override);\n    }\n  }",
        "javadoc": "/**\n * Create a map of constant names to constant values from a textual\n * description of the map.\n *\n * @param definitions A list of overriding definitions for defines in\n *     the form <name>[=<val>], where <val> is a number, boolean, or\n *     single-quoted string without single quotes.\n */\n"
      },
      "1": {
        "start_line": 84,
        "end_line": 94,
        "file": "src/com/google/javascript/jscomp/RemoveConstantExpressions.java",
        "code": "private void trySimplify(Node parent, Node node) {\n      if (node.getType() != Token.EXPR_RESULT) {\n        return;\n      }\n\n      Node exprBody = node.getFirstChild();\n      if (!NodeUtil.nodeTypeMayHaveSideEffects(exprBody)\n<START_BUG>\n      ) {\n<END_BUG>\n        changeProxy.replaceWith(parent, node, getSideEffectNodes(exprBody));\n      }\n    }",
        "javadoc": "/**\n * Attempts to replace the input node with a simpler but functionally\n * equivalent set of nodes.\n */\n"
      }
    },
    "contained_scope": "method",
    "bug_count": 2,
    "triggered_tests": {
      "0": {
        "test_path": "com.google.javascript.jscomp.CommandLineRunnerTest",
        "test_method": "testDefineFlag3",
        "test_code": "testDefineFlag3() {\n    args.add(\"--define=FOO=\\\"x'\\\"\");\n    test(\"/** @define {string} */ var FOO = \\\"a\\\";\",\n         \"var FOO = \\\"x'\\\";\");\n  }",
        "clean_err_msg": "java.lang.RuntimeException: --define flag syntax invalid: FOO=\"x'\""
      },
      "1": {
        "test_path": "com.google.javascript.jscomp.RemoveConstantExpressionsTest",
        "test_method": "testCall1",
        "test_code": "testCall1() {\n    test(\"Math.sin(0);\", \"\");\n  }",
        "clean_err_msg": "junit.framework.AssertionFailedError: "
      },
      "2": {
        "test_path": "com.google.javascript.jscomp.RemoveConstantExpressionsTest",
        "test_method": "testNew1",
        "test_code": "testNew1() {\n    test(\"new Date;\", \"\");\n  }",
        "clean_err_msg": "junit.framework.AssertionFailedError: "
      }
    },
    "buggy_files": {
      "0": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
      "1": "src/com/google/javascript/jscomp/RemoveConstantExpressions.java"
    },
    "hunk_type": "multi_file_two_hunks",
    "hunk_mapping": {
      "0": [
        {
          "start_line": 871,
          "end_line": 871,
          "file": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
          "code": "<START_BUG>\n            )) {\n<END_BUG>"
        }
      ],
      "1": [
        {
          "start_line": 91,
          "end_line": 91,
          "file": "src/com/google/javascript/jscomp/RemoveConstantExpressions.java",
          "code": "<START_BUG>\n      ) {\n<END_BUG>"
        }
      ]
    },
    "bug_report": {
      "url": "https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-139.json",
      "bug_description": "@define does not support strings",
      "title": ""
    }
  },
  "Jsoup_21": {
    "buggy_hunks": {
      "0": {
        "start_line": 64,
        "end_line": 63,
        "file": "src/main/java/org/jsoup/select/CombiningEvaluator.java",
        "code": "<START_BUG>\n<END_BUG>"
      },
      "1": {
        "start_line": 58,
        "end_line": 66,
        "file": "src/main/java/org/jsoup/select/QueryParser.java",
        "code": "<START_BUG>\n            if (tq.matchChomp(\",\")) {\n                CombiningEvaluator.Or or = new CombiningEvaluator.Or(evals);\n                evals.clear();\n                evals.add(or);\n                while (!tq.isEmpty()) {\n                    String subQuery = tq.chompTo(\",\");\n                    or.add(parse(subQuery));\n                }\n            } else if (tq.matchesAny(combinators)) {\n<END_BUG>"
      },
      "2": {
        "start_line": 101,
        "end_line": 100,
        "file": "src/main/java/org/jsoup/select/QueryParser.java",
        "code": "<START_BUG>\n<END_BUG>"
      }
    },
    "buggy_code": {
      "0": {
        "start_line": 64,
        "end_line": 64,
        "file": "src/main/java/org/jsoup/select/CombiningEvaluator.java",
        "code": "",
        "javadoc": "/**\n * Parse the query\n * @return Evaluator\n */\n"
      },
      "1": {
        "start_line": 44,
        "end_line": 79,
        "file": "src/main/java/org/jsoup/select/QueryParser.java",
        "code": "Evaluator parse() {\n        tq.consumeWhitespace();\n\n        if (tq.matchesAny(combinators)) { // if starts with a combinator, use root as elements\n            evals.add(new StructuralEvaluator.Root());\n            combinator(tq.consume());\n        } else {\n            findElements();\n        }\n\n        while (!tq.isEmpty()) {\n            // hierarchy and extras\n            boolean seenWhite = tq.consumeWhitespace();\n\n            if (tq.matchChomp(\",\")) {\n                CombiningEvaluator.Or or = new CombiningEvaluator.Or(evals);\n                evals.clear();\n                evals.add(or);\n                while (!tq.isEmpty()) {\n                    String subQuery = tq.chompTo(\",\");\n                    or.add(parse(subQuery));\n                }\n            } else if (tq.matchesAny(combinators)) {\n                combinator(tq.consume());\n            } else if (seenWhite) {\n                combinator(' ');\n            } else { // E.class, E#id, E[attr] etc. AND\n                findElements(); // take next el, #. etc off queue\n            }\n        }\n\n        if (evals.size() == 1)\n            return evals.get(0);\n\n        return new CombiningEvaluator.And(evals);\n    }",
        "javadoc": ""
      },
      "2": {
        "start_line": 81,
        "end_line": 103,
        "file": "src/main/java/org/jsoup/select/QueryParser.java",
        "code": "private void combinator(char combinator) {\n        tq.consumeWhitespace();\n        String subQuery = consumeSubQuery(); // support multi > childs\n        Evaluator e;\n\n        if (evals.size() == 1)\n            e = evals.get(0);\n        else\n            e = new CombiningEvaluator.And(evals);\n        evals.clear();\n        Evaluator f = parse(subQuery);\n\n        if (combinator == '>')\n            evals.add(new CombiningEvaluator.And(f, new StructuralEvaluator.ImmediateParent(e)));\n        else if (combinator == ' ')\n            evals.add(new CombiningEvaluator.And(f, new StructuralEvaluator.Parent(e)));\n        else if (combinator == '+')\n            evals.add(new CombiningEvaluator.And(f, new StructuralEvaluator.ImmediatePreviousSibling(e)));\n        else if (combinator == '~')\n            evals.add(new CombiningEvaluator.And(f, new StructuralEvaluator.PreviousSibling(e)));\n        else\n            throw new Selector.SelectorParseException(\"Unknown combinator: \" + combinator);\n    }",
        "javadoc": ""
      }
    },
    "delineated_bug": {
      "0": {
        "start_line": 64,
        "end_line": 64,
        "file": "src/main/java/org/jsoup/select/CombiningEvaluator.java",
        "code": "<START_BUG>\n\n<END_BUG>",
        "javadoc": "/**\n * Parse the query\n * @return Evaluator\n */\n"
      },
      "1": {
        "start_line": 44,
        "end_line": 79,
        "file": "src/main/java/org/jsoup/select/QueryParser.java",
        "code": "Evaluator parse() {\n        tq.consumeWhitespace();\n\n        if (tq.matchesAny(combinators)) { // if starts with a combinator, use root as elements\n            evals.add(new StructuralEvaluator.Root());\n            combinator(tq.consume());\n        } else {\n            findElements();\n        }\n\n        while (!tq.isEmpty()) {\n            // hierarchy and extras\n            boolean seenWhite = tq.consumeWhitespace();\n\n<START_BUG>\n            if (tq.matchChomp(\",\")) {\n                CombiningEvaluator.Or or = new CombiningEvaluator.Or(evals);\n                evals.clear();\n                evals.add(or);\n                while (!tq.isEmpty()) {\n                    String subQuery = tq.chompTo(\",\");\n                    or.add(parse(subQuery));\n                }\n            } else if (tq.matchesAny(combinators)) {\n<END_BUG>\n                combinator(tq.consume());\n            } else if (seenWhite) {\n                combinator(' ');\n            } else { // E.class, E#id, E[attr] etc. AND\n                findElements(); // take next el, #. etc off queue\n            }\n        }\n\n        if (evals.size() == 1)\n            return evals.get(0);\n\n        return new CombiningEvaluator.And(evals);\n    }",
        "javadoc": ""
      },
      "2": {
        "start_line": 81,
        "end_line": 103,
        "file": "src/main/java/org/jsoup/select/QueryParser.java",
        "code": "private void combinator(char combinator) {\n        tq.consumeWhitespace();\n        String subQuery = consumeSubQuery(); // support multi > childs\n        Evaluator e;\n\n        if (evals.size() == 1)\n            e = evals.get(0);\n        else\n            e = new CombiningEvaluator.And(evals);\n        evals.clear();\n        Evaluator f = parse(subQuery);\n\n        if (combinator == '>')\n            evals.add(new CombiningEvaluator.And(f, new StructuralEvaluator.ImmediateParent(e)));\n        else if (combinator == ' ')\n            evals.add(new CombiningEvaluator.And(f, new StructuralEvaluator.Parent(e)));\n        else if (combinator == '+')\n            evals.add(new CombiningEvaluator.And(f, new StructuralEvaluator.ImmediatePreviousSibling(e)));\n        else if (combinator == '~')\n            evals.add(new CombiningEvaluator.And(f, new StructuralEvaluator.PreviousSibling(e)));\n<END_BUG>\n<START_BUG>\n        else\n            throw new Selector.SelectorParseException(\"Unknown combinator: \" + combinator);\n    }",
        "javadoc": ""
      }
    },
    "contained_scope": "file",
    "bug_count": 3,
    "triggered_tests": {
      "0": {
        "test_path": "org.jsoup.select.SelectorTest",
        "test_method": "handlesCommasInSelector",
        "test_code": "handlesCommasInSelector() {\n        Document doc = Jsoup.parse(\"<p name='1,2'>One</p><div>Two</div><ol><li>123</li><li>Text</li></ol>\");\n\n        Elements ps = doc.select(\"[name=1,2]\");\n        assertEquals(1, ps.size());\n\n        Elements containers = doc.select(\"div, li:matches([0-9,]+)\");\n        assertEquals(2, containers.size());\n        assertEquals(\"div\", containers.get(0).tagName());\n        assertEquals(\"li\", containers.get(1).tagName());\n        assertEquals(\"123\", containers.get(1).text());\n    }",
        "clean_err_msg": "java.util.regex.PatternSyntaxException: Unclosed character class near index 3"
      },
      "1": {
        "test_path": "org.jsoup.select.SelectorTest",
        "test_method": "mixCombinatorGroup",
        "test_code": "mixCombinatorGroup() {\n        String h = \"<div class=foo><ol><li>One<li>Two<li>Three</ol></div>\";\n        Document doc = Jsoup.parse(h);\n        Elements els = doc.select(\".foo > ol, ol > li + li\");\n\n        assertEquals(2, els.size());\n        assertEquals(\"li\", els.get(0).tagName());\n        assertEquals(\"Three\", els.get(1).text());\n    }",
        "clean_err_msg": "junit.framework.AssertionFailedError: expected:<2> but was:<3>"
      }
    },
    "buggy_files": {
      "0": "src/main/java/org/jsoup/select/CombiningEvaluator.java",
      "1": "src/main/java/org/jsoup/select/QueryParser.java"
    },
    "hunk_type": "multi_file_three_hunks",
    "hunk_mapping": {
      "0": [
        {
          "start_line": 64,
          "end_line": 63,
          "file": "src/main/java/org/jsoup/select/CombiningEvaluator.java",
          "code": "<START_BUG>\n<END_BUG>"
        }
      ],
      "1": [
        {
          "start_line": 58,
          "end_line": 66,
          "file": "src/main/java/org/jsoup/select/QueryParser.java",
          "code": "<START_BUG>\n            if (tq.matchChomp(\",\")) {\n                CombiningEvaluator.Or or = new CombiningEvaluator.Or(evals);\n                evals.clear();\n                evals.add(or);\n                while (!tq.isEmpty()) {\n                    String subQuery = tq.chompTo(\",\");\n                    or.add(parse(subQuery));\n                }\n            } else if (tq.matchesAny(combinators)) {\n<END_BUG>"
        }
      ],
      "2": [
        {
          "start_line": 101,
          "end_line": 100,
          "file": "src/main/java/org/jsoup/select/QueryParser.java",
          "code": "<START_BUG>\n<END_BUG>"
        }
      ]
    },
    "bug_report": {
      "url": "https://github.com/jhy/jsoup/issues/179",
      "title": "Selector parsing gets confused by commata in regexes",
      "bug_description": "The selector `div, li:matches([0-9,]+)` causes a java.util.regex.PatternSyntaxException because  [QueryParser (line 63)](https://github.com/jhy/jsoup/blob/master/src/main/java/org/jsoup/select/QueryParser.java#L63) thinks that the comma inside the regex is a combinator and thus extracts `, li:matches([0-9` as the second alternative.\n\nInstead of scanning ahead with `chompTo(\",\"), the parser needs to parse its way through the alternative until it reaches a comma or the end of a string. That way, commata in regular expressions will be correctly interpreted as part of the regex.\n\nNote that there may be many more variations of this bug in the parser. Wherever a construct allows embedding an arbitrary string one should expect this problem. `[attr=a,b]` for example is likely to cause the same issue. In a way, any invocation of chompTo() needs to examined."
    }
  },
  "Jsoup_65": {
    "buggy_hunks": {
      "0": {
        "start_line": 360,
        "end_line": 364,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "code": "<START_BUG>\n        clearStackToContext(\"tbody\", \"tfoot\", \"thead\");\n    }\n\n    void clearStackToTableRowContext() {\n        clearStackToContext(\"tr\");\n<END_BUG>"
      },
      "1": {
        "start_line": 1036,
        "end_line": 1036,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java",
        "code": "<START_BUG>\n                    if (name.equals(\"tr\")) {\n<END_BUG>"
      },
      "2": {
        "start_line": 1096,
        "end_line": 1096,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java",
        "code": "<START_BUG>\n                if (StringUtil.in(name, \"th\", \"td\")) {\n<END_BUG>"
      }
    },
    "buggy_code": {
      "0": {
        "start_line": 359,
        "end_line": 365,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "code": "void clearStackToTableBodyContext() {\n        clearStackToContext(\"tbody\", \"tfoot\", \"thead\");\n    }\n\n    void clearStackToTableRowContext() {\n        clearStackToContext(\"tr\");\n    }",
        "javadoc": ""
      },
      "1": {
        "start_line": 1031,
        "end_line": 1073,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java",
        "code": "boolean process(Token t, HtmlTreeBuilder tb) {\n            switch (t.type) {\n                case StartTag:\n                    Token.StartTag startTag = t.asStartTag();\n                    String name = startTag.normalName();\n                    if (name.equals(\"tr\")) {\n                        tb.clearStackToTableBodyContext();\n                        tb.insert(startTag);\n                        tb.transition(InRow);\n                    } else if (StringUtil.in(name, \"th\", \"td\")) {\n                        tb.error(this);\n                        tb.processStartTag(\"tr\");\n                        return tb.process(startTag);\n                    } else if (StringUtil.in(name, \"caption\", \"col\", \"colgroup\", \"tbody\", \"tfoot\", \"thead\")) {\n                        return exitTableBody(t, tb);\n                    } else\n                        return anythingElse(t, tb);\n                    break;\n                case EndTag:\n                    Token.EndTag endTag = t.asEndTag();\n                    name = endTag.normalName();\n                    if (StringUtil.in(name, \"tbody\", \"tfoot\", \"thead\")) {\n                        if (!tb.inTableScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.clearStackToTableBodyContext();\n                            tb.pop();\n                            tb.transition(InTable);\n                        }\n                    } else if (name.equals(\"table\")) {\n                        return exitTableBody(t, tb);\n                    } else if (StringUtil.in(name, \"body\", \"caption\", \"col\", \"colgroup\", \"html\", \"td\", \"th\", \"tr\")) {\n                        tb.error(this);\n                        return false;\n                    } else\n                        return anythingElse(t, tb);\n                    break;\n                default:\n                    return anythingElse(t, tb);\n            }\n            return true;\n        }",
        "javadoc": ""
      },
      "2": {
        "start_line": 1091,
        "end_line": 1137,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java",
        "code": "boolean process(Token t, HtmlTreeBuilder tb) {\n            if (t.isStartTag()) {\n                Token.StartTag startTag = t.asStartTag();\n                String name = startTag.normalName();\n\n                if (StringUtil.in(name, \"th\", \"td\")) {\n                    tb.clearStackToTableRowContext();\n                    tb.insert(startTag);\n                    tb.transition(InCell);\n                    tb.insertMarkerToFormattingElements();\n                } else if (StringUtil.in(name, \"caption\", \"col\", \"colgroup\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n                    return handleMissingTr(t, tb);\n                } else {\n                    return anythingElse(t, tb);\n                }\n            } else if (t.isEndTag()) {\n                Token.EndTag endTag = t.asEndTag();\n                String name = endTag.normalName();\n\n                if (name.equals(\"tr\")) {\n                    if (!tb.inTableScope(name)) {\n                        tb.error(this); // frag\n                        return false;\n                    }\n                    tb.clearStackToTableRowContext();\n                    tb.pop(); // tr\n                    tb.transition(InTableBody);\n                } else if (name.equals(\"table\")) {\n                    return handleMissingTr(t, tb);\n                } else if (StringUtil.in(name, \"tbody\", \"tfoot\", \"thead\")) {\n                    if (!tb.inTableScope(name)) {\n                        tb.error(this);\n                        return false;\n                    }\n                    tb.processEndTag(\"tr\");\n                    return tb.process(t);\n                } else if (StringUtil.in(name, \"body\", \"caption\", \"col\", \"colgroup\", \"html\", \"td\", \"th\")) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    return anythingElse(t, tb);\n                }\n            } else {\n                return anythingElse(t, tb);\n            }\n            return true;\n        }",
        "javadoc": ""
      }
    },
    "delineated_bug": {
      "0": {
        "start_line": 359,
        "end_line": 365,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "code": "void clearStackToTableBodyContext() {\n<START_BUG>\n        clearStackToContext(\"tbody\", \"tfoot\", \"thead\");\n    }\n\n    void clearStackToTableRowContext() {\n        clearStackToContext(\"tr\");\n<END_BUG>\n    }",
        "javadoc": ""
      },
      "1": {
        "start_line": 1031,
        "end_line": 1073,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java",
        "code": "boolean process(Token t, HtmlTreeBuilder tb) {\n            switch (t.type) {\n                case StartTag:\n                    Token.StartTag startTag = t.asStartTag();\n                    String name = startTag.normalName();\n<START_BUG>\n                    if (name.equals(\"tr\")) {\n<END_BUG>\n                        tb.clearStackToTableBodyContext();\n                        tb.insert(startTag);\n                        tb.transition(InRow);\n                    } else if (StringUtil.in(name, \"th\", \"td\")) {\n                        tb.error(this);\n                        tb.processStartTag(\"tr\");\n                        return tb.process(startTag);\n                    } else if (StringUtil.in(name, \"caption\", \"col\", \"colgroup\", \"tbody\", \"tfoot\", \"thead\")) {\n                        return exitTableBody(t, tb);\n                    } else\n                        return anythingElse(t, tb);\n                    break;\n                case EndTag:\n                    Token.EndTag endTag = t.asEndTag();\n                    name = endTag.normalName();\n                    if (StringUtil.in(name, \"tbody\", \"tfoot\", \"thead\")) {\n                        if (!tb.inTableScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.clearStackToTableBodyContext();\n                            tb.pop();\n                            tb.transition(InTable);\n                        }\n                    } else if (name.equals(\"table\")) {\n                        return exitTableBody(t, tb);\n                    } else if (StringUtil.in(name, \"body\", \"caption\", \"col\", \"colgroup\", \"html\", \"td\", \"th\", \"tr\")) {\n                        tb.error(this);\n                        return false;\n                    } else\n                        return anythingElse(t, tb);\n                    break;\n                default:\n                    return anythingElse(t, tb);\n            }\n            return true;\n        }",
        "javadoc": ""
      },
      "2": {
        "start_line": 1091,
        "end_line": 1137,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java",
        "code": "boolean process(Token t, HtmlTreeBuilder tb) {\n            if (t.isStartTag()) {\n                Token.StartTag startTag = t.asStartTag();\n                String name = startTag.normalName();\n\n<START_BUG>\n                if (StringUtil.in(name, \"th\", \"td\")) {\n<END_BUG>\n                    tb.clearStackToTableRowContext();\n                    tb.insert(startTag);\n                    tb.transition(InCell);\n                    tb.insertMarkerToFormattingElements();\n                } else if (StringUtil.in(name, \"caption\", \"col\", \"colgroup\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n                    return handleMissingTr(t, tb);\n                } else {\n                    return anythingElse(t, tb);\n                }\n            } else if (t.isEndTag()) {\n                Token.EndTag endTag = t.asEndTag();\n                String name = endTag.normalName();\n\n                if (name.equals(\"tr\")) {\n                    if (!tb.inTableScope(name)) {\n                        tb.error(this); // frag\n                        return false;\n                    }\n                    tb.clearStackToTableRowContext();\n                    tb.pop(); // tr\n                    tb.transition(InTableBody);\n                } else if (name.equals(\"table\")) {\n                    return handleMissingTr(t, tb);\n                } else if (StringUtil.in(name, \"tbody\", \"tfoot\", \"thead\")) {\n                    if (!tb.inTableScope(name)) {\n                        tb.error(this);\n                        return false;\n                    }\n                    tb.processEndTag(\"tr\");\n                    return tb.process(t);\n                } else if (StringUtil.in(name, \"body\", \"caption\", \"col\", \"colgroup\", \"html\", \"td\", \"th\")) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    return anythingElse(t, tb);\n                }\n            } else {\n                return anythingElse(t, tb);\n            }\n            return true;\n        }",
        "javadoc": ""
      }
    },
    "contained_scope": "method",
    "bug_count": 3,
    "triggered_tests": {
      "0": {
        "test_path": "org.jsoup.parser.HtmlParserTest",
        "test_method": "testTemplateInsideTable",
        "test_code": "testTemplateInsideTable() throws IOException {\n        File in = ParseTest.getFile(\"/htmltests/table-polymer-template.html\");\n        Document doc = Jsoup.parse(in, \"UTF-8\");\n        doc.outputSettings().prettyPrint(true);\n\n        Elements templates = doc.body().getElementsByTag(\"template\");\n        for (Element template : templates) {\n            assertTrue(template.childNodes().size() > 1);\n        }\n  }",
        "clean_err_msg": "junit.framework.AssertionFailedError"
      }
    },
    "buggy_files": {
      "0": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
      "1": "src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java"
    },
    "hunk_type": "multi_file_three_hunks",
    "hunk_mapping": {
      "0": [
        {
          "start_line": 360,
          "end_line": 364,
          "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
          "code": "<START_BUG>\n        clearStackToContext(\"tbody\", \"tfoot\", \"thead\");\n    }\n\n    void clearStackToTableRowContext() {\n        clearStackToContext(\"tr\");\n<END_BUG>"
        }
      ],
      "1": [
        {
          "start_line": 1036,
          "end_line": 1036,
          "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java",
          "code": "<START_BUG>\n                    if (name.equals(\"tr\")) {\n<END_BUG>"
        }
      ],
      "2": [
        {
          "start_line": 1096,
          "end_line": 1096,
          "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java",
          "code": "<START_BUG>\n                if (StringUtil.in(name, \"th\", \"td\")) {\n<END_BUG>"
        }
      ]
    },
    "bug_report": {
      "url": "https://github.com/jhy/jsoup/issues/807",
      "title": "Parser error on <template> inside <tr>",
      "bug_description": "I've been experimenting with jsoup as a validator for TensorBoard code and I encountered a bug.\r\n\r\nIf I have code like this:\r\n\r\n```html\r\n          <tr>\r\n            <th></th>\r\n            <th>Name</th>\r\n            <template is=\"dom-if\" if=\"{{smoothingEnabled}}\">\r\n              <th>Smoothed</th>\r\n            </template>   \r\n            <th>Value</th>\r\n            <th>Step</th>\r\n            <th>Time</th>\r\n            <th>Relative</th>\r\n          </tr>\r\n```\r\n\r\nI get errors like this:\r\n\r\nERROR: tensorflow/tensorboard/components/vz_line_chart/vz-line-chart.html (offset 1282): Unexpected token [StartTag] when in state [InTable]\r\nERROR: tensorflow/tensorboard/components/vz_line_chart/vz-line-chart.html (offset 1338): Unexpected token [EndTag] when in state [InTable]\r\nERROR: tensorflow/tensorboard/components/vz_line_chart/vz-line-chart.html (offset 1338): Unexpected token [EndTag] when in state [InBody]\r\n\r\nPlease note that those offset numbers point to the `<template>` tags.\r\n\r\nTemplate tag is legal here because https://www.w3.org/TR/html5/tabular-data.html#the-tr-element says content model for `tr` is \"Zero or more td, th, and script-supporting elements\" and `template` is a script supporting element."
    }
  },
  "Chart_14": {
    "buggy_hunks": {
      "0": {
        "start_line": 2166,
        "end_line": 2165,
        "file": "source/org/jfree/chart/plot/CategoryPlot.java",
        "code": "<START_BUG>\n<END_BUG>"
      },
      "1": {
        "start_line": 2448,
        "end_line": 2447,
        "file": "source/org/jfree/chart/plot/CategoryPlot.java",
        "code": "<START_BUG>\n<END_BUG>"
      },
      "2": {
        "start_line": 2293,
        "end_line": 2292,
        "file": "source/org/jfree/chart/plot/XYPlot.java",
        "code": "<START_BUG>\n<END_BUG>"
      },
      "3": {
        "start_line": 2529,
        "end_line": 2528,
        "file": "source/org/jfree/chart/plot/XYPlot.java",
        "code": "<START_BUG>\n<END_BUG>"
      }
    },
    "buggy_code": {
      "0": {
        "start_line": 2155,
        "end_line": 2171,
        "file": "source/org/jfree/chart/plot/CategoryPlot.java",
        "code": "public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n    \t\tboolean notify) {\n        ArrayList markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                    index));\n        }\n        else {\n            markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                    index));\n        }\n        boolean removed = markers.remove(marker);\n        if (removed && notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }",
        "javadoc": "/**\n * Removes a marker for a specific dataset/renderer and, if requested,\n * sends a {@link PlotChangeEvent} to all registered listeners.\n *\n * @param index the dataset/renderer index.\n * @param marker the marker.\n * @param layer the layer (foreground or background).\n *\n * @return A boolean indicating whether or not the marker was actually\n *         removed.\n *\n * @since 1.0.10\n */\n"
      },
      "1": {
        "start_line": 2434,
        "end_line": 2453,
        "file": "source/org/jfree/chart/plot/CategoryPlot.java",
        "code": "public boolean removeRangeMarker(int index, Marker marker, Layer layer,\n    \t\tboolean notify) {\n        if (marker == null) {\n            throw new IllegalArgumentException(\"Null 'marker' argument.\");\n        }\n        ArrayList markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (ArrayList) this.foregroundRangeMarkers.get(new Integer(\n                    index));\n        }\n        else {\n            markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\n                    index));\n        }\n        boolean removed = markers.remove(marker);\n        if (removed && notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }",
        "javadoc": "/**\n * Removes a marker for a specific dataset/renderer and sends a\n * {@link PlotChangeEvent} to all registered listeners.\n *\n * @param index  the dataset/renderer index.\n * @param marker  the marker.\n * @param layer  the layer (foreground or background).\n * @param notify  notify listeners.\n *\n * @return A boolean indicating whether or not the marker was actually\n *         removed.\n *\n * @since 1.0.10\n *\n * @see #addRangeMarker(int, Marker, Layer, boolean)\n */\n"
      },
      "2": {
        "start_line": 2282,
        "end_line": 2298,
        "file": "source/org/jfree/chart/plot/XYPlot.java",
        "code": "public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n    \t\tboolean notify) {\n        ArrayList markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                    index));\n        }\n        else {\n            markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                    index));\n        }\n        boolean removed = markers.remove(marker);\n        if (removed && notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }",
        "javadoc": "/**\n * Removes a marker for a specific dataset/renderer and, if requested,\n * sends a {@link PlotChangeEvent} to all registered listeners.\n *\n * @param index  the dataset/renderer index.\n * @param marker  the marker.\n * @param layer  the layer (foreground or background).\n * @param notify  notify listeners?\n *\n * @return A boolean indicating whether or not the marker was actually\n *         removed.\n *\n * @since 1.0.10\n */\n"
      },
      "3": {
        "start_line": 2515,
        "end_line": 2534,
        "file": "source/org/jfree/chart/plot/XYPlot.java",
        "code": "public boolean removeRangeMarker(int index, Marker marker, Layer layer,\n    \t\tboolean notify) {\n        if (marker == null) {\n            throw new IllegalArgumentException(\"Null 'marker' argument.\");\n        }\n        ArrayList markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (ArrayList) this.foregroundRangeMarkers.get(new Integer(\n                    index));\n        }\n        else {\n            markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\n                    index));\n        }\n        boolean removed = markers.remove(marker);\n        if (removed && notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }",
        "javadoc": "/**\n * Removes a marker for a specific dataset/renderer and sends a\n * {@link PlotChangeEvent} to all registered listeners.\n *\n * @param index  the dataset/renderer index.\n * @param marker  the marker.\n * @param layer  the layer (foreground or background).\n * @param notify  notify listeners?\n *\n * @return A boolean indicating whether or not the marker was actually\n *         removed.\n *\n * @since 1.0.10\n */\n"
      }
    },
    "delineated_bug": {
      "0": {
        "start_line": 2155,
        "end_line": 2171,
        "file": "source/org/jfree/chart/plot/CategoryPlot.java",
        "code": "public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n    \t\tboolean notify) {\n        ArrayList markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                    index));\n        }\n        else {\n            markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                    index));\n        }\n<END_BUG>\n<START_BUG>\n        boolean removed = markers.remove(marker);\n        if (removed && notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }",
        "javadoc": "/**\n * Removes a marker for a specific dataset/renderer and, if requested,\n * sends a {@link PlotChangeEvent} to all registered listeners.\n *\n * @param index the dataset/renderer index.\n * @param marker the marker.\n * @param layer the layer (foreground or background).\n *\n * @return A boolean indicating whether or not the marker was actually\n *         removed.\n *\n * @since 1.0.10\n */\n"
      },
      "1": {
        "start_line": 2434,
        "end_line": 2453,
        "file": "source/org/jfree/chart/plot/CategoryPlot.java",
        "code": "public boolean removeRangeMarker(int index, Marker marker, Layer layer,\n    \t\tboolean notify) {\n        if (marker == null) {\n            throw new IllegalArgumentException(\"Null 'marker' argument.\");\n        }\n        ArrayList markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (ArrayList) this.foregroundRangeMarkers.get(new Integer(\n                    index));\n        }\n        else {\n            markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\n                    index));\n        }\n<END_BUG>\n<START_BUG>\n        boolean removed = markers.remove(marker);\n        if (removed && notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }",
        "javadoc": "/**\n * Removes a marker for a specific dataset/renderer and sends a\n * {@link PlotChangeEvent} to all registered listeners.\n *\n * @param index  the dataset/renderer index.\n * @param marker  the marker.\n * @param layer  the layer (foreground or background).\n * @param notify  notify listeners.\n *\n * @return A boolean indicating whether or not the marker was actually\n *         removed.\n *\n * @since 1.0.10\n *\n * @see #addRangeMarker(int, Marker, Layer, boolean)\n */\n"
      },
      "2": {
        "start_line": 2282,
        "end_line": 2298,
        "file": "source/org/jfree/chart/plot/XYPlot.java",
        "code": "public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n    \t\tboolean notify) {\n        ArrayList markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                    index));\n        }\n        else {\n            markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                    index));\n        }\n<END_BUG>\n<START_BUG>\n        boolean removed = markers.remove(marker);\n        if (removed && notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }",
        "javadoc": "/**\n * Removes a marker for a specific dataset/renderer and, if requested,\n * sends a {@link PlotChangeEvent} to all registered listeners.\n *\n * @param index  the dataset/renderer index.\n * @param marker  the marker.\n * @param layer  the layer (foreground or background).\n * @param notify  notify listeners?\n *\n * @return A boolean indicating whether or not the marker was actually\n *         removed.\n *\n * @since 1.0.10\n */\n"
      },
      "3": {
        "start_line": 2515,
        "end_line": 2534,
        "file": "source/org/jfree/chart/plot/XYPlot.java",
        "code": "public boolean removeRangeMarker(int index, Marker marker, Layer layer,\n    \t\tboolean notify) {\n        if (marker == null) {\n            throw new IllegalArgumentException(\"Null 'marker' argument.\");\n        }\n        ArrayList markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (ArrayList) this.foregroundRangeMarkers.get(new Integer(\n                    index));\n        }\n        else {\n            markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\n                    index));\n        }\n<END_BUG>\n<START_BUG>\n        boolean removed = markers.remove(marker);\n        if (removed && notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }",
        "javadoc": "/**\n * Removes a marker for a specific dataset/renderer and sends a\n * {@link PlotChangeEvent} to all registered listeners.\n *\n * @param index  the dataset/renderer index.\n * @param marker  the marker.\n * @param layer  the layer (foreground or background).\n * @param notify  notify listeners?\n *\n * @return A boolean indicating whether or not the marker was actually\n *         removed.\n *\n * @since 1.0.10\n */\n"
      }
    },
    "contained_scope": "method",
    "bug_count": 4,
    "triggered_tests": {
      "0": {
        "test_path": "org.jfree.chart.plot.junit.CategoryPlotTests",
        "test_method": "testRemoveRangeMarker",
        "test_code": "testRemoveRangeMarker() (DG);\n *\n */\n\npackage org.jfree.chart.plot.junit;\n\nimport java.awt.BasicStroke;\nimport java.awt.Color;\nimport java.awt.GradientPaint;\nimport java.awt.Graphics2D;\nimport java.awt.Stroke;\nimport java.awt.geom.Rectangle2D;\nimport java.awt.image.BufferedImage;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInput;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutput;\nimport java.io.ObjectOutputStream;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport junit.framework.Test;\nimport junit.framework.TestCase;\nimport junit.framework.TestSuite;\n\nimport org.jfree.chart.ChartFactory;\nimport org.jfree.chart.JFreeChart;\nimport org.jfree.chart.annotations.CategoryTextAnnotation;\nimport org.jfree.chart.axis.AxisLocation;\nimport org.jfree.chart.axis.AxisSpace;\nimport org.jfree.chart.axis.CategoryAnchor;\nimport org.jfree.chart.axis.CategoryAxis;\nimport org.jfree.chart.axis.NumberAxis;\nimport org.jfree.chart.event.MarkerChangeListener;\nimport org.jfree.chart.plot.CategoryMarker;\nimport org.jfree.chart.plot.CategoryPlot;\nimport org.jfree.chart.plot.DatasetRenderingOrder;\nimport org.jfree.chart.plot.IntervalMarker;\nimport org.jfree.chart.plot.Marker;\nimport org.jfree.chart.plot.PlotOrientation;\nimport org.jfree.chart.plot.ValueMarker;\nimport org.jfree.chart.renderer.category.AreaRenderer;\nimport org.jfree.chart.renderer.category.BarRenderer;\nimport org.jfree.chart.renderer.category.CategoryItemRenderer;\nimport org.jfree.chart.renderer.category.LineAndShapeRenderer;\nimport org.jfree.chart.util.Layer;\nimport org.jfree.chart.util.RectangleInsets;\nimport org.jfree.chart.util.SortOrder;\nimport org.jfree.data.Range;\nimport org.jfree.data.category.DefaultCategoryDataset;\n\n/**\n * Tests for the {@link CategoryPlot}",
        "clean_err_msg": "java.lang.NullPointerException"
      },
      "1": {
        "test_path": "org.jfree.chart.plot.junit.CategoryPlotTests",
        "test_method": "testRemoveDomainMarker",
        "test_code": "testRemoveDomainMarker() and \n *               testRemoveRangeMarker() (DG);\n *\n */\n\npackage org.jfree.chart.plot.junit;\n\nimport java.awt.BasicStroke;\nimport java.awt.Color;\nimport java.awt.GradientPaint;\nimport java.awt.Graphics2D;\nimport java.awt.Stroke;\nimport java.awt.geom.Rectangle2D;\nimport java.awt.image.BufferedImage;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInput;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutput;\nimport java.io.ObjectOutputStream;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport junit.framework.Test;\nimport junit.framework.TestCase;\nimport junit.framework.TestSuite;\n\nimport org.jfree.chart.ChartFactory;\nimport org.jfree.chart.JFreeChart;\nimport org.jfree.chart.annotations.CategoryTextAnnotation;\nimport org.jfree.chart.axis.AxisLocation;\nimport org.jfree.chart.axis.AxisSpace;\nimport org.jfree.chart.axis.CategoryAnchor;\nimport org.jfree.chart.axis.CategoryAxis;\nimport org.jfree.chart.axis.NumberAxis;\nimport org.jfree.chart.event.MarkerChangeListener;\nimport org.jfree.chart.plot.CategoryMarker;\nimport org.jfree.chart.plot.CategoryPlot;\nimport org.jfree.chart.plot.DatasetRenderingOrder;\nimport org.jfree.chart.plot.IntervalMarker;\nimport org.jfree.chart.plot.Marker;\nimport org.jfree.chart.plot.PlotOrientation;\nimport org.jfree.chart.plot.ValueMarker;\nimport org.jfree.chart.renderer.category.AreaRenderer;\nimport org.jfree.chart.renderer.category.BarRenderer;\nimport org.jfree.chart.renderer.category.CategoryItemRenderer;\nimport org.jfree.chart.renderer.category.LineAndShapeRenderer;\nimport org.jfree.chart.util.Layer;\nimport org.jfree.chart.util.RectangleInsets;\nimport org.jfree.chart.util.SortOrder;\nimport org.jfree.data.Range;\nimport org.jfree.data.category.DefaultCategoryDataset;\n\n/**\n * Tests for the {@link CategoryPlot}",
        "clean_err_msg": "java.lang.NullPointerException"
      },
      "2": {
        "test_path": "org.jfree.chart.plot.junit.XYPlotTests",
        "test_method": "testRemoveRangeMarker",
        "test_code": "testRemoveRangeMarker() (DG);\n * \n */\n\npackage org.jfree.chart.plot.junit;\n\nimport java.awt.BasicStroke;\nimport java.awt.Color;\nimport java.awt.GradientPaint;\nimport java.awt.Graphics2D;\nimport java.awt.Stroke;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.awt.image.BufferedImage;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInput;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutput;\nimport java.io.ObjectOutputStream;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport junit.framework.Test;\nimport junit.framework.TestCase;\nimport junit.framework.TestSuite;\n\nimport org.jfree.chart.ChartFactory;\nimport org.jfree.chart.JFreeChart;\nimport org.jfree.chart.LegendItemCollection;\nimport org.jfree.chart.annotations.XYTextAnnotation;\nimport org.jfree.chart.axis.AxisLocation;\nimport org.jfree.chart.axis.DateAxis;\nimport org.jfree.chart.axis.NumberAxis;\nimport org.jfree.chart.event.MarkerChangeListener;\nimport org.jfree.chart.labels.StandardXYToolTipGenerator;\nimport org.jfree.chart.plot.IntervalMarker;\nimport org.jfree.chart.plot.Marker;\nimport org.jfree.chart.plot.PlotOrientation;\nimport org.jfree.chart.plot.ValueMarker;\nimport org.jfree.chart.plot.XYPlot;\nimport org.jfree.chart.renderer.xy.DefaultXYItemRenderer;\nimport org.jfree.chart.renderer.xy.StandardXYItemRenderer;\nimport org.jfree.chart.renderer.xy.XYBarRenderer;\nimport org.jfree.chart.renderer.xy.XYItemRenderer;\nimport org.jfree.chart.renderer.xy.XYLineAndShapeRenderer;\nimport org.jfree.chart.util.Layer;\nimport org.jfree.chart.util.RectangleInsets;\nimport org.jfree.data.time.Day;\nimport org.jfree.data.time.MonthConstants;\nimport org.jfree.data.time.TimeSeries;\nimport org.jfree.data.time.TimeSeriesCollection;\nimport org.jfree.data.xy.DefaultXYDataset;\nimport org.jfree.data.xy.IntervalXYDataset;\nimport org.jfree.data.xy.XYDataset;\nimport org.jfree.data.xy.XYSeries;\nimport org.jfree.data.xy.XYSeriesCollection;\n\n/**\n * Tests for the {@link XYPlot}",
        "clean_err_msg": "java.lang.NullPointerException"
      },
      "3": {
        "test_path": "org.jfree.chart.plot.junit.XYPlotTests",
        "test_method": "testRemoveDomainMarker",
        "test_code": "testRemoveDomainMarker() and \n *               testRemoveRangeMarker() (DG);\n * \n */\n\npackage org.jfree.chart.plot.junit;\n\nimport java.awt.BasicStroke;\nimport java.awt.Color;\nimport java.awt.GradientPaint;\nimport java.awt.Graphics2D;\nimport java.awt.Stroke;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.awt.image.BufferedImage;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInput;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutput;\nimport java.io.ObjectOutputStream;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport junit.framework.Test;\nimport junit.framework.TestCase;\nimport junit.framework.TestSuite;\n\nimport org.jfree.chart.ChartFactory;\nimport org.jfree.chart.JFreeChart;\nimport org.jfree.chart.LegendItemCollection;\nimport org.jfree.chart.annotations.XYTextAnnotation;\nimport org.jfree.chart.axis.AxisLocation;\nimport org.jfree.chart.axis.DateAxis;\nimport org.jfree.chart.axis.NumberAxis;\nimport org.jfree.chart.event.MarkerChangeListener;\nimport org.jfree.chart.labels.StandardXYToolTipGenerator;\nimport org.jfree.chart.plot.IntervalMarker;\nimport org.jfree.chart.plot.Marker;\nimport org.jfree.chart.plot.PlotOrientation;\nimport org.jfree.chart.plot.ValueMarker;\nimport org.jfree.chart.plot.XYPlot;\nimport org.jfree.chart.renderer.xy.DefaultXYItemRenderer;\nimport org.jfree.chart.renderer.xy.StandardXYItemRenderer;\nimport org.jfree.chart.renderer.xy.XYBarRenderer;\nimport org.jfree.chart.renderer.xy.XYItemRenderer;\nimport org.jfree.chart.renderer.xy.XYLineAndShapeRenderer;\nimport org.jfree.chart.util.Layer;\nimport org.jfree.chart.util.RectangleInsets;\nimport org.jfree.data.time.Day;\nimport org.jfree.data.time.MonthConstants;\nimport org.jfree.data.time.TimeSeries;\nimport org.jfree.data.time.TimeSeriesCollection;\nimport org.jfree.data.xy.DefaultXYDataset;\nimport org.jfree.data.xy.IntervalXYDataset;\nimport org.jfree.data.xy.XYDataset;\nimport org.jfree.data.xy.XYSeries;\nimport org.jfree.data.xy.XYSeriesCollection;\n\n/**\n * Tests for the {@link XYPlot}",
        "clean_err_msg": "java.lang.NullPointerException"
      }
    },
    "buggy_files": {
      "0": "source/org/jfree/chart/plot/CategoryPlot.java",
      "1": "source/org/jfree/chart/plot/XYPlot.java"
    },
    "hunk_type": "multi_file_four_or_more_hunks",
    "hunk_mapping": {
      "0": [
        {
          "start_line": 2166,
          "end_line": 2165,
          "file": "source/org/jfree/chart/plot/CategoryPlot.java",
          "code": "<START_BUG>\n<END_BUG>"
        }
      ],
      "1": [
        {
          "start_line": 2448,
          "end_line": 2447,
          "file": "source/org/jfree/chart/plot/CategoryPlot.java",
          "code": "<START_BUG>\n<END_BUG>"
        }
      ],
      "2": [
        {
          "start_line": 2293,
          "end_line": 2292,
          "file": "source/org/jfree/chart/plot/XYPlot.java",
          "code": "<START_BUG>\n<END_BUG>"
        }
      ],
      "3": [
        {
          "start_line": 2529,
          "end_line": 2528,
          "file": "source/org/jfree/chart/plot/XYPlot.java",
          "code": "<START_BUG>\n<END_BUG>"
        }
      ]
    },
    "bug_report": {
      "url": "UNKNOWN",
      "bug_description": "",
      "title": ""
    }
  },
  "Time_2": {
    "buggy_hunks": {
      "0": {
        "start_line": 227,
        "end_line": 226,
        "file": "src/main/java/org/joda/time/field/UnsupportedDurationField.java",
        "code": "<START_BUG>\n<END_BUG>"
      },
      "1": {
        "start_line": 218,
        "end_line": 218,
        "file": "src/main/java/org/joda/time/Partial.java",
        "code": "<START_BUG>\n                if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n<END_BUG>"
      },
      "2": {
        "start_line": 449,
        "end_line": 448,
        "file": "src/main/java/org/joda/time/Partial.java",
        "code": "<START_BUG>\n<END_BUG>"
      }
    },
    "buggy_code": {
      "0": {
        "start_line": 226,
        "end_line": 228,
        "file": "src/main/java/org/joda/time/field/UnsupportedDurationField.java",
        "code": "public int compareTo(DurationField durationField) {\n        return 0;\n    }",
        "javadoc": "/**\n * Always returns zero, indicating that sort order is not relevent.\n *\n * @return zero always\n */\n"
      },
      "1": {
        "start_line": 189,
        "end_line": 251,
        "file": "src/main/java/org/joda/time/Partial.java",
        "code": "public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {\n        super();\n        chronology = DateTimeUtils.getChronology(chronology).withUTC();\n        iChronology = chronology;\n        if (types == null) {\n            throw new IllegalArgumentException(\"Types array must not be null\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Values array must not be null\");\n        }\n        if (values.length != types.length) {\n            throw new IllegalArgumentException(\"Values array must be the same length as the types array\");\n        }\n        if (types.length == 0) {\n            iTypes = types;\n            iValues = values;\n            return;\n        }\n        for (int i = 0; i < types.length; i++) {\n            if (types[i] == null) {\n                throw new IllegalArgumentException(\"Types array must not contain null: index \" + i);\n            }\n        }\n        DurationField lastUnitField = null;\n        for (int i = 0; i < types.length; i++) {\n            DateTimeFieldType loopType = types[i];\n            DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n            if (i > 0) {\n                int compare = lastUnitField.compareTo(loopUnitField);\n                if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }\n            }\n            lastUnitField = loopUnitField;\n        }\n        \n        iTypes = (DateTimeFieldType[]) types.clone();\n        chronology.validate(this, values);\n        iValues = (int[]) values.clone();\n    }",
        "javadoc": "/**\n * Constructs a Partial with the specified fields and values.\n * The fields must be specified in the order largest to smallest.\n * <p>\n * The constructor uses the specified chronology.\n *\n * @param types  the types to create the partial from, not null\n * @param values  the values to store, not null\n * @param chronology  the chronology, null means ISO\n * @throws IllegalArgumentException if the types or values are invalid\n */\n"
      },
      "2": {
        "start_line": 428,
        "end_line": 476,
        "file": "src/main/java/org/joda/time/Partial.java",
        "code": "public Partial with(DateTimeFieldType fieldType, int value) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"The field type must not be null\");\n        }\n        int index = indexOf(fieldType);\n        if (index == -1) {\n            DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n            int[] newValues = new int[newTypes.length];\n            \n            // find correct insertion point to keep largest-smallest order\n            int i = 0;\n            DurationField unitField = fieldType.getDurationType().getField(iChronology);\n            if (unitField.isSupported()) {\n                for (; i < iTypes.length; i++) {\n                    DateTimeFieldType loopType = iTypes[i];\n                    DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                    if (loopUnitField.isSupported()) {\n                        int compare = unitField.compareTo(loopUnitField);\n                        if (compare > 0) {\n                            break;\n                        } else if (compare == 0) {\n                            DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                            DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                            if (rangeField.compareTo(loopRangeField) > 0) {\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            System.arraycopy(iTypes, 0, newTypes, 0, i);\n            System.arraycopy(iValues, 0, newValues, 0, i);\n            newTypes[i] = fieldType;\n            newValues[i] = value;\n            System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n            System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n            // use public constructor to ensure full validation\n            // this isn't overly efficient, but is safe\n            Partial newPartial = new Partial(newTypes, newValues, iChronology);\n            iChronology.validate(newPartial, newValues);\n            return newPartial;\n        }\n        if (value == getValue(index)) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).set(this, index, newValues, value);\n        return new Partial(this, newValues);\n    }",
        "javadoc": "/**\n * Gets a copy of this date with the specified field set to a new value.\n * <p>\n * If this partial did not previously support the field, the new one will.\n * Contrast this behaviour with {@link #withField(DateTimeFieldType, int)}.\n * <p>\n * For example, if the field type is <code>dayOfMonth</code> then the day\n * would be changed/added in the returned instance.\n *\n * @param fieldType  the field type to set, not null\n * @param value  the value to set\n * @return a copy of this instance with the field set\n * @throws IllegalArgumentException if the value is null or invalid\n */\n"
      }
    },
    "delineated_bug": {
      "0": {
        "start_line": 226,
        "end_line": 228,
        "file": "src/main/java/org/joda/time/field/UnsupportedDurationField.java",
        "code": "public int compareTo(DurationField durationField) {\n<END_BUG>\n<START_BUG>\n        return 0;\n    }",
        "javadoc": "/**\n * Always returns zero, indicating that sort order is not relevent.\n *\n * @return zero always\n */\n"
      },
      "1": {
        "start_line": 189,
        "end_line": 251,
        "file": "src/main/java/org/joda/time/Partial.java",
        "code": "public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {\n        super();\n        chronology = DateTimeUtils.getChronology(chronology).withUTC();\n        iChronology = chronology;\n        if (types == null) {\n            throw new IllegalArgumentException(\"Types array must not be null\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Values array must not be null\");\n        }\n        if (values.length != types.length) {\n            throw new IllegalArgumentException(\"Values array must be the same length as the types array\");\n        }\n        if (types.length == 0) {\n            iTypes = types;\n            iValues = values;\n            return;\n        }\n        for (int i = 0; i < types.length; i++) {\n            if (types[i] == null) {\n                throw new IllegalArgumentException(\"Types array must not contain null: index \" + i);\n            }\n        }\n        DurationField lastUnitField = null;\n        for (int i = 0; i < types.length; i++) {\n            DateTimeFieldType loopType = types[i];\n            DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n            if (i > 0) {\n                int compare = lastUnitField.compareTo(loopUnitField);\n<START_BUG>\n                if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n<END_BUG>\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }\n            }\n            lastUnitField = loopUnitField;\n        }\n        \n        iTypes = (DateTimeFieldType[]) types.clone();\n        chronology.validate(this, values);\n        iValues = (int[]) values.clone();\n    }",
        "javadoc": "/**\n * Constructs a Partial with the specified fields and values.\n * The fields must be specified in the order largest to smallest.\n * <p>\n * The constructor uses the specified chronology.\n *\n * @param types  the types to create the partial from, not null\n * @param values  the values to store, not null\n * @param chronology  the chronology, null means ISO\n * @throws IllegalArgumentException if the types or values are invalid\n */\n"
      },
      "2": {
        "start_line": 428,
        "end_line": 476,
        "file": "src/main/java/org/joda/time/Partial.java",
        "code": "public Partial with(DateTimeFieldType fieldType, int value) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"The field type must not be null\");\n        }\n        int index = indexOf(fieldType);\n        if (index == -1) {\n            DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n            int[] newValues = new int[newTypes.length];\n            \n            // find correct insertion point to keep largest-smallest order\n            int i = 0;\n            DurationField unitField = fieldType.getDurationType().getField(iChronology);\n            if (unitField.isSupported()) {\n                for (; i < iTypes.length; i++) {\n                    DateTimeFieldType loopType = iTypes[i];\n                    DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                    if (loopUnitField.isSupported()) {\n                        int compare = unitField.compareTo(loopUnitField);\n                        if (compare > 0) {\n                            break;\n                        } else if (compare == 0) {\n<END_BUG>\n<START_BUG>\n                            DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                            DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                            if (rangeField.compareTo(loopRangeField) > 0) {\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            System.arraycopy(iTypes, 0, newTypes, 0, i);\n            System.arraycopy(iValues, 0, newValues, 0, i);\n            newTypes[i] = fieldType;\n            newValues[i] = value;\n            System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n            System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n            // use public constructor to ensure full validation\n            // this isn't overly efficient, but is safe\n            Partial newPartial = new Partial(newTypes, newValues, iChronology);\n            iChronology.validate(newPartial, newValues);\n            return newPartial;\n        }\n        if (value == getValue(index)) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).set(this, index, newValues, value);\n        return new Partial(this, newValues);\n    }",
        "javadoc": "/**\n * Gets a copy of this date with the specified field set to a new value.\n * <p>\n * If this partial did not previously support the field, the new one will.\n * Contrast this behaviour with {@link #withField(DateTimeFieldType, int)}.\n * <p>\n * For example, if the field type is <code>dayOfMonth</code> then the day\n * would be changed/added in the returned instance.\n *\n * @param fieldType  the field type to set, not null\n * @param value  the value to set\n * @return a copy of this instance with the field set\n * @throws IllegalArgumentException if the value is null or invalid\n */\n"
      }
    },
    "contained_scope": "method",
    "bug_count": 3,
    "triggered_tests": {
      "0": {
        "test_path": "org.joda.time.TestPartial_Basics",
        "test_method": "testWith_baseAndArgHaveNoRange",
        "test_code": "testWith_baseAndArgHaveNoRange() {\n        Partial test = new Partial(DateTimeFieldType.year(), 1);\n        Partial result = test.with(DateTimeFieldType.era(), 1);\n        assertEquals(2, result.size());\n        assertEquals(0, result.indexOf(DateTimeFieldType.era()));\n        assertEquals(1, result.indexOf(DateTimeFieldType.year()));\n    }",
        "clean_err_msg": "java.lang.IllegalArgumentException: Types array must not contain duplicate: era and year"
      }
    },
    "buggy_files": {
      "0": "src/main/java/org/joda/time/field/UnsupportedDurationField.java",
      "1": "src/main/java/org/joda/time/Partial.java"
    },
    "hunk_type": "multi_file_three_hunks",
    "hunk_mapping": {
      "0": [
        {
          "start_line": 227,
          "end_line": 226,
          "file": "src/main/java/org/joda/time/field/UnsupportedDurationField.java",
          "code": "<START_BUG>\n<END_BUG>"
        }
      ],
      "1": [
        {
          "start_line": 218,
          "end_line": 218,
          "file": "src/main/java/org/joda/time/Partial.java",
          "code": "<START_BUG>\n                if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n<END_BUG>"
        }
      ],
      "2": [
        {
          "start_line": 449,
          "end_line": 448,
          "file": "src/main/java/org/joda/time/Partial.java",
          "code": "<START_BUG>\n<END_BUG>"
        }
      ]
    },
    "bug_report": {
      "url": "https://github.com/JodaOrg/joda-time/issues/93",
      "title": "Partial.with fails with NPE",
      "bug_description": "With the latest master:\n\n``` java\nnew Partial(yearOfCentury(),  1).with(weekyear(), 1);\n// NullPointerException\n// org.joda.time.Partial.with (Partial.java:447)\n```\n\nFails with yearOfCentury, year and yearOfEra. Probably because weekyear has a null range duration type."
    }
  },
  "Gson_9": {
    "buggy_hunks": {
      "0": {
        "start_line": 162,
        "end_line": 161,
        "file": "gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java",
        "code": "<START_BUG>\n<END_BUG>"
      },
      "1": {
        "start_line": 165,
        "end_line": 168,
        "file": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "code": "<START_BUG>\n      if (value == null) {\n        out.nullValue();\n        return;\n      }\n<END_BUG>"
      },
      "2": {
        "start_line": 476,
        "end_line": 475,
        "file": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
        "code": "<START_BUG>\n<END_BUG>"
      }
    },
    "buggy_code": {
      "0": {
        "start_line": 162,
        "end_line": 162,
        "file": "gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java",
        "code": "",
        "javadoc": ""
      },
      "1": {
        "start_line": 163,
        "end_line": 170,
        "file": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "code": "@Override\n    public void write(JsonWriter out, Boolean value) throws IOException {\n      if (value == null) {\n        out.nullValue();\n        return;\n      }\n      out.value(value);\n    }",
        "javadoc": ""
      },
      "2": {
        "start_line": 476,
        "end_line": 476,
        "file": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
        "code": "",
        "javadoc": ""
      }
    },
    "delineated_bug": {
      "0": {
        "start_line": 162,
        "end_line": 162,
        "file": "gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java",
        "code": "<START_BUG>\n\n<END_BUG>",
        "javadoc": ""
      },
      "1": {
        "start_line": 163,
        "end_line": 170,
        "file": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "code": "@Override\n    public void write(JsonWriter out, Boolean value) throws IOException {\n<START_BUG>\n      if (value == null) {\n        out.nullValue();\n        return;\n      }\n<END_BUG>\n      out.value(value);\n    }",
        "javadoc": ""
      },
      "2": {
        "start_line": 476,
        "end_line": 476,
        "file": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
        "code": "<START_BUG>\n\n<END_BUG>",
        "javadoc": ""
      }
    },
    "contained_scope": "file",
    "bug_count": 3,
    "triggered_tests": {
      "0": {
        "test_path": "com.google.gson.stream.JsonWriterTest",
        "test_method": "testBoxedBooleans",
        "test_code": "testBoxedBooleans() throws IOException {\n    StringWriter stringWriter = new StringWriter();\n    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n    jsonWriter.beginArray();\n    jsonWriter.value((Boolean) true);\n    jsonWriter.value((Boolean) false);\n    jsonWriter.value((Boolean) null);\n    jsonWriter.endArray();\n    assertEquals(\"[true,false,null]\", stringWriter.toString());\n  }",
        "clean_err_msg": "java.lang.NullPointerException"
      }
    },
    "buggy_files": {
      "0": "gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java",
      "1": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
      "2": "gson/src/main/java/com/google/gson/stream/JsonWriter.java"
    },
    "hunk_type": "multi_file_three_hunks",
    "hunk_mapping": {
      "0": [
        {
          "start_line": 162,
          "end_line": 161,
          "file": "gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java",
          "code": "<START_BUG>\n<END_BUG>"
        }
      ],
      "1": [
        {
          "start_line": 165,
          "end_line": 168,
          "file": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
          "code": "<START_BUG>\n      if (value == null) {\n        out.nullValue();\n        return;\n      }\n<END_BUG>"
        }
      ],
      "2": [
        {
          "start_line": 476,
          "end_line": 475,
          "file": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
          "code": "<START_BUG>\n<END_BUG>"
        }
      ]
    },
    "bug_report": {
      "url": "https://github.com/google/gson/pull/836",
      "title": "Add boxed boolean value() overload.",
      "bug_description": "When calling value() with a Boolean, overload resolution would choose value(boolean) which would throw an NPE on null. The other boxed types are all numbers which would resolve to value(Number) and behave correctly.\n\nProof this happens: https://github.com/bugsnag/bugsnag-android/pull/42"
    }
  },
  "Math_6": {
    "buggy_hunks": {
      "0": {
        "start_line": 51,
        "end_line": 51,
        "file": "src/main/java/org/apache/commons/math3/optim/BaseOptimizer.java",
        "code": "<START_BUG>\n        iterations = new Incrementor(0, new MaxIterCallback());\n<END_BUG>"
      },
      "1": {
        "start_line": 214,
        "end_line": 223,
        "file": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer.java",
        "code": "<START_BUG>\n        int iter = 0;\n        int maxEval = getMaxEvaluations();\n        while (true) {\n            ++iter;\n\n            final double objective = computeObjectiveValue(point);\n            PointValuePair previous = current;\n            current = new PointValuePair(point, objective);\n            if (previous != null) {\n                if (checker.converged(iter, previous, current)) {\n<END_BUG>"
      },
      "2": {
        "start_line": 277,
        "end_line": 277,
        "file": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer.java",
        "code": "<START_BUG>\n            if (iter % n == 0 ||\n<END_BUG>"
      },
      "3": {
        "start_line": 388,
        "end_line": 387,
        "file": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java",
        "code": "<START_BUG>\n<END_BUG>"
      },
      "4": {
        "start_line": 191,
        "end_line": 193,
        "file": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizer.java",
        "code": "<START_BUG>\n        int iter = 0;\n        while (true) {\n            ++iter;\n<END_BUG>"
      },
      "5": {
        "start_line": 227,
        "end_line": 227,
        "file": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizer.java",
        "code": "<START_BUG>\n                    stop = checker.converged(iter, previous, current);\n<END_BUG>"
      },
      "6": {
        "start_line": 158,
        "end_line": 158,
        "file": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizer.java",
        "code": "<START_BUG>\n            if (iteration > 0) {\n<END_BUG>"
      },
      "7": {
        "start_line": 175,
        "end_line": 175,
        "file": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizer.java",
        "code": "<START_BUG>\n\t\t\t++iteration;\n<END_BUG>"
      },
      "8": {
        "start_line": 106,
        "end_line": 108,
        "file": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizer.java",
        "code": "<START_BUG>\n        int iter = 0;\n        for (boolean converged = false; !converged;) {\n            ++iter;\n<END_BUG>"
      },
      "9": {
        "start_line": 160,
        "end_line": 160,
        "file": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizer.java",
        "code": "<START_BUG>\n                converged = checker.converged(iter, previous, current);\n<END_BUG>"
      },
      "10": {
        "start_line": 322,
        "end_line": 325,
        "file": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java",
        "code": "<START_BUG>\n        int iter = 0;\n        final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker();\n        while (true) {\n            ++iter;\n<END_BUG>"
      },
      "11": {
        "start_line": 489,
        "end_line": 489,
        "file": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java",
        "code": "<START_BUG>\n                        if (checker.converged(iter, previous, current)) {\n<END_BUG>"
      }
    },
    "buggy_code": {
      "0": {
        "start_line": 47,
        "end_line": 52,
        "file": "src/main/java/org/apache/commons/math3/optim/BaseOptimizer.java",
        "code": "protected BaseOptimizer(ConvergenceChecker<PAIR> checker) {\n        this.checker = checker;\n\n        evaluations = new Incrementor(0, new MaxEvalCallback());\n        iterations = new Incrementor(0, new MaxIterCallback());\n    }",
        "javadoc": "/**\n * @param checker Convergence checker.\n */\n"
      },
      "1": {
        "start_line": 191,
        "end_line": 288,
        "file": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer.java",
        "code": "@Override\n    protected PointValuePair doOptimize() {\n        final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();\n        final double[] point = getStartPoint();\n        final GoalType goal = getGoalType();\n        final int n = point.length;\n        double[] r = computeObjectiveGradient(point);\n        if (goal == GoalType.MINIMIZE) {\n            for (int i = 0; i < n; i++) {\n                r[i] = -r[i];\n            }\n        }\n\n        // Initial search direction.\n        double[] steepestDescent = preconditioner.precondition(point, r);\n        double[] searchDirection = steepestDescent.clone();\n\n        double delta = 0;\n        for (int i = 0; i < n; ++i) {\n            delta += r[i] * searchDirection[i];\n        }\n\n        PointValuePair current = null;\n        int iter = 0;\n        int maxEval = getMaxEvaluations();\n        while (true) {\n            ++iter;\n\n            final double objective = computeObjectiveValue(point);\n            PointValuePair previous = current;\n            current = new PointValuePair(point, objective);\n            if (previous != null) {\n                if (checker.converged(iter, previous, current)) {\n                    // We have found an optimum.\n                    return current;\n                }\n            }\n\n            // Find the optimal step in the search direction.\n            final UnivariateFunction lsf = new LineSearchFunction(point, searchDirection);\n            final double uB = findUpperBound(lsf, 0, initialStep);\n            // XXX Last parameters is set to a value close to zero in order to\n            // work around the divergence problem in the \"testCircleFitting\"\n            // unit test (see MATH-439).\n            final double step = solver.solve(maxEval, lsf, 0, uB, 1e-15);\n            maxEval -= solver.getEvaluations(); // Subtract used up evaluations.\n\n            // Validate new point.\n            for (int i = 0; i < point.length; ++i) {\n                point[i] += step * searchDirection[i];\n            }\n\n            r = computeObjectiveGradient(point);\n            if (goal == GoalType.MINIMIZE) {\n                for (int i = 0; i < n; ++i) {\n                    r[i] = -r[i];\n                }\n            }\n\n            // Compute beta.\n            final double deltaOld = delta;\n            final double[] newSteepestDescent = preconditioner.precondition(point, r);\n            delta = 0;\n            for (int i = 0; i < n; ++i) {\n                delta += r[i] * newSteepestDescent[i];\n            }\n\n            final double beta;\n            switch (updateFormula) {\n            case FLETCHER_REEVES:\n                beta = delta / deltaOld;\n                break;\n            case POLAK_RIBIERE:\n                double deltaMid = 0;\n                for (int i = 0; i < r.length; ++i) {\n                    deltaMid += r[i] * steepestDescent[i];\n                }\n                beta = (delta - deltaMid) / deltaOld;\n                break;\n            default:\n                // Should never happen.\n                throw new MathInternalError();\n            }\n            steepestDescent = newSteepestDescent;\n\n            // Compute conjugate search direction.\n            if (iter % n == 0 ||\n                beta < 0) {\n                // Break conjugation: reset search direction.\n                searchDirection = steepestDescent.clone();\n            } else {\n                // Compute new conjugate search direction.\n                for (int i = 0; i < n; ++i) {\n                    searchDirection[i] = steepestDescent[i] + beta * searchDirection[i];\n                }\n            }\n        }\n    }",
        "javadoc": "/**\n * {@inheritDoc}\n */\n"
      },
      "2": {
        "start_line": 367,
        "end_line": 515,
        "file": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java",
        "code": "@Override\n    protected PointValuePair doOptimize() {\n         // -------------------- Initialization --------------------------------\n        isMinimize = getGoalType().equals(GoalType.MINIMIZE);\n        final FitnessFunction fitfun = new FitnessFunction();\n        final double[] guess = getStartPoint();\n        // number of objective variables/problem dimension\n        dimension = guess.length;\n        initializeCMA(guess);\n        iterations = 0;\n        double bestValue = fitfun.value(guess);\n        push(fitnessHistory, bestValue);\n        PointValuePair optimum\n            = new PointValuePair(getStartPoint(),\n                                 isMinimize ? bestValue : -bestValue);\n        PointValuePair lastResult = null;\n\n        // -------------------- Generation Loop --------------------------------\n\n        generationLoop:\n        for (iterations = 1; iterations <= maxIterations; iterations++) {\n\n            // Generate and evaluate lambda offspring\n            final RealMatrix arz = randn1(dimension, lambda);\n            final RealMatrix arx = zeros(dimension, lambda);\n            final double[] fitness = new double[lambda];\n            // generate random offspring\n            for (int k = 0; k < lambda; k++) {\n                RealMatrix arxk = null;\n                for (int i = 0; i < checkFeasableCount + 1; i++) {\n                    if (diagonalOnly <= 0) {\n                        arxk = xmean.add(BD.multiply(arz.getColumnMatrix(k))\n                                         .scalarMultiply(sigma)); // m + sig * Normal(0,C)\n                    } else {\n                        arxk = xmean.add(times(diagD,arz.getColumnMatrix(k))\n                                         .scalarMultiply(sigma));\n                    }\n                    if (i >= checkFeasableCount ||\n                        fitfun.isFeasible(arxk.getColumn(0))) {\n                        break;\n                    }\n                    // regenerate random arguments for row\n                    arz.setColumn(k, randn(dimension));\n                }\n                copyColumn(arxk, 0, arx, k);\n                try {\n                    fitness[k] = fitfun.value(arx.getColumn(k)); // compute fitness\n                } catch (TooManyEvaluationsException e) {\n                    break generationLoop;\n                }\n            }\n            // Sort by fitness and compute weighted mean into xmean\n            final int[] arindex = sortedIndices(fitness);\n            // Calculate new xmean, this is selection and recombination\n            final RealMatrix xold = xmean; // for speed up of Eq. (2) and (3)\n            final RealMatrix bestArx = selectColumns(arx, MathArrays.copyOf(arindex, mu));\n            xmean = bestArx.multiply(weights);\n            final RealMatrix bestArz = selectColumns(arz, MathArrays.copyOf(arindex, mu));\n            final RealMatrix zmean = bestArz.multiply(weights);\n            final boolean hsig = updateEvolutionPaths(zmean, xold);\n            if (diagonalOnly <= 0) {\n                updateCovariance(hsig, bestArx, arz, arindex, xold);\n            } else {\n                updateCovarianceDiagonalOnly(hsig, bestArz);\n            }\n            // Adapt step size sigma - Eq. (5)\n            sigma *= Math.exp(Math.min(1, (normps/chiN - 1) * cs / damps));\n            final double bestFitness = fitness[arindex[0]];\n            final double worstFitness = fitness[arindex[arindex.length - 1]];\n            if (bestValue > bestFitness) {\n                bestValue = bestFitness;\n                lastResult = optimum;\n                optimum = new PointValuePair(fitfun.repair(bestArx.getColumn(0)),\n                                             isMinimize ? bestFitness : -bestFitness);\n                if (getConvergenceChecker() != null &&\n                    lastResult != null) {\n                    if (getConvergenceChecker().converged(iterations, optimum, lastResult)) {\n                        break generationLoop;\n                    }\n                }\n            }\n            // handle termination criteria\n            // Break, if fitness is good enough\n            if (stopFitness != 0) { // only if stopFitness is defined\n                if (bestFitness < (isMinimize ? stopFitness : -stopFitness)) {\n                    break generationLoop;\n                }\n            }\n            final double[] sqrtDiagC = sqrt(diagC).getColumn(0);\n            final double[] pcCol = pc.getColumn(0);\n            for (int i = 0; i < dimension; i++) {\n                if (sigma * Math.max(Math.abs(pcCol[i]), sqrtDiagC[i]) > stopTolX) {\n                    break;\n                }\n                if (i >= dimension - 1) {\n                    break generationLoop;\n                }\n            }\n            for (int i = 0; i < dimension; i++) {\n                if (sigma * sqrtDiagC[i] > stopTolUpX) {\n                    break generationLoop;\n                }\n            }\n            final double historyBest = min(fitnessHistory);\n            final double historyWorst = max(fitnessHistory);\n            if (iterations > 2 &&\n                Math.max(historyWorst, worstFitness) -\n                Math.min(historyBest, bestFitness) < stopTolFun) {\n                break generationLoop;\n            }\n            if (iterations > fitnessHistory.length &&\n                historyWorst - historyBest < stopTolHistFun) {\n                break generationLoop;\n            }\n            // condition number of the covariance matrix exceeds 1e14\n            if (max(diagD) / min(diagD) > 1e7) {\n                break generationLoop;\n            }\n            // user defined termination\n            if (getConvergenceChecker() != null) {\n                final PointValuePair current\n                    = new PointValuePair(bestArx.getColumn(0),\n                                         isMinimize ? bestFitness : -bestFitness);\n                if (lastResult != null &&\n                    getConvergenceChecker().converged(iterations, current, lastResult)) {\n                    break generationLoop;\n                    }\n                lastResult = current;\n            }\n            // Adjust step size in case of equal function values (flat fitness)\n            if (bestValue == fitness[arindex[(int)(0.1+lambda/4.)]]) {\n                sigma = sigma * Math.exp(0.2 + cs / damps);\n            }\n            if (iterations > 2 && Math.max(historyWorst, bestFitness) -\n                Math.min(historyBest, bestFitness) == 0) {\n                sigma = sigma * Math.exp(0.2 + cs / damps);\n            }\n            // store best in history\n            push(fitnessHistory,bestFitness);\n            fitfun.setValueRange(worstFitness-bestFitness);\n            if (generateStatistics) {\n                statisticsSigmaHistory.add(sigma);\n                statisticsFitnessHistory.add(bestFitness);\n                statisticsMeanHistory.add(xmean.transpose());\n                statisticsDHistory.add(diagD.transpose().scalarMultiply(1E5));\n            }\n        }\n        return optimum;\n    }",
        "javadoc": "/**\n * {@inheritDoc}\n */\n"
      },
      "3": {
        "start_line": 172,
        "end_line": 268,
        "file": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizer.java",
        "code": "@Override\n    protected PointValuePair doOptimize() {\n        checkParameters();\n\n        final GoalType goal = getGoalType();\n        final double[] guess = getStartPoint();\n        final int n = guess.length;\n\n        final double[][] direc = new double[n][n];\n        for (int i = 0; i < n; i++) {\n            direc[i][i] = 1;\n        }\n\n        final ConvergenceChecker<PointValuePair> checker\n            = getConvergenceChecker();\n\n        double[] x = guess;\n        double fVal = computeObjectiveValue(x);\n        double[] x1 = x.clone();\n        int iter = 0;\n        while (true) {\n            ++iter;\n\n            double fX = fVal;\n            double fX2 = 0;\n            double delta = 0;\n            int bigInd = 0;\n            double alphaMin = 0;\n\n            for (int i = 0; i < n; i++) {\n                final double[] d = MathArrays.copyOf(direc[i]);\n\n                fX2 = fVal;\n\n                final UnivariatePointValuePair optimum = line.search(x, d);\n                fVal = optimum.getValue();\n                alphaMin = optimum.getPoint();\n                final double[][] result = newPointAndDirection(x, d, alphaMin);\n                x = result[0];\n\n                if ((fX2 - fVal) > delta) {\n                    delta = fX2 - fVal;\n                    bigInd = i;\n                }\n            }\n\n            // Default convergence check.\n            boolean stop = 2 * (fX - fVal) <=\n                (relativeThreshold * (FastMath.abs(fX) + FastMath.abs(fVal)) +\n                 absoluteThreshold);\n\n            final PointValuePair previous = new PointValuePair(x1, fX);\n            final PointValuePair current = new PointValuePair(x, fVal);\n            if (!stop) { // User-defined stopping criteria.\n                if (checker != null) {\n                    stop = checker.converged(iter, previous, current);\n                }\n            }\n            if (stop) {\n                if (goal == GoalType.MINIMIZE) {\n                    return (fVal < fX) ? current : previous;\n                } else {\n                    return (fVal > fX) ? current : previous;\n                }\n            }\n\n            final double[] d = new double[n];\n            final double[] x2 = new double[n];\n            for (int i = 0; i < n; i++) {\n                d[i] = x[i] - x1[i];\n                x2[i] = 2 * x[i] - x1[i];\n            }\n\n            x1 = x.clone();\n            fX2 = computeObjectiveValue(x2);\n\n            if (fX > fX2) {\n                double t = 2 * (fX + fX2 - 2 * fVal);\n                double temp = fX - fVal - delta;\n                t *= temp * temp;\n                temp = fX - fX2;\n                t -= delta * temp * temp;\n\n                if (t < 0.0) {\n                    final UnivariatePointValuePair optimum = line.search(x, d);\n                    fVal = optimum.getValue();\n                    alphaMin = optimum.getPoint();\n                    final double[][] result = newPointAndDirection(x, d, alphaMin);\n                    x = result[0];\n\n                    final int lastInd = n - 1;\n                    direc[bigInd] = direc[lastInd];\n                    direc[lastInd] = result[1];\n                }\n            }\n        }\n    }",
        "javadoc": "/**\n * {@inheritDoc}\n */\n"
      },
      "4": {
        "start_line": 126,
        "end_line": 177,
        "file": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizer.java",
        "code": "@Override\n    protected PointValuePair doOptimize() {\n        checkParameters();\n\n        // Indirect call to \"computeObjectiveValue\" in order to update the\n        // evaluations counter.\n        final MultivariateFunction evalFunc\n            = new MultivariateFunction() {\n                public double value(double[] point) {\n                    return computeObjectiveValue(point);\n                }\n            };\n\n        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n        final Comparator<PointValuePair> comparator\n            = new Comparator<PointValuePair>() {\n            public int compare(final PointValuePair o1,\n                               final PointValuePair o2) {\n                final double v1 = o1.getValue();\n                final double v2 = o2.getValue();\n                return isMinim ? Double.compare(v1, v2) : Double.compare(v2, v1);\n            }\n        };\n\n        // Initialize search.\n        simplex.build(getStartPoint());\n        simplex.evaluate(evalFunc, comparator);\n\n        PointValuePair[] previous = null;\n        int iteration = 0;\n        final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();\n        while (true) {\n            if (iteration > 0) {\n                boolean converged = true;\n                for (int i = 0; i < simplex.getSize(); i++) {\n                    PointValuePair prev = previous[i];\n                    converged = converged &&\n                        checker.converged(iteration, prev, simplex.getPoint(i));\n                }\n                if (converged) {\n                    // We have found an optimum.\n                    return simplex.getPoint(0);\n                }\n            }\n\n            // We still need to search.\n            previous = simplex.getPoints();\n            simplex.iterate(evalFunc, comparator);\n\n\t\t\t++iteration;\n        }\n    }",
        "javadoc": "/**\n * {@inheritDoc}\n */\n"
      },
      "5": {
        "start_line": 79,
        "end_line": 169,
        "file": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizer.java",
        "code": "@Override\n    public PointVectorValuePair doOptimize() {\n        checkParameters();\n\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStartPoint();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        int iter = 0;\n        for (boolean converged = false; !converged;) {\n            ++iter;\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\n                    double wgk = weight * grad[k];\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(iter, previous, current);\n                if (converged) {\n                    setCost(computeCost(currentResiduals));\n                    return current;\n                }\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
        "javadoc": "/**\n * {@inheritDoc}\n */\n"
      },
      "6": {
        "start_line": 283,
        "end_line": 534,
        "file": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java",
        "code": "@Override\n    protected PointVectorValuePair doOptimize() {\n        checkParameters();\n\n        final int nR = getTarget().length; // Number of observed data.\n        final double[] currentPoint = getStartPoint();\n        final int nC = currentPoint.length; // Number of parameters.\n\n        // arrays shared with the other private methods\n        solvedCols  = FastMath.min(nR, nC);\n        diagR       = new double[nC];\n        jacNorm     = new double[nC];\n        beta        = new double[nC];\n        permutation = new int[nC];\n        lmDir       = new double[nC];\n\n        // local point\n        double   delta   = 0;\n        double   xNorm   = 0;\n        double[] diag    = new double[nC];\n        double[] oldX    = new double[nC];\n        double[] oldRes  = new double[nR];\n        double[] oldObj  = new double[nR];\n        double[] qtf     = new double[nR];\n        double[] work1   = new double[nC];\n        double[] work2   = new double[nC];\n        double[] work3   = new double[nC];\n\n        final RealMatrix weightMatrixSqrt = getWeightSquareRoot();\n\n        // Evaluate the function at the starting point and calculate its norm.\n        double[] currentObjective = computeObjectiveValue(currentPoint);\n        double[] currentResiduals = computeResiduals(currentObjective);\n        PointVectorValuePair current = new PointVectorValuePair(currentPoint, currentObjective);\n        double currentCost = computeCost(currentResiduals);\n\n        // Outer loop.\n        lmPar = 0;\n        boolean firstIteration = true;\n        int iter = 0;\n        final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker();\n        while (true) {\n            ++iter;\n            final PointVectorValuePair previous = current;\n\n            // QR decomposition of the jacobian matrix\n            qrDecomposition(computeWeightedJacobian(currentPoint));\n\n            weightedResidual = weightMatrixSqrt.operate(currentResiduals);\n            for (int i = 0; i < nR; i++) {\n                qtf[i] = weightedResidual[i];\n            }\n\n            // compute Qt.res\n            qTy(qtf);\n\n            // now we don't need Q anymore,\n            // so let jacobian contain the R matrix with its diagonal elements\n            for (int k = 0; k < solvedCols; ++k) {\n                int pk = permutation[k];\n                weightedJacobian[k][pk] = diagR[pk];\n            }\n\n            if (firstIteration) {\n                // scale the point according to the norms of the columns\n                // of the initial jacobian\n                xNorm = 0;\n                for (int k = 0; k < nC; ++k) {\n                    double dk = jacNorm[k];\n                    if (dk == 0) {\n                        dk = 1.0;\n                    }\n                    double xk = dk * currentPoint[k];\n                    xNorm  += xk * xk;\n                    diag[k] = dk;\n                }\n                xNorm = FastMath.sqrt(xNorm);\n\n                // initialize the step bound delta\n                delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n            }\n\n            // check orthogonality between function vector and jacobian columns\n            double maxCosine = 0;\n            if (currentCost != 0) {\n                for (int j = 0; j < solvedCols; ++j) {\n                    int    pj = permutation[j];\n                    double s  = jacNorm[pj];\n                    if (s != 0) {\n                        double sum = 0;\n                        for (int i = 0; i <= j; ++i) {\n                            sum += weightedJacobian[i][pj] * qtf[i];\n                        }\n                        maxCosine = FastMath.max(maxCosine, FastMath.abs(sum) / (s * currentCost));\n                    }\n                }\n            }\n            if (maxCosine <= orthoTolerance) {\n                // Convergence has been reached.\n                setCost(currentCost);\n                return current;\n            }\n\n            // rescale if necessary\n            for (int j = 0; j < nC; ++j) {\n                diag[j] = FastMath.max(diag[j], jacNorm[j]);\n            }\n\n            // Inner loop.\n            for (double ratio = 0; ratio < 1.0e-4;) {\n\n                // save the state\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    oldX[pj] = currentPoint[pj];\n                }\n                final double previousCost = currentCost;\n                double[] tmpVec = weightedResidual;\n                weightedResidual = oldRes;\n                oldRes    = tmpVec;\n                tmpVec    = currentObjective;\n                currentObjective = oldObj;\n                oldObj    = tmpVec;\n\n                // determine the Levenberg-Marquardt parameter\n                determineLMParameter(qtf, delta, diag, work1, work2, work3);\n\n                // compute the new point and the norm of the evolution direction\n                double lmNorm = 0;\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    lmDir[pj] = -lmDir[pj];\n                    currentPoint[pj] = oldX[pj] + lmDir[pj];\n                    double s = diag[pj] * lmDir[pj];\n                    lmNorm  += s * s;\n                }\n                lmNorm = FastMath.sqrt(lmNorm);\n                // on the first iteration, adjust the initial step bound.\n                if (firstIteration) {\n                    delta = FastMath.min(delta, lmNorm);\n                }\n\n                // Evaluate the function at x + p and calculate its norm.\n                currentObjective = computeObjectiveValue(currentPoint);\n                currentResiduals = computeResiduals(currentObjective);\n                current = new PointVectorValuePair(currentPoint, currentObjective);\n                currentCost = computeCost(currentResiduals);\n\n                // compute the scaled actual reduction\n                double actRed = -1.0;\n                if (0.1 * currentCost < previousCost) {\n                    double r = currentCost / previousCost;\n                    actRed = 1.0 - r * r;\n                }\n\n                // compute the scaled predicted reduction\n                // and the scaled directional derivative\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    double dirJ = lmDir[pj];\n                    work1[j] = 0;\n                    for (int i = 0; i <= j; ++i) {\n                        work1[i] += weightedJacobian[i][pj] * dirJ;\n                    }\n                }\n                double coeff1 = 0;\n                for (int j = 0; j < solvedCols; ++j) {\n                    coeff1 += work1[j] * work1[j];\n                }\n                double pc2 = previousCost * previousCost;\n                coeff1 = coeff1 / pc2;\n                double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n                double preRed = coeff1 + 2 * coeff2;\n                double dirDer = -(coeff1 + coeff2);\n\n                // ratio of the actual to the predicted reduction\n                ratio = (preRed == 0) ? 0 : (actRed / preRed);\n\n                // update the step bound\n                if (ratio <= 0.25) {\n                    double tmp =\n                        (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                        if ((0.1 * currentCost >= previousCost) || (tmp < 0.1)) {\n                            tmp = 0.1;\n                        }\n                        delta = tmp * FastMath.min(delta, 10.0 * lmNorm);\n                        lmPar /= tmp;\n                } else if ((lmPar == 0) || (ratio >= 0.75)) {\n                    delta = 2 * lmNorm;\n                    lmPar *= 0.5;\n                }\n\n                // test for successful iteration.\n                if (ratio >= 1.0e-4) {\n                    // successful iteration, update the norm\n                    firstIteration = false;\n                    xNorm = 0;\n                    for (int k = 0; k < nC; ++k) {\n                        double xK = diag[k] * currentPoint[k];\n                        xNorm += xK * xK;\n                    }\n                    xNorm = FastMath.sqrt(xNorm);\n\n                    // tests for convergence.\n                    if (checker != null) {\n                        // we use the vectorial convergence checker\n                        if (checker.converged(iter, previous, current)) {\n                            setCost(currentCost);\n                            return current;\n                        }\n                    }\n                } else {\n                    // failed iteration, reset the previous values\n                    currentCost = previousCost;\n                    for (int j = 0; j < solvedCols; ++j) {\n                        int pj = permutation[j];\n                        currentPoint[pj] = oldX[pj];\n                    }\n                    tmpVec    = weightedResidual;\n                    weightedResidual = oldRes;\n                    oldRes    = tmpVec;\n                    tmpVec    = currentObjective;\n                    currentObjective = oldObj;\n                    oldObj    = tmpVec;\n                    // Reset \"current\" to previous values.\n                    current = new PointVectorValuePair(currentPoint, currentObjective);\n                }\n\n                // Default convergence criteria.\n                if ((FastMath.abs(actRed) <= costRelativeTolerance &&\n                     preRed <= costRelativeTolerance &&\n                     ratio <= 2.0) ||\n                    delta <= parRelativeTolerance * xNorm) {\n                    setCost(currentCost);\n                    return current;\n                }\n\n                // tests for termination and stringent tolerances\n                // (2.2204e-16 is the machine epsilon for IEEE754)\n                if ((FastMath.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n                    throw new ConvergenceException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE,\n                                                   costRelativeTolerance);\n                } else if (delta <= 2.2204e-16 * xNorm) {\n                    throw new ConvergenceException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE,\n                                                   parRelativeTolerance);\n                } else if (maxCosine <= 2.2204e-16)  {\n                    throw new ConvergenceException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE,\n                                                   orthoTolerance);\n                }\n            }\n        }\n    }",
        "javadoc": "/**\n * {@inheritDoc}\n */\n"
      }
    },
    "delineated_bug": {
      "0": {
        "start_line": 47,
        "end_line": 52,
        "file": "src/main/java/org/apache/commons/math3/optim/BaseOptimizer.java",
        "code": "protected BaseOptimizer(ConvergenceChecker<PAIR> checker) {\n        this.checker = checker;\n\n        evaluations = new Incrementor(0, new MaxEvalCallback());\n<START_BUG>\n        iterations = new Incrementor(0, new MaxIterCallback());\n<END_BUG>\n    }",
        "javadoc": "/**\n * @param checker Convergence checker.\n */\n"
      },
      "1": {
        "start_line": 191,
        "end_line": 288,
        "file": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer.java",
        "code": "@Override\n    protected PointValuePair doOptimize() {\n        final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();\n        final double[] point = getStartPoint();\n        final GoalType goal = getGoalType();\n        final int n = point.length;\n        double[] r = computeObjectiveGradient(point);\n        if (goal == GoalType.MINIMIZE) {\n            for (int i = 0; i < n; i++) {\n                r[i] = -r[i];\n            }\n        }\n\n        // Initial search direction.\n        double[] steepestDescent = preconditioner.precondition(point, r);\n        double[] searchDirection = steepestDescent.clone();\n\n        double delta = 0;\n        for (int i = 0; i < n; ++i) {\n            delta += r[i] * searchDirection[i];\n        }\n\n        PointValuePair current = null;\n<START_BUG>\n        int iter = 0;\n        int maxEval = getMaxEvaluations();\n        while (true) {\n            ++iter;\n\n            final double objective = computeObjectiveValue(point);\n            PointValuePair previous = current;\n            current = new PointValuePair(point, objective);\n            if (previous != null) {\n                if (checker.converged(iter, previous, current)) {\n<END_BUG>\n                    // We have found an optimum.\n                    return current;\n                }\n            }\n\n            // Find the optimal step in the search direction.\n            final UnivariateFunction lsf = new LineSearchFunction(point, searchDirection);\n            final double uB = findUpperBound(lsf, 0, initialStep);\n            // XXX Last parameters is set to a value close to zero in order to\n            // work around the divergence problem in the \"testCircleFitting\"\n            // unit test (see MATH-439).\n            final double step = solver.solve(maxEval, lsf, 0, uB, 1e-15);\n            maxEval -= solver.getEvaluations(); // Subtract used up evaluations.\n\n            // Validate new point.\n            for (int i = 0; i < point.length; ++i) {\n                point[i] += step * searchDirection[i];\n            }\n\n            r = computeObjectiveGradient(point);\n            if (goal == GoalType.MINIMIZE) {\n                for (int i = 0; i < n; ++i) {\n                    r[i] = -r[i];\n                }\n            }\n\n            // Compute beta.\n            final double deltaOld = delta;\n            final double[] newSteepestDescent = preconditioner.precondition(point, r);\n            delta = 0;\n            for (int i = 0; i < n; ++i) {\n                delta += r[i] * newSteepestDescent[i];\n            }\n\n            final double beta;\n            switch (updateFormula) {\n            case FLETCHER_REEVES:\n                beta = delta / deltaOld;\n                break;\n            case POLAK_RIBIERE:\n                double deltaMid = 0;\n                for (int i = 0; i < r.length; ++i) {\n                    deltaMid += r[i] * steepestDescent[i];\n                }\n                beta = (delta - deltaMid) / deltaOld;\n                break;\n            default:\n                // Should never happen.\n                throw new MathInternalError();\n            }\n            steepestDescent = newSteepestDescent;\n\n            // Compute conjugate search direction.\n<START_BUG>\n            if (iter % n == 0 ||\n<END_BUG>\n                beta < 0) {\n                // Break conjugation: reset search direction.\n                searchDirection = steepestDescent.clone();\n            } else {\n                // Compute new conjugate search direction.\n                for (int i = 0; i < n; ++i) {\n                    searchDirection[i] = steepestDescent[i] + beta * searchDirection[i];\n                }\n            }\n        }\n    }",
        "javadoc": "/**\n * {@inheritDoc}\n */\n"
      },
      "2": {
        "start_line": 367,
        "end_line": 515,
        "file": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java",
        "code": "@Override\n    protected PointValuePair doOptimize() {\n         // -------------------- Initialization --------------------------------\n        isMinimize = getGoalType().equals(GoalType.MINIMIZE);\n        final FitnessFunction fitfun = new FitnessFunction();\n        final double[] guess = getStartPoint();\n        // number of objective variables/problem dimension\n        dimension = guess.length;\n        initializeCMA(guess);\n        iterations = 0;\n        double bestValue = fitfun.value(guess);\n        push(fitnessHistory, bestValue);\n        PointValuePair optimum\n            = new PointValuePair(getStartPoint(),\n                                 isMinimize ? bestValue : -bestValue);\n        PointValuePair lastResult = null;\n\n        // -------------------- Generation Loop --------------------------------\n\n        generationLoop:\n        for (iterations = 1; iterations <= maxIterations; iterations++) {\n<END_BUG>\n<START_BUG>\n\n            // Generate and evaluate lambda offspring\n            final RealMatrix arz = randn1(dimension, lambda);\n            final RealMatrix arx = zeros(dimension, lambda);\n            final double[] fitness = new double[lambda];\n            // generate random offspring\n            for (int k = 0; k < lambda; k++) {\n                RealMatrix arxk = null;\n                for (int i = 0; i < checkFeasableCount + 1; i++) {\n                    if (diagonalOnly <= 0) {\n                        arxk = xmean.add(BD.multiply(arz.getColumnMatrix(k))\n                                         .scalarMultiply(sigma)); // m + sig * Normal(0,C)\n                    } else {\n                        arxk = xmean.add(times(diagD,arz.getColumnMatrix(k))\n                                         .scalarMultiply(sigma));\n                    }\n                    if (i >= checkFeasableCount ||\n                        fitfun.isFeasible(arxk.getColumn(0))) {\n                        break;\n                    }\n                    // regenerate random arguments for row\n                    arz.setColumn(k, randn(dimension));\n                }\n                copyColumn(arxk, 0, arx, k);\n                try {\n                    fitness[k] = fitfun.value(arx.getColumn(k)); // compute fitness\n                } catch (TooManyEvaluationsException e) {\n                    break generationLoop;\n                }\n            }\n            // Sort by fitness and compute weighted mean into xmean\n            final int[] arindex = sortedIndices(fitness);\n            // Calculate new xmean, this is selection and recombination\n            final RealMatrix xold = xmean; // for speed up of Eq. (2) and (3)\n            final RealMatrix bestArx = selectColumns(arx, MathArrays.copyOf(arindex, mu));\n            xmean = bestArx.multiply(weights);\n            final RealMatrix bestArz = selectColumns(arz, MathArrays.copyOf(arindex, mu));\n            final RealMatrix zmean = bestArz.multiply(weights);\n            final boolean hsig = updateEvolutionPaths(zmean, xold);\n            if (diagonalOnly <= 0) {\n                updateCovariance(hsig, bestArx, arz, arindex, xold);\n            } else {\n                updateCovarianceDiagonalOnly(hsig, bestArz);\n            }\n            // Adapt step size sigma - Eq. (5)\n            sigma *= Math.exp(Math.min(1, (normps/chiN - 1) * cs / damps));\n            final double bestFitness = fitness[arindex[0]];\n            final double worstFitness = fitness[arindex[arindex.length - 1]];\n            if (bestValue > bestFitness) {\n                bestValue = bestFitness;\n                lastResult = optimum;\n                optimum = new PointValuePair(fitfun.repair(bestArx.getColumn(0)),\n                                             isMinimize ? bestFitness : -bestFitness);\n                if (getConvergenceChecker() != null &&\n                    lastResult != null) {\n                    if (getConvergenceChecker().converged(iterations, optimum, lastResult)) {\n                        break generationLoop;\n                    }\n                }\n            }\n            // handle termination criteria\n            // Break, if fitness is good enough\n            if (stopFitness != 0) { // only if stopFitness is defined\n                if (bestFitness < (isMinimize ? stopFitness : -stopFitness)) {\n                    break generationLoop;\n                }\n            }\n            final double[] sqrtDiagC = sqrt(diagC).getColumn(0);\n            final double[] pcCol = pc.getColumn(0);\n            for (int i = 0; i < dimension; i++) {\n                if (sigma * Math.max(Math.abs(pcCol[i]), sqrtDiagC[i]) > stopTolX) {\n                    break;\n                }\n                if (i >= dimension - 1) {\n                    break generationLoop;\n                }\n            }\n            for (int i = 0; i < dimension; i++) {\n                if (sigma * sqrtDiagC[i] > stopTolUpX) {\n                    break generationLoop;\n                }\n            }\n            final double historyBest = min(fitnessHistory);\n            final double historyWorst = max(fitnessHistory);\n            if (iterations > 2 &&\n                Math.max(historyWorst, worstFitness) -\n                Math.min(historyBest, bestFitness) < stopTolFun) {\n                break generationLoop;\n            }\n            if (iterations > fitnessHistory.length &&\n                historyWorst - historyBest < stopTolHistFun) {\n                break generationLoop;\n            }\n            // condition number of the covariance matrix exceeds 1e14\n            if (max(diagD) / min(diagD) > 1e7) {\n                break generationLoop;\n            }\n            // user defined termination\n            if (getConvergenceChecker() != null) {\n                final PointValuePair current\n                    = new PointValuePair(bestArx.getColumn(0),\n                                         isMinimize ? bestFitness : -bestFitness);\n                if (lastResult != null &&\n                    getConvergenceChecker().converged(iterations, current, lastResult)) {\n                    break generationLoop;\n                    }\n                lastResult = current;\n            }\n            // Adjust step size in case of equal function values (flat fitness)\n            if (bestValue == fitness[arindex[(int)(0.1+lambda/4.)]]) {\n                sigma = sigma * Math.exp(0.2 + cs / damps);\n            }\n            if (iterations > 2 && Math.max(historyWorst, bestFitness) -\n                Math.min(historyBest, bestFitness) == 0) {\n                sigma = sigma * Math.exp(0.2 + cs / damps);\n            }\n            // store best in history\n            push(fitnessHistory,bestFitness);\n            fitfun.setValueRange(worstFitness-bestFitness);\n            if (generateStatistics) {\n                statisticsSigmaHistory.add(sigma);\n                statisticsFitnessHistory.add(bestFitness);\n                statisticsMeanHistory.add(xmean.transpose());\n                statisticsDHistory.add(diagD.transpose().scalarMultiply(1E5));\n            }\n        }\n        return optimum;\n    }",
        "javadoc": "/**\n * {@inheritDoc}\n */\n"
      },
      "3": {
        "start_line": 172,
        "end_line": 268,
        "file": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizer.java",
        "code": "@Override\n    protected PointValuePair doOptimize() {\n        checkParameters();\n\n        final GoalType goal = getGoalType();\n        final double[] guess = getStartPoint();\n        final int n = guess.length;\n\n        final double[][] direc = new double[n][n];\n        for (int i = 0; i < n; i++) {\n            direc[i][i] = 1;\n        }\n\n        final ConvergenceChecker<PointValuePair> checker\n            = getConvergenceChecker();\n\n        double[] x = guess;\n        double fVal = computeObjectiveValue(x);\n        double[] x1 = x.clone();\n<START_BUG>\n        int iter = 0;\n        while (true) {\n            ++iter;\n<END_BUG>\n\n            double fX = fVal;\n            double fX2 = 0;\n            double delta = 0;\n            int bigInd = 0;\n            double alphaMin = 0;\n\n            for (int i = 0; i < n; i++) {\n                final double[] d = MathArrays.copyOf(direc[i]);\n\n                fX2 = fVal;\n\n                final UnivariatePointValuePair optimum = line.search(x, d);\n                fVal = optimum.getValue();\n                alphaMin = optimum.getPoint();\n                final double[][] result = newPointAndDirection(x, d, alphaMin);\n                x = result[0];\n\n                if ((fX2 - fVal) > delta) {\n                    delta = fX2 - fVal;\n                    bigInd = i;\n                }\n            }\n\n            // Default convergence check.\n            boolean stop = 2 * (fX - fVal) <=\n                (relativeThreshold * (FastMath.abs(fX) + FastMath.abs(fVal)) +\n                 absoluteThreshold);\n\n            final PointValuePair previous = new PointValuePair(x1, fX);\n            final PointValuePair current = new PointValuePair(x, fVal);\n            if (!stop) { // User-defined stopping criteria.\n                if (checker != null) {\n<START_BUG>\n                    stop = checker.converged(iter, previous, current);\n<END_BUG>\n                }\n            }\n            if (stop) {\n                if (goal == GoalType.MINIMIZE) {\n                    return (fVal < fX) ? current : previous;\n                } else {\n                    return (fVal > fX) ? current : previous;\n                }\n            }\n\n            final double[] d = new double[n];\n            final double[] x2 = new double[n];\n            for (int i = 0; i < n; i++) {\n                d[i] = x[i] - x1[i];\n                x2[i] = 2 * x[i] - x1[i];\n            }\n\n            x1 = x.clone();\n            fX2 = computeObjectiveValue(x2);\n\n            if (fX > fX2) {\n                double t = 2 * (fX + fX2 - 2 * fVal);\n                double temp = fX - fVal - delta;\n                t *= temp * temp;\n                temp = fX - fX2;\n                t -= delta * temp * temp;\n\n                if (t < 0.0) {\n                    final UnivariatePointValuePair optimum = line.search(x, d);\n                    fVal = optimum.getValue();\n                    alphaMin = optimum.getPoint();\n                    final double[][] result = newPointAndDirection(x, d, alphaMin);\n                    x = result[0];\n\n                    final int lastInd = n - 1;\n                    direc[bigInd] = direc[lastInd];\n                    direc[lastInd] = result[1];\n                }\n            }\n        }\n    }",
        "javadoc": "/**\n * {@inheritDoc}\n */\n"
      },
      "4": {
        "start_line": 126,
        "end_line": 177,
        "file": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizer.java",
        "code": "@Override\n    protected PointValuePair doOptimize() {\n        checkParameters();\n\n        // Indirect call to \"computeObjectiveValue\" in order to update the\n        // evaluations counter.\n        final MultivariateFunction evalFunc\n            = new MultivariateFunction() {\n                public double value(double[] point) {\n                    return computeObjectiveValue(point);\n                }\n            };\n\n        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n        final Comparator<PointValuePair> comparator\n            = new Comparator<PointValuePair>() {\n            public int compare(final PointValuePair o1,\n                               final PointValuePair o2) {\n                final double v1 = o1.getValue();\n                final double v2 = o2.getValue();\n                return isMinim ? Double.compare(v1, v2) : Double.compare(v2, v1);\n            }\n        };\n\n        // Initialize search.\n        simplex.build(getStartPoint());\n        simplex.evaluate(evalFunc, comparator);\n\n        PointValuePair[] previous = null;\n        int iteration = 0;\n        final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();\n        while (true) {\n<START_BUG>\n            if (iteration > 0) {\n<END_BUG>\n                boolean converged = true;\n                for (int i = 0; i < simplex.getSize(); i++) {\n                    PointValuePair prev = previous[i];\n                    converged = converged &&\n                        checker.converged(iteration, prev, simplex.getPoint(i));\n                }\n                if (converged) {\n                    // We have found an optimum.\n                    return simplex.getPoint(0);\n                }\n            }\n\n            // We still need to search.\n            previous = simplex.getPoints();\n            simplex.iterate(evalFunc, comparator);\n\n<START_BUG>\n\t\t\t++iteration;\n<END_BUG>\n        }\n    }",
        "javadoc": "/**\n * {@inheritDoc}\n */\n"
      },
      "5": {
        "start_line": 79,
        "end_line": 169,
        "file": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizer.java",
        "code": "@Override\n    public PointVectorValuePair doOptimize() {\n        checkParameters();\n\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStartPoint();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n<START_BUG>\n        int iter = 0;\n        for (boolean converged = false; !converged;) {\n            ++iter;\n<END_BUG>\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\n                    double wgk = weight * grad[k];\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n\n            // Check convergence.\n            if (previous != null) {\n<START_BUG>\n                converged = checker.converged(iter, previous, current);\n<END_BUG>\n                if (converged) {\n                    setCost(computeCost(currentResiduals));\n                    return current;\n                }\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
        "javadoc": "/**\n * {@inheritDoc}\n */\n"
      },
      "6": {
        "start_line": 283,
        "end_line": 534,
        "file": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java",
        "code": "@Override\n    protected PointVectorValuePair doOptimize() {\n        checkParameters();\n\n        final int nR = getTarget().length; // Number of observed data.\n        final double[] currentPoint = getStartPoint();\n        final int nC = currentPoint.length; // Number of parameters.\n\n        // arrays shared with the other private methods\n        solvedCols  = FastMath.min(nR, nC);\n        diagR       = new double[nC];\n        jacNorm     = new double[nC];\n        beta        = new double[nC];\n        permutation = new int[nC];\n        lmDir       = new double[nC];\n\n        // local point\n        double   delta   = 0;\n        double   xNorm   = 0;\n        double[] diag    = new double[nC];\n        double[] oldX    = new double[nC];\n        double[] oldRes  = new double[nR];\n        double[] oldObj  = new double[nR];\n        double[] qtf     = new double[nR];\n        double[] work1   = new double[nC];\n        double[] work2   = new double[nC];\n        double[] work3   = new double[nC];\n\n        final RealMatrix weightMatrixSqrt = getWeightSquareRoot();\n\n        // Evaluate the function at the starting point and calculate its norm.\n        double[] currentObjective = computeObjectiveValue(currentPoint);\n        double[] currentResiduals = computeResiduals(currentObjective);\n        PointVectorValuePair current = new PointVectorValuePair(currentPoint, currentObjective);\n        double currentCost = computeCost(currentResiduals);\n\n        // Outer loop.\n        lmPar = 0;\n        boolean firstIteration = true;\n<START_BUG>\n        int iter = 0;\n        final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker();\n        while (true) {\n            ++iter;\n<END_BUG>\n            final PointVectorValuePair previous = current;\n\n            // QR decomposition of the jacobian matrix\n            qrDecomposition(computeWeightedJacobian(currentPoint));\n\n            weightedResidual = weightMatrixSqrt.operate(currentResiduals);\n            for (int i = 0; i < nR; i++) {\n                qtf[i] = weightedResidual[i];\n            }\n\n            // compute Qt.res\n            qTy(qtf);\n\n            // now we don't need Q anymore,\n            // so let jacobian contain the R matrix with its diagonal elements\n            for (int k = 0; k < solvedCols; ++k) {\n                int pk = permutation[k];\n                weightedJacobian[k][pk] = diagR[pk];\n            }\n\n            if (firstIteration) {\n                // scale the point according to the norms of the columns\n                // of the initial jacobian\n                xNorm = 0;\n                for (int k = 0; k < nC; ++k) {\n                    double dk = jacNorm[k];\n                    if (dk == 0) {\n                        dk = 1.0;\n                    }\n                    double xk = dk * currentPoint[k];\n                    xNorm  += xk * xk;\n                    diag[k] = dk;\n                }\n                xNorm = FastMath.sqrt(xNorm);\n\n                // initialize the step bound delta\n                delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n            }\n\n            // check orthogonality between function vector and jacobian columns\n            double maxCosine = 0;\n            if (currentCost != 0) {\n                for (int j = 0; j < solvedCols; ++j) {\n                    int    pj = permutation[j];\n                    double s  = jacNorm[pj];\n                    if (s != 0) {\n                        double sum = 0;\n                        for (int i = 0; i <= j; ++i) {\n                            sum += weightedJacobian[i][pj] * qtf[i];\n                        }\n                        maxCosine = FastMath.max(maxCosine, FastMath.abs(sum) / (s * currentCost));\n                    }\n                }\n            }\n            if (maxCosine <= orthoTolerance) {\n                // Convergence has been reached.\n                setCost(currentCost);\n                return current;\n            }\n\n            // rescale if necessary\n            for (int j = 0; j < nC; ++j) {\n                diag[j] = FastMath.max(diag[j], jacNorm[j]);\n            }\n\n            // Inner loop.\n            for (double ratio = 0; ratio < 1.0e-4;) {\n\n                // save the state\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    oldX[pj] = currentPoint[pj];\n                }\n                final double previousCost = currentCost;\n                double[] tmpVec = weightedResidual;\n                weightedResidual = oldRes;\n                oldRes    = tmpVec;\n                tmpVec    = currentObjective;\n                currentObjective = oldObj;\n                oldObj    = tmpVec;\n\n                // determine the Levenberg-Marquardt parameter\n                determineLMParameter(qtf, delta, diag, work1, work2, work3);\n\n                // compute the new point and the norm of the evolution direction\n                double lmNorm = 0;\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    lmDir[pj] = -lmDir[pj];\n                    currentPoint[pj] = oldX[pj] + lmDir[pj];\n                    double s = diag[pj] * lmDir[pj];\n                    lmNorm  += s * s;\n                }\n                lmNorm = FastMath.sqrt(lmNorm);\n                // on the first iteration, adjust the initial step bound.\n                if (firstIteration) {\n                    delta = FastMath.min(delta, lmNorm);\n                }\n\n                // Evaluate the function at x + p and calculate its norm.\n                currentObjective = computeObjectiveValue(currentPoint);\n                currentResiduals = computeResiduals(currentObjective);\n                current = new PointVectorValuePair(currentPoint, currentObjective);\n                currentCost = computeCost(currentResiduals);\n\n                // compute the scaled actual reduction\n                double actRed = -1.0;\n                if (0.1 * currentCost < previousCost) {\n                    double r = currentCost / previousCost;\n                    actRed = 1.0 - r * r;\n                }\n\n                // compute the scaled predicted reduction\n                // and the scaled directional derivative\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    double dirJ = lmDir[pj];\n                    work1[j] = 0;\n                    for (int i = 0; i <= j; ++i) {\n                        work1[i] += weightedJacobian[i][pj] * dirJ;\n                    }\n                }\n                double coeff1 = 0;\n                for (int j = 0; j < solvedCols; ++j) {\n                    coeff1 += work1[j] * work1[j];\n                }\n                double pc2 = previousCost * previousCost;\n                coeff1 = coeff1 / pc2;\n                double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n                double preRed = coeff1 + 2 * coeff2;\n                double dirDer = -(coeff1 + coeff2);\n\n                // ratio of the actual to the predicted reduction\n                ratio = (preRed == 0) ? 0 : (actRed / preRed);\n\n                // update the step bound\n                if (ratio <= 0.25) {\n                    double tmp =\n                        (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                        if ((0.1 * currentCost >= previousCost) || (tmp < 0.1)) {\n                            tmp = 0.1;\n                        }\n                        delta = tmp * FastMath.min(delta, 10.0 * lmNorm);\n                        lmPar /= tmp;\n                } else if ((lmPar == 0) || (ratio >= 0.75)) {\n                    delta = 2 * lmNorm;\n                    lmPar *= 0.5;\n                }\n\n                // test for successful iteration.\n                if (ratio >= 1.0e-4) {\n                    // successful iteration, update the norm\n                    firstIteration = false;\n                    xNorm = 0;\n                    for (int k = 0; k < nC; ++k) {\n                        double xK = diag[k] * currentPoint[k];\n                        xNorm += xK * xK;\n                    }\n                    xNorm = FastMath.sqrt(xNorm);\n\n                    // tests for convergence.\n                    if (checker != null) {\n                        // we use the vectorial convergence checker\n<START_BUG>\n                        if (checker.converged(iter, previous, current)) {\n<END_BUG>\n                            setCost(currentCost);\n                            return current;\n                        }\n                    }\n                } else {\n                    // failed iteration, reset the previous values\n                    currentCost = previousCost;\n                    for (int j = 0; j < solvedCols; ++j) {\n                        int pj = permutation[j];\n                        currentPoint[pj] = oldX[pj];\n                    }\n                    tmpVec    = weightedResidual;\n                    weightedResidual = oldRes;\n                    oldRes    = tmpVec;\n                    tmpVec    = currentObjective;\n                    currentObjective = oldObj;\n                    oldObj    = tmpVec;\n                    // Reset \"current\" to previous values.\n                    current = new PointVectorValuePair(currentPoint, currentObjective);\n                }\n\n                // Default convergence criteria.\n                if ((FastMath.abs(actRed) <= costRelativeTolerance &&\n                     preRed <= costRelativeTolerance &&\n                     ratio <= 2.0) ||\n                    delta <= parRelativeTolerance * xNorm) {\n                    setCost(currentCost);\n                    return current;\n                }\n\n                // tests for termination and stringent tolerances\n                // (2.2204e-16 is the machine epsilon for IEEE754)\n                if ((FastMath.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n                    throw new ConvergenceException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE,\n                                                   costRelativeTolerance);\n                } else if (delta <= 2.2204e-16 * xNorm) {\n                    throw new ConvergenceException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE,\n                                                   parRelativeTolerance);\n                } else if (maxCosine <= 2.2204e-16)  {\n                    throw new ConvergenceException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE,\n                                                   orthoTolerance);\n                }\n            }\n        }\n    }",
        "javadoc": "/**\n * {@inheritDoc}\n */\n"
      }
    },
    "contained_scope": "method",
    "bug_count": 7,
    "triggered_tests": {
      "0": {
        "test_path": "org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizerTest",
        "test_method": "testTrivial",
        "test_code": "testTrivial() {\n        LinearProblem problem\n            = new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });\n        NonLinearConjugateGradientOptimizer optimizer\n            = new NonLinearConjugateGradientOptimizer(NonLinearConjugateGradientOptimizer.Formula.POLAK_RIBIERE,\n                                                      new SimpleValueChecker(1e-6, 1e-6));\n        PointValuePair optimum\n            = optimizer.optimize(new MaxEval(100),\n                                 problem.getObjectiveFunction(),\n                                 problem.getObjectiveFunctionGradient(),\n                                 GoalType.MINIMIZE,\n                                 new InitialGuess(new double[] { 0 }));\n        Assert.assertEquals(1.5, optimum.getPoint()[0], 1.0e-10);\n        Assert.assertEquals(0.0, optimum.getValue(), 1.0e-10);\n\n        // Check that the number of iterations is updated (MATH-949).\n        Assert.assertTrue(optimizer.getIterations() > 0);\n    }",
        "clean_err_msg": "junit.framework.AssertionFailedError"
      },
      "1": {
        "test_path": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest",
        "test_method": "testConstrainedRosen",
        "test_code": "testConstrainedRosen() {\n        double[] startPoint = point(DIM, 0.1);\n        double[] insigma = point(DIM, 0.1);\n        double[][] boundaries = boundaries(DIM, -1, 2);\n        PointValuePair expected =\n            new PointValuePair(point(DIM,1.0),0.0);\n        doTest(new Rosen(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, 2*LAMBDA, true, 0, 1e-13,\n                1e-13, 1e-6, 100000, expected);\n        doTest(new Rosen(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, 2*LAMBDA, false, 0, 1e-13,\n                1e-13, 1e-6, 100000, expected);\n    }",
        "clean_err_msg": "junit.framework.AssertionFailedError"
      },
      "2": {
        "test_path": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest",
        "test_method": "testElliRotated",
        "test_code": "testElliRotated() {\n        double[] startPoint = point(DIM,1.0);\n        double[] insigma = point(DIM,0.1);\n        double[][] boundaries = null;\n        PointValuePair expected =\n            new PointValuePair(point(DIM,0.0),0.0);\n        doTest(new ElliRotated(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,\n                1e-13, 1e-6, 100000, expected);\n        doTest(new ElliRotated(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13,\n                1e-13, 1e-6, 100000, expected);\n    }",
        "clean_err_msg": "junit.framework.AssertionFailedError"
      },
      "3": {
        "test_path": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest",
        "test_method": "testEllipse",
        "test_code": "testEllipse() {\n        double[] startPoint = point(DIM,1.0);\n        double[] insigma = point(DIM,0.1);\n        double[][] boundaries = null;\n        PointValuePair expected =\n            new PointValuePair(point(DIM,0.0),0.0);\n        doTest(new Elli(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,\n                1e-13, 1e-6, 100000, expected);\n        doTest(new Elli(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13,\n                1e-13, 1e-6, 100000, expected);\n    }",
        "clean_err_msg": "junit.framework.AssertionFailedError"
      },
      "4": {
        "test_path": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest",
        "test_method": "testTwoAxes",
        "test_code": "testTwoAxes() {\n        double[] startPoint = point(DIM,1.0);\n        double[] insigma = point(DIM,0.1);\n        double[][] boundaries = null;\n        PointValuePair expected =\n            new PointValuePair(point(DIM,0.0),0.0);\n        doTest(new TwoAxes(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, 2*LAMBDA, true, 0, 1e-13,\n                1e-13, 1e-6, 200000, expected);\n        doTest(new TwoAxes(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, 2*LAMBDA, false, 0, 1e-13,\n                1e-8, 1e-3, 200000, expected);\n    }",
        "clean_err_msg": "junit.framework.AssertionFailedError"
      },
      "5": {
        "test_path": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest",
        "test_method": "testCigar",
        "test_code": "testCigar() {\n        double[] startPoint = point(DIM,1.0);\n        double[] insigma = point(DIM,0.1);\n        double[][] boundaries = null;\n        PointValuePair expected =\n            new PointValuePair(point(DIM,0.0),0.0);\n        doTest(new Cigar(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,\n                1e-13, 1e-6, 200000, expected);\n        doTest(new Cigar(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13,\n                1e-13, 1e-6, 100000, expected);\n    }",
        "clean_err_msg": "junit.framework.AssertionFailedError"
      },
      "6": {
        "test_path": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest",
        "test_method": "testRosen",
        "test_code": "testRosen() {\n        double[] startPoint = point(DIM,0.1);\n        double[] insigma = point(DIM,0.1);\n        double[][] boundaries = null;\n        PointValuePair expected =\n            new PointValuePair(point(DIM,1.0),0.0);\n        doTest(new Rosen(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,\n                1e-13, 1e-6, 100000, expected);\n        doTest(new Rosen(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13,\n                1e-13, 1e-6, 100000, expected);\n    }",
        "clean_err_msg": "junit.framework.AssertionFailedError"
      },
      "7": {
        "test_path": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest",
        "test_method": "testRastrigin",
        "test_code": "testRastrigin() {\n        double[] startPoint = point(DIM,0.1);\n        double[] insigma = point(DIM,0.1);\n        double[][] boundaries = null;\n        PointValuePair expected =\n            new PointValuePair(point(DIM,0.0),0.0);\n        doTest(new Rastrigin(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, (int)(200*Math.sqrt(DIM)), true, 0, 1e-13,\n                1e-13, 1e-6, 200000, expected);\n        doTest(new Rastrigin(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, (int)(200*Math.sqrt(DIM)), false, 0, 1e-13,\n                1e-13, 1e-6, 200000, expected);\n    }",
        "clean_err_msg": "junit.framework.AssertionFailedError"
      },
      "8": {
        "test_path": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest",
        "test_method": "testDiagonalRosen",
        "test_code": "testDiagonalRosen() {\n        double[] startPoint = point(DIM,0.1);\n        double[] insigma = point(DIM,0.1);\n        double[][] boundaries = null;\n        PointValuePair expected =\n            new PointValuePair(point(DIM,1.0),0.0);\n        doTest(new Rosen(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, LAMBDA, false, 1, 1e-13,\n                1e-10, 1e-4, 1000000, expected);\n     }",
        "clean_err_msg": "junit.framework.AssertionFailedError"
      },
      "9": {
        "test_path": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest",
        "test_method": "testSsDiffPow",
        "test_code": "testSsDiffPow() {\n        double[] startPoint = point(DIM,1.0);\n        double[] insigma = point(DIM,0.1);\n        double[][] boundaries = null;\n        PointValuePair expected =\n            new PointValuePair(point(DIM,0.0),0.0);\n        doTest(new SsDiffPow(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, 10, true, 0, 1e-13,\n                1e-4, 1e-1, 200000, expected);\n        doTest(new SsDiffPow(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, 10, false, 0, 1e-13,\n                1e-4, 1e-1, 200000, expected);\n    }",
        "clean_err_msg": "junit.framework.AssertionFailedError"
      },
      "10": {
        "test_path": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest",
        "test_method": "testMaximize",
        "test_code": "testMaximize() {\n        double[] startPoint = point(DIM,1.0);\n        double[] insigma = point(DIM,0.1);\n        double[][] boundaries = null;\n        PointValuePair expected =\n            new PointValuePair(point(DIM,0.0),1.0);\n        doTest(new MinusElli(), startPoint, insigma, boundaries,\n                GoalType.MAXIMIZE, LAMBDA, true, 0, 1.0-1e-13,\n                2e-10, 5e-6, 100000, expected);\n        doTest(new MinusElli(), startPoint, insigma, boundaries,\n                GoalType.MAXIMIZE, LAMBDA, false, 0, 1.0-1e-13,\n                2e-10, 5e-6, 100000, expected);\n        boundaries = boundaries(DIM,-0.3,0.3); \n        startPoint = point(DIM,0.1);\n        doTest(new MinusElli(), startPoint, insigma, boundaries,\n                GoalType.MAXIMIZE, LAMBDA, true, 0, 1.0-1e-13,\n                2e-10, 5e-6, 100000, expected);\n    }",
        "clean_err_msg": "junit.framework.AssertionFailedError"
      },
      "11": {
        "test_path": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest",
        "test_method": "testAckley",
        "test_code": "testAckley() {\n        double[] startPoint = point(DIM,1.0);\n        double[] insigma = point(DIM,1.0);\n        double[][] boundaries = null;\n        PointValuePair expected =\n            new PointValuePair(point(DIM,0.0),0.0);\n        doTest(new Ackley(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, 2*LAMBDA, true, 0, 1e-13,\n                1e-9, 1e-5, 100000, expected);\n        doTest(new Ackley(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, 2*LAMBDA, false, 0, 1e-13,\n                1e-9, 1e-5, 100000, expected);\n    }",
        "clean_err_msg": "junit.framework.AssertionFailedError"
      },
      "12": {
        "test_path": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest",
        "test_method": "testCigTab",
        "test_code": "testCigTab() {\n        double[] startPoint = point(DIM,1.0);\n        double[] insigma = point(DIM,0.3);\n        double[][] boundaries = null;\n        PointValuePair expected =\n            new PointValuePair(point(DIM,0.0),0.0);\n        doTest(new CigTab(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,\n                1e-13, 5e-5, 100000, expected);\n        doTest(new CigTab(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13,\n                1e-13, 5e-5, 100000, expected);\n    }",
        "clean_err_msg": "junit.framework.AssertionFailedError"
      },
      "13": {
        "test_path": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest",
        "test_method": "testDiffPow",
        "test_code": "testDiffPow() {\n        double[] startPoint = point(DIM,1.0);\n        double[] insigma = point(DIM,0.1);\n        double[][] boundaries = null;\n        PointValuePair expected =\n            new PointValuePair(point(DIM,0.0),0.0);\n        doTest(new DiffPow(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, 10, true, 0, 1e-13,\n                1e-8, 1e-1, 100000, expected);\n        doTest(new DiffPow(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, 10, false, 0, 1e-13,\n                1e-8, 2e-1, 100000, expected);\n    }",
        "clean_err_msg": "junit.framework.AssertionFailedError"
      },
      "14": {
        "test_path": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest",
        "test_method": "testSphere",
        "test_code": "testSphere() {\n        double[] startPoint = point(DIM,1.0);\n        double[] insigma = point(DIM,0.1);\n        double[][] boundaries = null;\n        PointValuePair expected =\n            new PointValuePair(point(DIM,0.0),0.0);\n        doTest(new Sphere(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,\n                1e-13, 1e-6, 100000, expected);\n        doTest(new Sphere(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13,\n                1e-13, 1e-6, 100000, expected);\n    }",
        "clean_err_msg": "junit.framework.AssertionFailedError"
      },
      "15": {
        "test_path": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest",
        "test_method": "testTablet",
        "test_code": "testTablet() {\n        double[] startPoint = point(DIM,1.0);\n        double[] insigma = point(DIM,0.1);\n        double[][] boundaries = null;\n        PointValuePair expected =\n            new PointValuePair(point(DIM,0.0),0.0);\n        doTest(new Tablet(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,\n                1e-13, 1e-6, 100000, expected);\n        doTest(new Tablet(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13,\n                1e-13, 1e-6, 100000, expected);\n    }",
        "clean_err_msg": "junit.framework.AssertionFailedError"
      },
      "16": {
        "test_path": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest",
        "test_method": "testCigarWithBoundaries",
        "test_code": "testCigarWithBoundaries() {\n        double[] startPoint = point(DIM,1.0);\n        double[] insigma = point(DIM,0.1);\n        double[][] boundaries = boundaries(DIM, -1e100, Double.POSITIVE_INFINITY);\n        PointValuePair expected =\n            new PointValuePair(point(DIM,0.0),0.0);\n        doTest(new Cigar(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,\n                1e-13, 1e-6, 200000, expected);\n        doTest(new Cigar(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13,\n                1e-13, 1e-6, 100000, expected);\n    }",
        "clean_err_msg": "junit.framework.AssertionFailedError"
      },
      "17": {
        "test_path": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.PowellOptimizerTest",
        "test_method": "testSumSinc",
        "test_code": "testSumSinc() {\n        final MultivariateFunction func = new SumSincFunction(-1);\n\n        int dim = 2;\n        final double[] minPoint = new double[dim];\n        for (int i = 0; i < dim; i++) {\n            minPoint[i] = 0;\n        }\n\n        double[] init = new double[dim];\n\n        // Initial is minimum.\n        for (int i = 0; i < dim; i++) {\n            init[i] = minPoint[i];\n        }\n        doTest(func, minPoint, init, GoalType.MINIMIZE, 1e-9, 1e-9);\n\n        // Initial is far from minimum.\n        for (int i = 0; i < dim; i++) {\n            init[i] = minPoint[i] + 3;\n        }\n        doTest(func, minPoint, init, GoalType.MINIMIZE, 1e-9, 1e-5);\n        // More stringent line search tolerance enhances the precision\n        // of the result.\n        doTest(func, minPoint, init, GoalType.MINIMIZE, 1e-9, 1e-9, 1e-7);\n    }",
        "clean_err_msg": "junit.framework.AssertionFailedError"
      },
      "18": {
        "test_path": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizerMultiDirectionalTest",
        "test_method": "testMaximize1",
        "test_code": "testMaximize1() {\n        SimplexOptimizer optimizer = new SimplexOptimizer(1e-11, 1e-30);\n        final FourExtrema fourExtrema = new FourExtrema();\n\n        final PointValuePair optimum\n            = optimizer.optimize(new MaxEval(200),\n                                 new ObjectiveFunction(fourExtrema),\n                                 GoalType.MAXIMIZE,\n                                 new InitialGuess(new double[] { -3.0, 0.0 }),\n                                 new MultiDirectionalSimplex(new double[] { 0.2, 0.2 }));\n        Assert.assertEquals(fourExtrema.xM, optimum.getPoint()[0], 7e-7);\n        Assert.assertEquals(fourExtrema.yM, optimum.getPoint()[1], 3e-7);\n        Assert.assertEquals(fourExtrema.valueXmYm, optimum.getValue(), 2e-14);\n        Assert.assertTrue(optimizer.getEvaluations() > 120);\n        Assert.assertTrue(optimizer.getEvaluations() < 150);\n\n        // Check that the number of iterations is updated (MATH-949).\n        Assert.assertTrue(optimizer.getIterations() > 0);\n    }",
        "clean_err_msg": "junit.framework.AssertionFailedError"
      },
      "19": {
        "test_path": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizerMultiDirectionalTest",
        "test_method": "testMaximize2",
        "test_code": "testMaximize2() {\n        SimplexOptimizer optimizer = new SimplexOptimizer(new SimpleValueChecker(1e-15, 1e-30));\n        final FourExtrema fourExtrema = new FourExtrema();\n\n        final PointValuePair optimum\n            = optimizer.optimize(new MaxEval(200),\n                                 new ObjectiveFunction(fourExtrema),\n                                 GoalType.MAXIMIZE,\n                                 new InitialGuess(new double[] { 1, 0 }),\n                                 new MultiDirectionalSimplex(new double[] { 0.2, 0.2 }));\n        Assert.assertEquals(fourExtrema.xP, optimum.getPoint()[0], 2e-8);\n        Assert.assertEquals(fourExtrema.yP, optimum.getPoint()[1], 3e-6);\n        Assert.assertEquals(fourExtrema.valueXpYp, optimum.getValue(), 2e-12);\n        Assert.assertTrue(optimizer.getEvaluations() > 180);\n        Assert.assertTrue(optimizer.getEvaluations() < 220);\n\n        // Check that the number of iterations is updated (MATH-949).\n        Assert.assertTrue(optimizer.getIterations() > 0);\n    }",
        "clean_err_msg": "junit.framework.AssertionFailedError"
      },
      "20": {
        "test_path": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizerMultiDirectionalTest",
        "test_method": "testMinimize1",
        "test_code": "testMinimize1() {\n        SimplexOptimizer optimizer = new SimplexOptimizer(1e-11, 1e-30);\n        final FourExtrema fourExtrema = new FourExtrema();\n\n        final PointValuePair optimum\n            = optimizer.optimize(new MaxEval(200),\n                                 new ObjectiveFunction(fourExtrema),\n                                 GoalType.MINIMIZE,\n                                 new InitialGuess(new double[] { -3, 0 }),\n                                 new MultiDirectionalSimplex(new double[] { 0.2, 0.2 }));\n        Assert.assertEquals(fourExtrema.xM, optimum.getPoint()[0], 4e-6);\n        Assert.assertEquals(fourExtrema.yP, optimum.getPoint()[1], 3e-6);\n        Assert.assertEquals(fourExtrema.valueXmYp, optimum.getValue(), 8e-13);\n        Assert.assertTrue(optimizer.getEvaluations() > 120);\n        Assert.assertTrue(optimizer.getEvaluations() < 150);\n\n        // Check that the number of iterations is updated (MATH-949).\n        Assert.assertTrue(optimizer.getIterations() > 0);\n    }",
        "clean_err_msg": "junit.framework.AssertionFailedError"
      },
      "21": {
        "test_path": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizerMultiDirectionalTest",
        "test_method": "testMinimize2",
        "test_code": "testMinimize2() {\n        SimplexOptimizer optimizer = new SimplexOptimizer(1e-11, 1e-30);\n        final FourExtrema fourExtrema = new FourExtrema();\n\n        final PointValuePair optimum\n            = optimizer.optimize(new MaxEval(200),\n                                 new ObjectiveFunction(fourExtrema),\n                                 GoalType.MINIMIZE,\n                                 new InitialGuess(new double[] { 1, 0 }),\n                                 new MultiDirectionalSimplex(new double[] { 0.2, 0.2 }));\n        Assert.assertEquals(fourExtrema.xP, optimum.getPoint()[0], 2e-8);\n        Assert.assertEquals(fourExtrema.yM, optimum.getPoint()[1], 3e-6);\n        Assert.assertEquals(fourExtrema.valueXpYm, optimum.getValue(), 2e-12);\n        Assert.assertTrue(optimizer.getEvaluations() > 120);\n        Assert.assertTrue(optimizer.getEvaluations() < 150);\n\n        // Check that the number of iterations is updated (MATH-949).\n        Assert.assertTrue(optimizer.getIterations() > 0);\n    }",
        "clean_err_msg": "junit.framework.AssertionFailedError"
      },
      "22": {
        "test_path": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizerNelderMeadTest",
        "test_method": "testMaximize1",
        "test_code": "testMaximize1() {\n        SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30);\n        final FourExtrema fourExtrema = new FourExtrema();\n\n        final PointValuePair optimum\n            = optimizer.optimize(new MaxEval(100),\n                                 new ObjectiveFunction(fourExtrema),\n                                 GoalType.MAXIMIZE,\n                                 new InitialGuess(new double[] { -3, 0 }),\n                                 new NelderMeadSimplex(new double[] { 0.2, 0.2 }));\n        Assert.assertEquals(fourExtrema.xM, optimum.getPoint()[0], 1e-5);\n        Assert.assertEquals(fourExtrema.yM, optimum.getPoint()[1], 3e-6);\n        Assert.assertEquals(fourExtrema.valueXmYm, optimum.getValue(), 3e-12);\n        Assert.assertTrue(optimizer.getEvaluations() > 60);\n        Assert.assertTrue(optimizer.getEvaluations() < 90);\n\n        // Check that the number of iterations is updated (MATH-949).\n        Assert.assertTrue(optimizer.getIterations() > 0);\n    }",
        "clean_err_msg": "junit.framework.AssertionFailedError"
      },
      "23": {
        "test_path": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizerNelderMeadTest",
        "test_method": "testMaximize2",
        "test_code": "testMaximize2() {\n        SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30);\n        final FourExtrema fourExtrema = new FourExtrema();\n\n        final PointValuePair optimum\n            = optimizer.optimize(new MaxEval(100),\n                                 new ObjectiveFunction(fourExtrema),\n                                 GoalType.MAXIMIZE,\n                                 new InitialGuess(new double[] { 1, 0 }),\n                                 new NelderMeadSimplex(new double[] { 0.2, 0.2 }));\n        Assert.assertEquals(fourExtrema.xP, optimum.getPoint()[0], 4e-6);\n        Assert.assertEquals(fourExtrema.yP, optimum.getPoint()[1], 5e-6);\n        Assert.assertEquals(fourExtrema.valueXpYp, optimum.getValue(), 7e-12);\n        Assert.assertTrue(optimizer.getEvaluations() > 60);\n        Assert.assertTrue(optimizer.getEvaluations() < 90);\n\n        // Check that the number of iterations is updated (MATH-949).\n        Assert.assertTrue(optimizer.getIterations() > 0);\n    }",
        "clean_err_msg": "junit.framework.AssertionFailedError"
      },
      "24": {
        "test_path": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizerNelderMeadTest",
        "test_method": "testMinimize1",
        "test_code": "testMinimize1() {\n        SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30);\n        final FourExtrema fourExtrema = new FourExtrema();\n\n        final PointValuePair optimum\n            = optimizer.optimize(new MaxEval(100),\n                                 new ObjectiveFunction(fourExtrema),\n                                 GoalType.MINIMIZE,\n                                 new InitialGuess(new double[] { -3, 0 }),\n                                 new NelderMeadSimplex(new double[] { 0.2, 0.2 }));\n        Assert.assertEquals(fourExtrema.xM, optimum.getPoint()[0], 2e-7);\n        Assert.assertEquals(fourExtrema.yP, optimum.getPoint()[1], 2e-5);\n        Assert.assertEquals(fourExtrema.valueXmYp, optimum.getValue(), 6e-12);\n        Assert.assertTrue(optimizer.getEvaluations() > 60);\n        Assert.assertTrue(optimizer.getEvaluations() < 90);\n\n        // Check that the number of iterations is updated (MATH-949).\n        Assert.assertTrue(optimizer.getIterations() > 0);\n    }",
        "clean_err_msg": "junit.framework.AssertionFailedError"
      },
      "25": {
        "test_path": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizerNelderMeadTest",
        "test_method": "testMinimize2",
        "test_code": "testMinimize2() {\n        SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30);\n        final FourExtrema fourExtrema = new FourExtrema();\n\n        final PointValuePair optimum\n            = optimizer.optimize(new MaxEval(100),\n                                 new ObjectiveFunction(fourExtrema),\n                                 GoalType.MINIMIZE,\n                                 new InitialGuess(new double[] { 1, 0 }),\n                                 new NelderMeadSimplex(new double[] { 0.2, 0.2 }));\n        Assert.assertEquals(fourExtrema.xP, optimum.getPoint()[0], 5e-6);\n        Assert.assertEquals(fourExtrema.yM, optimum.getPoint()[1], 6e-6);\n        Assert.assertEquals(fourExtrema.valueXpYm, optimum.getValue(), 1e-11);\n        Assert.assertTrue(optimizer.getEvaluations() > 60);\n        Assert.assertTrue(optimizer.getEvaluations() < 90);\n\n        // Check that the number of iterations is updated (MATH-949).\n        Assert.assertTrue(optimizer.getIterations() > 0);\n    }",
        "clean_err_msg": "junit.framework.AssertionFailedError"
      }
    },
    "buggy_files": {
      "0": "src/main/java/org/apache/commons/math3/optim/BaseOptimizer.java",
      "1": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer.java",
      "2": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java",
      "3": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizer.java",
      "4": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizer.java",
      "5": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizer.java",
      "6": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java"
    },
    "hunk_type": "multi_file_four_or_more_hunks",
    "hunk_mapping": {
      "0": [
        {
          "start_line": 51,
          "end_line": 51,
          "file": "src/main/java/org/apache/commons/math3/optim/BaseOptimizer.java",
          "code": "<START_BUG>\n        iterations = new Incrementor(0, new MaxIterCallback());\n<END_BUG>"
        }
      ],
      "1": [
        {
          "start_line": 214,
          "end_line": 223,
          "file": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer.java",
          "code": "<START_BUG>\n        int iter = 0;\n        int maxEval = getMaxEvaluations();\n        while (true) {\n            ++iter;\n\n            final double objective = computeObjectiveValue(point);\n            PointValuePair previous = current;\n            current = new PointValuePair(point, objective);\n            if (previous != null) {\n                if (checker.converged(iter, previous, current)) {\n<END_BUG>"
        },
        {
          "start_line": 277,
          "end_line": 277,
          "file": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer.java",
          "code": "<START_BUG>\n            if (iter % n == 0 ||\n<END_BUG>"
        }
      ],
      "2": [
        {
          "start_line": 388,
          "end_line": 387,
          "file": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java",
          "code": "<START_BUG>\n<END_BUG>"
        }
      ],
      "3": [
        {
          "start_line": 191,
          "end_line": 193,
          "file": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizer.java",
          "code": "<START_BUG>\n        int iter = 0;\n        while (true) {\n            ++iter;\n<END_BUG>"
        },
        {
          "start_line": 227,
          "end_line": 227,
          "file": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizer.java",
          "code": "<START_BUG>\n                    stop = checker.converged(iter, previous, current);\n<END_BUG>"
        }
      ],
      "4": [
        {
          "start_line": 158,
          "end_line": 158,
          "file": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizer.java",
          "code": "<START_BUG>\n            if (iteration > 0) {\n<END_BUG>"
        },
        {
          "start_line": 175,
          "end_line": 175,
          "file": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizer.java",
          "code": "<START_BUG>\n\t\t\t++iteration;\n<END_BUG>"
        }
      ],
      "5": [
        {
          "start_line": 106,
          "end_line": 108,
          "file": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizer.java",
          "code": "<START_BUG>\n        int iter = 0;\n        for (boolean converged = false; !converged;) {\n            ++iter;\n<END_BUG>"
        },
        {
          "start_line": 160,
          "end_line": 160,
          "file": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizer.java",
          "code": "<START_BUG>\n                converged = checker.converged(iter, previous, current);\n<END_BUG>"
        }
      ],
      "6": [
        {
          "start_line": 322,
          "end_line": 325,
          "file": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java",
          "code": "<START_BUG>\n        int iter = 0;\n        final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker();\n        while (true) {\n            ++iter;\n<END_BUG>"
        },
        {
          "start_line": 489,
          "end_line": 489,
          "file": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java",
          "code": "<START_BUG>\n                        if (checker.converged(iter, previous, current)) {\n<END_BUG>"
        }
      ]
    },
    "bug_report": {
      "url": "https://issues.apache.org/jira/browse/MATH-949",
      "title": "LevenbergMarquardtOptimizer reports 0 iterations",
      "bug_description": "The method LevenbergMarquardtOptimizer.getIterations() does not report the correct number of iterations; It always returns 0. A quick look at the code shows that only SimplexOptimizer calls BaseOptimizer.incrementEvaluationsCount()\nI've put a test case below. Notice how the evaluations count is correctly incremented, but the iterations count is not.\n@Test\n    public void testGetIterations() {\n        // setup\n        LevenbergMarquardtOptimizer otim = new LevenbergMarquardtOptimizer();\n\n        // action\n        otim.optimize(new MaxEval(100), new Target(new double[] { 1 }),\n                new Weight(new double[] { 1 }), new InitialGuess(\n                        new double[] { 3 }), new ModelFunction(\n                        new MultivariateVectorFunction() {\n                            @Override\n                            public double[] value(double[] point)\n                                    throws IllegalArgumentException {\n                                return new double[] { FastMath.pow(point[0], 4) };\n                            }\n                        }), new ModelFunctionJacobian(\n                        new MultivariateMatrixFunction() {\n                            @Override\n                            public double[][] value(double[] point)\n                                    throws IllegalArgumentException {\n                                return new double[][] { { 0.25 * FastMath.pow(\n                                        point[0], 3) } };\n                            }\n                        }));\n\n        // verify\n        assertThat(otim.getEvaluations(), greaterThan(1));\n        assertThat(otim.getIterations(), greaterThan(1));\n    }"
    }
  },
  "Jsoup_22": {
    "buggy_hunks": {
      "0": {
        "start_line": 434,
        "end_line": 435,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "code": "<START_BUG>\n\n        return parent().children();\n<END_BUG>"
      },
      "1": {
        "start_line": 447,
        "end_line": 446,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "code": "<START_BUG>\n<END_BUG>"
      },
      "2": {
        "start_line": 462,
        "end_line": 461,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "code": "<START_BUG>\n<END_BUG>"
      },
      "3": {
        "start_line": 444,
        "end_line": 445,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "code": "<START_BUG>\n\n        return parent().childNodes();\n<END_BUG>"
      },
      "4": {
        "start_line": 470,
        "end_line": 469,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "code": "<START_BUG>\n<END_BUG>"
      },
      "5": {
        "start_line": 22,
        "end_line": 21,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "code": "<START_BUG>\n<END_BUG>"
      }
    },
    "buggy_code": {
      "0": {
        "start_line": 433,
        "end_line": 436,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "code": "public Elements siblingElements() {\n\n        return parent().children();\n    }",
        "javadoc": "/**\n * Get sibling elements. If the element has no sibling elements, returns an empty list. An element is not a sibling\n * of itself, so will not be included in the returned list.\n * @return sibling elements\n */\n"
      },
      "1": {
        "start_line": 446,
        "end_line": 454,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "code": "public Element nextElementSibling() {\n        List<Element> siblings = parent().children();\n        Integer index = indexInList(this, siblings);\n        Validate.notNull(index);\n        if (siblings.size() > index+1)\n            return siblings.get(index+1);\n        else\n            return null;\n    }",
        "javadoc": "/**\n * Gets the next sibling element of this element. E.g., if a {@code div} contains two {@code p}s,\n * the {@code nextElementSibling} of the first {@code p} is the second {@code p}.\n * <p/>\n * This is similar to {@link #nextSibling()}, but specifically finds only Elements\n * @return the next element, or null if there is no next element\n * @see #previousElementSibling()\n */\n"
      },
      "2": {
        "start_line": 461,
        "end_line": 469,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "code": "public Element previousElementSibling() {\n        List<Element> siblings = parent().children();\n        Integer index = indexInList(this, siblings);\n        Validate.notNull(index);\n        if (index > 0)\n            return siblings.get(index-1);\n        else\n            return null;\n    }",
        "javadoc": "/**\n * Gets the previous element sibling of this element.\n * @return the previous element, or null if there is no previous element\n * @see #nextElementSibling()\n */\n"
      },
      "3": {
        "start_line": 443,
        "end_line": 446,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "code": "public List<Node> siblingNodes() {\n\n        return parent().childNodes();\n    }",
        "javadoc": "/**\n *     Retrieves this node's sibling nodes. Similar to {@link #childNodes()  node.parent.childNodes()}, but does not\n *     include this node (a node is not a sibling of itself).\n *     @return node siblings. If the node has no parent, returns an empty list.\n */\n"
      },
      "4": {
        "start_line": 469,
        "end_line": 478,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "code": "public Node previousSibling() {\n\n        List<Node> siblings = parentNode.childNodes;\n        Integer index = siblingIndex();\n        Validate.notNull(index);\n        if (index > 0)\n            return siblings.get(index-1);\n        else\n            return null;\n    }",
        "javadoc": "/**\n *     Get this node's previous sibling.\n *     @return the previous sibling, or null if this is the first sibling\n */\n"
      },
      "5": {
        "start_line": 22,
        "end_line": 22,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "code": "",
        "javadoc": ""
      }
    },
    "delineated_bug": {
      "0": {
        "start_line": 433,
        "end_line": 436,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "code": "public Elements siblingElements() {\n<START_BUG>\n\n        return parent().children();\n<END_BUG>\n    }",
        "javadoc": "/**\n * Get sibling elements. If the element has no sibling elements, returns an empty list. An element is not a sibling\n * of itself, so will not be included in the returned list.\n * @return sibling elements\n */\n"
      },
      "1": {
        "start_line": 446,
        "end_line": 454,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "code": "public Element nextElementSibling() {\n<END_BUG>\n<START_BUG>\n        List<Element> siblings = parent().children();\n        Integer index = indexInList(this, siblings);\n        Validate.notNull(index);\n        if (siblings.size() > index+1)\n            return siblings.get(index+1);\n        else\n            return null;\n    }",
        "javadoc": "/**\n * Gets the next sibling element of this element. E.g., if a {@code div} contains two {@code p}s,\n * the {@code nextElementSibling} of the first {@code p} is the second {@code p}.\n * <p/>\n * This is similar to {@link #nextSibling()}, but specifically finds only Elements\n * @return the next element, or null if there is no next element\n * @see #previousElementSibling()\n */\n"
      },
      "2": {
        "start_line": 461,
        "end_line": 469,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "code": "public Element previousElementSibling() {\n<END_BUG>\n<START_BUG>\n        List<Element> siblings = parent().children();\n        Integer index = indexInList(this, siblings);\n        Validate.notNull(index);\n        if (index > 0)\n            return siblings.get(index-1);\n        else\n            return null;\n    }",
        "javadoc": "/**\n * Gets the previous element sibling of this element.\n * @return the previous element, or null if there is no previous element\n * @see #nextElementSibling()\n */\n"
      },
      "3": {
        "start_line": 443,
        "end_line": 446,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "code": "public List<Node> siblingNodes() {\n<START_BUG>\n\n        return parent().childNodes();\n<END_BUG>\n    }",
        "javadoc": "/**\n *     Retrieves this node's sibling nodes. Similar to {@link #childNodes()  node.parent.childNodes()}, but does not\n *     include this node (a node is not a sibling of itself).\n *     @return node siblings. If the node has no parent, returns an empty list.\n */\n"
      },
      "4": {
        "start_line": 469,
        "end_line": 478,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "code": "public Node previousSibling() {\n<END_BUG>\n<START_BUG>\n\n        List<Node> siblings = parentNode.childNodes;\n        Integer index = siblingIndex();\n        Validate.notNull(index);\n        if (index > 0)\n            return siblings.get(index-1);\n        else\n            return null;\n    }",
        "javadoc": "/**\n *     Get this node's previous sibling.\n *     @return the previous sibling, or null if this is the first sibling\n */\n"
      },
      "5": {
        "start_line": 22,
        "end_line": 22,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "code": "<START_BUG>\n\n<END_BUG>",
        "javadoc": ""
      }
    },
    "contained_scope": "file",
    "bug_count": 6,
    "triggered_tests": {
      "0": {
        "test_path": "org.jsoup.nodes.ElementTest",
        "test_method": "elementIsNotASiblingOfItself",
        "test_code": "elementIsNotASiblingOfItself() {\n        Document doc = Jsoup.parse(\"<div><p>One<p>Two<p>Three</div>\");\n        Element p2 = doc.select(\"p\").get(1);\n\n        assertEquals(\"Two\", p2.text());\n        Elements els = p2.siblingElements();\n        assertEquals(2, els.size());\n        assertEquals(\"<p>One</p>\", els.get(0).outerHtml());\n        assertEquals(\"<p>Three</p>\", els.get(1).outerHtml());\n    }",
        "clean_err_msg": "junit.framework.AssertionFailedError: expected:<2> but was:<3>"
      },
      "1": {
        "test_path": "org.jsoup.nodes.NodeTest",
        "test_method": "nodeIsNotASiblingOfItself",
        "test_code": "nodeIsNotASiblingOfItself() {\n        Document doc = Jsoup.parse(\"<div><p>One<p>Two<p>Three</div>\");\n        Element p2 = doc.select(\"p\").get(1);\n\n        assertEquals(\"Two\", p2.text());\n        List<Node> nodes = p2.siblingNodes();\n        assertEquals(2, nodes.size());\n        assertEquals(\"<p>One</p>\", nodes.get(0).outerHtml());\n        assertEquals(\"<p>Three</p>\", nodes.get(1).outerHtml());\n    }",
        "clean_err_msg": "junit.framework.AssertionFailedError: expected:<2> but was:<3>"
      },
      "2": {
        "test_path": "org.jsoup.nodes.NodeTest",
        "test_method": "orphanNodeReturnsNullForSiblingElements",
        "test_code": "orphanNodeReturnsNullForSiblingElements() {\n        Node node = new Element(Tag.valueOf(\"p\"), \"\");\n        Element el = new Element(Tag.valueOf(\"p\"), \"\");\n\n        assertEquals(0, node.siblingIndex());\n        assertEquals(0, node.siblingNodes().size());\n\n        assertNull(node.previousSibling());\n        assertNull(node.nextSibling());\n\n        assertEquals(0, el.siblingElements().size());\n        assertNull(el.previousElementSibling());\n        assertNull(el.nextElementSibling());\n    }",
        "clean_err_msg": "java.lang.NullPointerException"
      }
    },
    "buggy_files": {
      "0": "src/main/java/org/jsoup/nodes/Element.java",
      "1": "src/main/java/org/jsoup/nodes/Node.java",
      "2": "src/main/java/org/jsoup/select/Elements.java"
    },
    "hunk_type": "multi_file_four_or_more_hunks",
    "hunk_mapping": {
      "0": [
        {
          "start_line": 434,
          "end_line": 435,
          "file": "src/main/java/org/jsoup/nodes/Element.java",
          "code": "<START_BUG>\n\n        return parent().children();\n<END_BUG>"
        }
      ],
      "1": [
        {
          "start_line": 447,
          "end_line": 446,
          "file": "src/main/java/org/jsoup/nodes/Element.java",
          "code": "<START_BUG>\n<END_BUG>"
        }
      ],
      "2": [
        {
          "start_line": 462,
          "end_line": 461,
          "file": "src/main/java/org/jsoup/nodes/Element.java",
          "code": "<START_BUG>\n<END_BUG>"
        }
      ],
      "3": [
        {
          "start_line": 444,
          "end_line": 445,
          "file": "src/main/java/org/jsoup/nodes/Node.java",
          "code": "<START_BUG>\n\n        return parent().childNodes();\n<END_BUG>"
        }
      ],
      "4": [
        {
          "start_line": 470,
          "end_line": 469,
          "file": "src/main/java/org/jsoup/nodes/Node.java",
          "code": "<START_BUG>\n<END_BUG>"
        }
      ],
      "5": [
        {
          "start_line": 22,
          "end_line": 21,
          "file": "src/main/java/org/jsoup/select/Elements.java",
          "code": "<START_BUG>\n<END_BUG>"
        }
      ]
    },
    "bug_report": {
      "url": "https://github.com/jhy/jsoup/issues/184",
      "title": "siblingElements in Element throws Null Pointer Exception",
      "bug_description": "Hi,\n\nI have noticed that the sibling methods (nextSibling, previousSibling, siblingElements) rely on an element (underlying node) having a parent. If the node does not have a parent it throws null pointer exception.\n\nWould it be possible to modify the code so that it checks for parent nullness around Node.java:468? \n\nIn the event of nullness return null as in the javadoc?\n\nConfirmed in 1.6.2"
    }
  },
  "JacksonDatabind_65": {
    "buggy_hunks": {
      "0": {
        "start_line": 128,
        "end_line": 128,
        "file": "src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java",
        "code": "<START_BUG>\n            return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n<END_BUG>"
      },
      "1": {
        "start_line": 525,
        "end_line": 525,
        "file": "src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java",
        "code": "<START_BUG>\n            if (isFactoryMethod(am)) {\n<END_BUG>"
      },
      "2": {
        "start_line": 558,
        "end_line": 558,
        "file": "src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java",
        "code": "<START_BUG>\n                return true;\n<END_BUG>"
      }
    },
    "buggy_code": {
      "0": {
        "start_line": 115,
        "end_line": 134,
        "file": "src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java",
        "code": "@Override\n    public Object deserializeKey(String key, DeserializationContext ctxt)\n        throws IOException\n    {\n        if (key == null) { // is this even legal call?\n            return null;\n        }\n        try {\n            Object result = _parse(key, ctxt);\n            if (result != null) {\n                return result;\n            }\n        } catch (Exception re) {\n            return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n        }\n        if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n            return null;\n        }\n        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n    }",
        "javadoc": ""
      },
      "1": {
        "start_line": 519,
        "end_line": 537,
        "file": "src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java",
        "code": "@Override\n    public Method findFactoryMethod(Class<?>... expArgTypes)\n    {\n        // So, of all single-arg static methods:\n        for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n            // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n            if (isFactoryMethod(am)) {\n                // And must take one of expected arg types (or supertype)\n                Class<?> actualArgType = am.getRawParameterType(0);\n                for (Class<?> expArgType : expArgTypes) {\n                    // And one that matches what we would pass in\n                    if (actualArgType.isAssignableFrom(expArgType)) {\n                        return am.getAnnotated();\n                    }\n                }\n            }\n        }\n        return null;\n    }",
        "javadoc": ""
      },
      "2": {
        "start_line": 539,
        "end_line": 570,
        "file": "src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java",
        "code": "protected boolean isFactoryMethod(AnnotatedMethod am)\n    {\n        /* First: return type must be compatible with the introspected class\n         * (i.e. allowed to be sub-class, although usually is the same class)\n         */\n        Class<?> rt = am.getRawReturnType();\n        if (!getBeanClass().isAssignableFrom(rt)) {\n            return false;\n        }\n        /* Also: must be a recognized factory method, meaning:\n         * (a) marked with @JsonCreator annotation, or\n         * (b) \"valueOf\" (at this point, need not be public)\n         */\n        if (_annotationIntrospector.hasCreatorAnnotation(am)) {\n            return true;\n        }\n        final String name = am.getName();\n        // 24-Oct-2016, tatu: As per [databind#1429] must ensure takes exactly one arg\n        if (\"valueOf\".equals(name)) {\n                return true;\n        }\n        // [databind#208] Also accept \"fromString()\", if takes String or CharSequence\n        if (\"fromString\".equals(name)) {\n            if (am.getParameterCount() == 1) {\n                Class<?> cls = am.getRawParameterType(0);\n                if (cls == String.class || CharSequence.class.isAssignableFrom(cls)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }",
        "javadoc": ""
      }
    },
    "delineated_bug": {
      "0": {
        "start_line": 115,
        "end_line": 134,
        "file": "src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java",
        "code": "@Override\n    public Object deserializeKey(String key, DeserializationContext ctxt)\n        throws IOException\n    {\n        if (key == null) { // is this even legal call?\n            return null;\n        }\n        try {\n            Object result = _parse(key, ctxt);\n            if (result != null) {\n                return result;\n            }\n        } catch (Exception re) {\n<START_BUG>\n            return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n<END_BUG>\n        }\n        if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n            return null;\n        }\n        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n    }",
        "javadoc": ""
      },
      "1": {
        "start_line": 519,
        "end_line": 537,
        "file": "src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java",
        "code": "@Override\n    public Method findFactoryMethod(Class<?>... expArgTypes)\n    {\n        // So, of all single-arg static methods:\n        for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n            // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n<START_BUG>\n            if (isFactoryMethod(am)) {\n<END_BUG>\n                // And must take one of expected arg types (or supertype)\n                Class<?> actualArgType = am.getRawParameterType(0);\n                for (Class<?> expArgType : expArgTypes) {\n                    // And one that matches what we would pass in\n                    if (actualArgType.isAssignableFrom(expArgType)) {\n                        return am.getAnnotated();\n                    }\n                }\n            }\n        }\n        return null;\n    }",
        "javadoc": ""
      },
      "2": {
        "start_line": 539,
        "end_line": 570,
        "file": "src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java",
        "code": "protected boolean isFactoryMethod(AnnotatedMethod am)\n    {\n        /* First: return type must be compatible with the introspected class\n         * (i.e. allowed to be sub-class, although usually is the same class)\n         */\n        Class<?> rt = am.getRawReturnType();\n        if (!getBeanClass().isAssignableFrom(rt)) {\n            return false;\n        }\n        /* Also: must be a recognized factory method, meaning:\n         * (a) marked with @JsonCreator annotation, or\n         * (b) \"valueOf\" (at this point, need not be public)\n         */\n        if (_annotationIntrospector.hasCreatorAnnotation(am)) {\n            return true;\n        }\n        final String name = am.getName();\n        // 24-Oct-2016, tatu: As per [databind#1429] must ensure takes exactly one arg\n        if (\"valueOf\".equals(name)) {\n<START_BUG>\n                return true;\n<END_BUG>\n        }\n        // [databind#208] Also accept \"fromString()\", if takes String or CharSequence\n        if (\"fromString\".equals(name)) {\n            if (am.getParameterCount() == 1) {\n                Class<?> cls = am.getRawParameterType(0);\n                if (cls == String.class || CharSequence.class.isAssignableFrom(cls)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }",
        "javadoc": ""
      }
    },
    "contained_scope": "method",
    "bug_count": 3,
    "triggered_tests": {
      "0": {
        "test_path": "com.fasterxml.jackson.databind.deser.KeyDeser1429Test",
        "test_method": "testDeserializeKeyViaFactory",
        "test_code": "testDeserializeKeyViaFactory() throws Exception\n    {\n        Map<FullName, Double> map =\n            new ObjectMapper().readValue(\"{\\\"first.last\\\": 42}\",\n                    new TypeReference<Map<FullName, Double>>() { });\n        Map.Entry<FullName, Double> entry = map.entrySet().iterator().next();\n        FullName key = entry.getKey();\n        assertEquals(key._firstname, \"first\");\n        assertEquals(key._lastname, \"last\");\n        assertEquals(entry.getValue().doubleValue(), 42, 0);\n    }",
        "clean_err_msg": "com.fasterxml.jackson.databind.exc.InvalidFormatException: Can not deserialize Map key of type com.fasterxml.jackson.databind.deser.KeyDeser1429Test$FullName from String \"first.last\": not a valid representation, problem: wrong number of arguments"
      }
    },
    "buggy_files": {
      "0": "src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java",
      "1": "src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java"
    },
    "hunk_type": "multi_file_three_hunks",
    "hunk_mapping": {
      "0": [
        {
          "start_line": 128,
          "end_line": 128,
          "file": "src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java",
          "code": "<START_BUG>\n            return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n<END_BUG>"
        }
      ],
      "1": [
        {
          "start_line": 525,
          "end_line": 525,
          "file": "src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java",
          "code": "<START_BUG>\n            if (isFactoryMethod(am)) {\n<END_BUG>"
        }
      ],
      "2": [
        {
          "start_line": 558,
          "end_line": 558,
          "file": "src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java",
          "code": "<START_BUG>\n                return true;\n<END_BUG>"
        }
      ]
    },
    "bug_report": {
      "url": "https://github.com/FasterXML/jackson-databind/issues/1429",
      "title": "StdKeyDeserializer can erroneously use a static factory method with more than one argument",
      "bug_description": "While investigating an issue, I found that there was different behavior for normal deserializers and key deserializers where deserializing a value as a field works as expected, but as a map key fails with \"not a valid representation: wrong number of arguments\".\n\nA basic example:\n\n``` java\nimport com.fasterxml.jackson.annotation.*;\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport org.junit.Test;\n\nimport java.io.IOException;\nimport java.util.Map;\nimport java.util.Map.Entry;\n\nimport static org.junit.Assert.assertEquals;\n\npublic class KeyVsFieldTest {\n    @Test\n    public void deserializeAsField() throws IOException {\n        AsField as_field = new ObjectMapper().readValue(\"{\\\"name\\\": \\\"first.last\\\"}\", AsField.class);\n        assertEquals(as_field.getName()._firstname, \"first\");\n        assertEquals(as_field.getName()._lastname, \"last\");\n    }\n\n    @Test\n    public void deserializeAsKey() throws IOException {\n        Map<FullName, Double> map =\n            new ObjectMapper().readValue(\"{\\\"first.last\\\": 42}\", new TypeReference<Map<FullName, Double>>() {\n            });\n       /* \n          Fails with: com.fasterxml.jackson.databind.exc.InvalidFormatException: Can not construct Map key of type KeyVsFieldTest$FullName from String \"first.last\": not a valid representation: wrong number of arguments\n at [Source: java.io.StringReader@7113b13f; line: 1, column: 2]\n       */\n\n        Entry<FullName, Double> entry = map.entrySet().iterator().next();\n\n        assertEquals(entry.getKey()._firstname, \"first\");\n        assertEquals(entry.getKey()._lastname, \"last\");\n        assertEquals(entry.getValue().doubleValue(), 42, 0);\n    }\n\n    public static class AsField {\n        private final FullName _name;\n\n        public AsField(@JsonProperty(\"name\") FullName aName) {\n            _name = aName;\n        }\n\n        public FullName getName() {\n            return _name;\n        }\n    }\n\n    public static class FullName {\n        private final String _firstname;\n        private final String _lastname;\n\n        private FullName(String firstname, String lastname) {\n            _firstname = firstname;\n            _lastname = lastname;\n        }\n\n        @JsonCreator\n        public static FullName valueOf(String value) {\n            String[] mySplit = value.split(\"\\\\.\");\n            return new FullName(mySplit[0], mySplit[1]);\n        }\n\n        public static FullName valueOf(String firstname, String lastname) {\n            return new FullName(firstname, lastname);\n        }\n\n        @JsonValue\n        @Override\n        public String toString() {\n            return _firstname + \".\" + _lastname;\n        }\n    }\n}\n```\n\nIt looks like this is because in `BasicBeanDescriptor`, `findFactoryMethod` has an incorrect assumption about the contents of `_classInfo.getStaticMethods()`, which will have any method named `valueOf` and static methods annotated with `@JsonCreator`:\n\n``` java\n    @Override\n    public Method findFactoryMethod(Class<?>... expArgTypes)\n    {\n        // So, of all single-arg static methods:\n        for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n            if (isFactoryMethod(am)) {\n                // And must take one of expected arg types (or supertype)\n                Class<?> actualArgType = am.getRawParameterType(0);\n                for (Class<?> expArgType : expArgTypes) {\n                    // And one that matches what we would pass in\n                    if (actualArgType.isAssignableFrom(expArgType)) {\n                        return am.getAnnotated();\n                    }\n                }\n            }\n        }\n        return null;\n    }\n```\n\nThis can be worked around by annotating static factory methods not intended to be used as `@JsonCreator`s with `@JsonIgnore`, due to the resolution in `_classInfo.getStaticMethods()`, so is not really urgent.\n\nPlease let me know if you have any questions about the issue!\n\nThanks,\nChris"
    }
  },
  "JacksonDatabind_30": {
    "buggy_hunks": {
      "0": {
        "start_line": 2510,
        "end_line": 2509,
        "file": "src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java",
        "code": "<START_BUG>\n<END_BUG>"
      },
      "1": {
        "start_line": 3426,
        "end_line": 3425,
        "file": "src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java",
        "code": "<START_BUG>\n<END_BUG>"
      },
      "2": {
        "start_line": 80,
        "end_line": 79,
        "file": "src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java",
        "code": "<START_BUG>\n<END_BUG>"
      },
      "3": {
        "start_line": 188,
        "end_line": 192,
        "file": "src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java",
        "code": "<START_BUG>\n    }\n\n    /**\n     * @since 2.7\n     */\n<END_BUG>"
      },
      "4": {
        "start_line": 959,
        "end_line": 963,
        "file": "src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java",
        "code": "<START_BUG>\n                /* 10-Oct-2015, tatu: Ideally we would first determine whether underlying\n                 *   number is already decoded into a number (in which case might as well\n                 *   access as number); or is still retained as text (in which case we\n                 *   should further defer decoding that may not need BigDecimal):\n                 */\n<END_BUG>"
      },
      "5": {
        "start_line": 973,
        "end_line": 972,
        "file": "src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java",
        "code": "<START_BUG>\n<END_BUG>"
      }
    },
    "buggy_code": {
      "0": {
        "start_line": 2504,
        "end_line": 2520,
        "file": "src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java",
        "code": "@SuppressWarnings({ \"unchecked\", \"resource\" })\n    public <T extends JsonNode> T valueToTree(Object fromValue)\n        throws IllegalArgumentException\n    {\n        if (fromValue == null) return null;\n        TokenBuffer buf = new TokenBuffer(this, false);\n        JsonNode result;\n        try {\n            writeValue(buf, fromValue);\n            JsonParser jp = buf.asParser();\n            result = readTree(jp);\n            jp.close();\n        } catch (IOException e) { // should not occur, no real i/o...\n            throw new IllegalArgumentException(e.getMessage(), e);\n        }\n        return (T) result;\n    }",
        "javadoc": "/**\n *  Reverse of {@link #treeToValue}; given a value (usually bean), will\n *  construct equivalent JSON Tree representation. Functionally similar\n *  to serializing value into JSON and parsing JSON as tree, but\n *  more efficient.\n * <p>\n *  NOTE: while results are usually identical to that of serialization followed\n *  by deserialization, this is not always the case. In some cases serialization\n *  into intermediate representation will retain encapsulation of things like\n *  raw value ({@link com.fasterxml.jackson.databind.util.RawValue}) or basic\n *  node identity ({@link JsonNode}). If so, result is a valid tree, but values\n *  are not re-constructed through actual JSON representation. So if transformation\n *  requires actual materialization of JSON (or other data format that this mapper\n *  produces), it will be necessary to do actual serialization.\n *\n *  @param <T> Actual node type; usually either basic {@link JsonNode} or\n *   {@link com.fasterxml.jackson.databind.node.ObjectNode}\n *  @param fromValue Bean value to convert\n *  @return Root node of the resulting JSON tree\n */\n"
      },
      "1": {
        "start_line": 3408,
        "end_line": 3455,
        "file": "src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java",
        "code": "@SuppressWarnings(\"resource\")\n    protected Object _convert(Object fromValue, JavaType toValueType)\n        throws IllegalArgumentException\n    {        \n        // also, as per [Issue-11], consider case for simple cast\n        /* But with caveats: one is that while everything is Object.class, we don't\n         * want to \"optimize\" that out; and the other is that we also do not want\n         * to lose conversions of generic types.\n         */\n        Class<?> targetType = toValueType.getRawClass();\n        if (targetType != Object.class\n                && !toValueType.hasGenericTypes()\n                && targetType.isAssignableFrom(fromValue.getClass())) {\n            return fromValue;\n        }\n        \n        // Then use TokenBuffer, which is a JsonGenerator:\n        TokenBuffer buf = new TokenBuffer(this, false);\n        try {\n            // inlined 'writeValue' with minor changes:\n            // first: disable wrapping when writing\n            SerializationConfig config = getSerializationConfig().without(SerializationFeature.WRAP_ROOT_VALUE);\n            // no need to check for closing of TokenBuffer\n            _serializerProvider(config).serializeValue(buf, fromValue);\n\n            // then matching read, inlined 'readValue' with minor mods:\n            final JsonParser jp = buf.asParser();\n            Object result;\n            // ok to pass in existing feature flags; unwrapping handled by mapper\n            final DeserializationConfig deserConfig = getDeserializationConfig();\n            JsonToken t = _initForReading(jp);\n            if (t == JsonToken.VALUE_NULL) {\n                DeserializationContext ctxt = createDeserializationContext(jp, deserConfig);\n                result = _findRootDeserializer(ctxt, toValueType).getNullValue(ctxt);\n            } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n                result = null;\n            } else { // pointing to event other than null\n                DeserializationContext ctxt = createDeserializationContext(jp, deserConfig);\n                JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, toValueType);\n                // note: no handling of unwarpping\n                result = deser.deserialize(jp, ctxt);\n            }\n            jp.close();\n            return result;\n        } catch (IOException e) { // should not occur, no real i/o...\n            throw new IllegalArgumentException(e.getMessage(), e);\n        }\n    }",
        "javadoc": "/**\n * Actual conversion implementation: instead of using existing read\n * and write methods, much of code is inlined. Reason for this is\n * that we must avoid root value wrapping/unwrapping both for efficiency and\n * for correctness. If root value wrapping/unwrapping is actually desired,\n * caller must use explicit <code>writeValue</code> and\n * <code>readValue</code> methods.\n */\n"
      },
      "2": {
        "start_line": 80,
        "end_line": 80,
        "file": "src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java",
        "code": "",
        "javadoc": "/**\n * @since 2.7\n */\n"
      },
      "3": {
        "start_line": 177,
        "end_line": 188,
        "file": "src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java",
        "code": "public TokenBuffer(JsonParser p, DeserializationContext ctxt)\n    {\n        _objectCodec = p.getCodec();\n        _generatorFeatures = DEFAULT_GENERATOR_FEATURES;\n        _writeContext = JsonWriteContext.createRootContext(null);\n        // at first we have just one segment\n        _first = _last = new Segment();\n        _appendAt = 0;\n        _hasNativeTypeIds = p.canReadTypeId();\n        _hasNativeObjectIds = p.canReadObjectId();\n        _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;\n    }",
        "javadoc": ""
      },
      "4": {
        "start_line": 917,
        "end_line": 990,
        "file": "src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java",
        "code": "@Override\n    public void copyCurrentEvent(JsonParser p) throws IOException\n    {\n        if (_mayHaveNativeIds) {\n            _checkNativeIds(p);\n        }\n        switch (p.getCurrentToken()) {\n        case START_OBJECT:\n            writeStartObject();\n            break;\n        case END_OBJECT:\n            writeEndObject();\n            break;\n        case START_ARRAY:\n            writeStartArray();\n            break;\n        case END_ARRAY:\n            writeEndArray();\n            break;\n        case FIELD_NAME:\n            writeFieldName(p.getCurrentName());\n            break;\n        case VALUE_STRING:\n            if (p.hasTextCharacters()) {\n                writeString(p.getTextCharacters(), p.getTextOffset(), p.getTextLength());\n            } else {\n                writeString(p.getText());\n            }\n            break;\n        case VALUE_NUMBER_INT:\n            switch (p.getNumberType()) {\n            case INT:\n                writeNumber(p.getIntValue());\n                break;\n            case BIG_INTEGER:\n                writeNumber(p.getBigIntegerValue());\n                break;\n            default:\n                writeNumber(p.getLongValue());\n            }\n            break;\n        case VALUE_NUMBER_FLOAT:\n                /* 10-Oct-2015, tatu: Ideally we would first determine whether underlying\n                 *   number is already decoded into a number (in which case might as well\n                 *   access as number); or is still retained as text (in which case we\n                 *   should further defer decoding that may not need BigDecimal):\n                 */\n                switch (p.getNumberType()) {\n                case BIG_DECIMAL:\n                    writeNumber(p.getDecimalValue());\n                    break;\n                case FLOAT:\n                    writeNumber(p.getFloatValue());\n                    break;\n                default:\n                    writeNumber(p.getDoubleValue());\n            }\n            break;\n        case VALUE_TRUE:\n            writeBoolean(true);\n            break;\n        case VALUE_FALSE:\n            writeBoolean(false);\n            break;\n        case VALUE_NULL:\n            writeNull();\n            break;\n        case VALUE_EMBEDDED_OBJECT:\n            writeObject(p.getEmbeddedObject());\n            break;\n        default:\n            throw new RuntimeException(\"Internal error: should never end up through this code path\");\n        }\n    }",
        "javadoc": ""
      }
    },
    "delineated_bug": {
      "0": {
        "start_line": 2504,
        "end_line": 2520,
        "file": "src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java",
        "code": "@SuppressWarnings({ \"unchecked\", \"resource\" })\n    public <T extends JsonNode> T valueToTree(Object fromValue)\n        throws IllegalArgumentException\n    {\n        if (fromValue == null) return null;\n        TokenBuffer buf = new TokenBuffer(this, false);\n<END_BUG>\n<START_BUG>\n        JsonNode result;\n        try {\n            writeValue(buf, fromValue);\n            JsonParser jp = buf.asParser();\n            result = readTree(jp);\n            jp.close();\n        } catch (IOException e) { // should not occur, no real i/o...\n            throw new IllegalArgumentException(e.getMessage(), e);\n        }\n        return (T) result;\n    }",
        "javadoc": "/**\n *  Reverse of {@link #treeToValue}; given a value (usually bean), will\n *  construct equivalent JSON Tree representation. Functionally similar\n *  to serializing value into JSON and parsing JSON as tree, but\n *  more efficient.\n * <p>\n *  NOTE: while results are usually identical to that of serialization followed\n *  by deserialization, this is not always the case. In some cases serialization\n *  into intermediate representation will retain encapsulation of things like\n *  raw value ({@link com.fasterxml.jackson.databind.util.RawValue}) or basic\n *  node identity ({@link JsonNode}). If so, result is a valid tree, but values\n *  are not re-constructed through actual JSON representation. So if transformation\n *  requires actual materialization of JSON (or other data format that this mapper\n *  produces), it will be necessary to do actual serialization.\n *\n *  @param <T> Actual node type; usually either basic {@link JsonNode} or\n *   {@link com.fasterxml.jackson.databind.node.ObjectNode}\n *  @param fromValue Bean value to convert\n *  @return Root node of the resulting JSON tree\n */\n"
      },
      "1": {
        "start_line": 3408,
        "end_line": 3455,
        "file": "src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java",
        "code": "@SuppressWarnings(\"resource\")\n    protected Object _convert(Object fromValue, JavaType toValueType)\n        throws IllegalArgumentException\n    {        \n        // also, as per [Issue-11], consider case for simple cast\n        /* But with caveats: one is that while everything is Object.class, we don't\n         * want to \"optimize\" that out; and the other is that we also do not want\n         * to lose conversions of generic types.\n         */\n        Class<?> targetType = toValueType.getRawClass();\n        if (targetType != Object.class\n                && !toValueType.hasGenericTypes()\n                && targetType.isAssignableFrom(fromValue.getClass())) {\n            return fromValue;\n        }\n        \n        // Then use TokenBuffer, which is a JsonGenerator:\n        TokenBuffer buf = new TokenBuffer(this, false);\n<END_BUG>\n<START_BUG>\n        try {\n            // inlined 'writeValue' with minor changes:\n            // first: disable wrapping when writing\n            SerializationConfig config = getSerializationConfig().without(SerializationFeature.WRAP_ROOT_VALUE);\n            // no need to check for closing of TokenBuffer\n            _serializerProvider(config).serializeValue(buf, fromValue);\n\n            // then matching read, inlined 'readValue' with minor mods:\n            final JsonParser jp = buf.asParser();\n            Object result;\n            // ok to pass in existing feature flags; unwrapping handled by mapper\n            final DeserializationConfig deserConfig = getDeserializationConfig();\n            JsonToken t = _initForReading(jp);\n            if (t == JsonToken.VALUE_NULL) {\n                DeserializationContext ctxt = createDeserializationContext(jp, deserConfig);\n                result = _findRootDeserializer(ctxt, toValueType).getNullValue(ctxt);\n            } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n                result = null;\n            } else { // pointing to event other than null\n                DeserializationContext ctxt = createDeserializationContext(jp, deserConfig);\n                JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, toValueType);\n                // note: no handling of unwarpping\n                result = deser.deserialize(jp, ctxt);\n            }\n            jp.close();\n            return result;\n        } catch (IOException e) { // should not occur, no real i/o...\n            throw new IllegalArgumentException(e.getMessage(), e);\n        }\n    }",
        "javadoc": "/**\n * Actual conversion implementation: instead of using existing read\n * and write methods, much of code is inlined. Reason for this is\n * that we must avoid root value wrapping/unwrapping both for efficiency and\n * for correctness. If root value wrapping/unwrapping is actually desired,\n * caller must use explicit <code>writeValue</code> and\n * <code>readValue</code> methods.\n */\n"
      },
      "2": {
        "start_line": 80,
        "end_line": 80,
        "file": "src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java",
        "code": "<START_BUG>\n\n<END_BUG>",
        "javadoc": "/**\n * @since 2.7\n */\n"
      },
      "3": {
        "start_line": 177,
        "end_line": 188,
        "file": "src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java",
        "code": "public TokenBuffer(JsonParser p, DeserializationContext ctxt)\n    {\n        _objectCodec = p.getCodec();\n        _generatorFeatures = DEFAULT_GENERATOR_FEATURES;\n        _writeContext = JsonWriteContext.createRootContext(null);\n        // at first we have just one segment\n        _first = _last = new Segment();\n        _appendAt = 0;\n        _hasNativeTypeIds = p.canReadTypeId();\n        _hasNativeObjectIds = p.canReadObjectId();\n        _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;\n<START_BUG>\n    }\n<END_BUG>",
        "javadoc": ""
      },
      "4": {
        "start_line": 917,
        "end_line": 990,
        "file": "src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java",
        "code": "@Override\n    public void copyCurrentEvent(JsonParser p) throws IOException\n    {\n        if (_mayHaveNativeIds) {\n            _checkNativeIds(p);\n        }\n        switch (p.getCurrentToken()) {\n        case START_OBJECT:\n            writeStartObject();\n            break;\n        case END_OBJECT:\n            writeEndObject();\n            break;\n        case START_ARRAY:\n            writeStartArray();\n            break;\n        case END_ARRAY:\n            writeEndArray();\n            break;\n        case FIELD_NAME:\n            writeFieldName(p.getCurrentName());\n            break;\n        case VALUE_STRING:\n            if (p.hasTextCharacters()) {\n                writeString(p.getTextCharacters(), p.getTextOffset(), p.getTextLength());\n            } else {\n                writeString(p.getText());\n            }\n            break;\n        case VALUE_NUMBER_INT:\n            switch (p.getNumberType()) {\n            case INT:\n                writeNumber(p.getIntValue());\n                break;\n            case BIG_INTEGER:\n                writeNumber(p.getBigIntegerValue());\n                break;\n            default:\n                writeNumber(p.getLongValue());\n            }\n            break;\n        case VALUE_NUMBER_FLOAT:\n<START_BUG>\n                /* 10-Oct-2015, tatu: Ideally we would first determine whether underlying\n                 *   number is already decoded into a number (in which case might as well\n                 *   access as number); or is still retained as text (in which case we\n                 *   should further defer decoding that may not need BigDecimal):\n                 */\n<END_BUG>\n                switch (p.getNumberType()) {\n                case BIG_DECIMAL:\n                    writeNumber(p.getDecimalValue());\n                    break;\n                case FLOAT:\n                    writeNumber(p.getFloatValue());\n                    break;\n                default:\n                    writeNumber(p.getDoubleValue());\n<END_BUG>\n<START_BUG>\n            }\n            break;\n        case VALUE_TRUE:\n            writeBoolean(true);\n            break;\n        case VALUE_FALSE:\n            writeBoolean(false);\n            break;\n        case VALUE_NULL:\n            writeNull();\n            break;\n        case VALUE_EMBEDDED_OBJECT:\n            writeObject(p.getEmbeddedObject());\n            break;\n        default:\n            throw new RuntimeException(\"Internal error: should never end up through this code path\");\n        }\n    }",
        "javadoc": ""
      }
    },
    "contained_scope": "file",
    "bug_count": 5,
    "triggered_tests": {
      "0": {
        "test_path": "com.fasterxml.jackson.databind.jsontype.TestExternalId",
        "test_method": "testBigDecimal965",
        "test_code": "testBigDecimal965() throws Exception\n    {\n\n        Wrapper965 w = new Wrapper965();\n        w.typeEnum = Type965.BIG_DECIMAL;\n        final String NUM_STR = \"-10000000000.0000000001\";\n        w.value = new BigDecimal(NUM_STR);\n\n        String json = MAPPER.writeValueAsString(w);\n\n        // simple sanity check so serialization is faithful\n        if (!json.contains(NUM_STR)) {\n            fail(\"JSON content should contain value '\"+NUM_STR+\"', does not appear to: \"+json);\n        }\n        \n        Wrapper965 w2 = MAPPER.readerFor(Wrapper965.class)\n                .with(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)\n                .readValue(json);\n\n        assertEquals(w.typeEnum, w2.typeEnum);\n        assertTrue(String.format(\"Expected %s = %s; got back %s = %s\",\n            w.value.getClass().getSimpleName(), w.value.toString(), w2.value.getClass().getSimpleName(), w2.value.toString()),\n            w.value.equals(w2.value));\n    }",
        "clean_err_msg": "junit.framework.AssertionFailedError: Expected BigDecimal = -10000000000.0000000001; got back BigDecimal = -1.0E+10"
      }
    },
    "buggy_files": {
      "0": "src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java",
      "1": "src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java"
    },
    "hunk_type": "multi_file_four_or_more_hunks",
    "hunk_mapping": {
      "0": [
        {
          "start_line": 2510,
          "end_line": 2509,
          "file": "src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java",
          "code": "<START_BUG>\n<END_BUG>"
        }
      ],
      "1": [
        {
          "start_line": 3426,
          "end_line": 3425,
          "file": "src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java",
          "code": "<START_BUG>\n<END_BUG>"
        }
      ],
      "2": [
        {
          "start_line": 80,
          "end_line": 79,
          "file": "src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java",
          "code": "<START_BUG>\n<END_BUG>"
        }
      ],
      "3": [
        {
          "start_line": 188,
          "end_line": 192,
          "file": "src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java",
          "code": "<START_BUG>\n    }\n\n    /**\n     * @since 2.7\n     */\n<END_BUG>"
        }
      ],
      "4": [
        {
          "start_line": 959,
          "end_line": 963,
          "file": "src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java",
          "code": "<START_BUG>\n                /* 10-Oct-2015, tatu: Ideally we would first determine whether underlying\n                 *   number is already decoded into a number (in which case might as well\n                 *   access as number); or is still retained as text (in which case we\n                 *   should further defer decoding that may not need BigDecimal):\n                 */\n<END_BUG>"
        },
        {
          "start_line": 973,
          "end_line": 972,
          "file": "src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java",
          "code": "<START_BUG>\n<END_BUG>"
        }
      ]
    },
    "bug_report": {
      "url": "https://github.com/FasterXML/jackson-databind/issues/965",
      "title": "BigDecimal values via @JsonTypeInfo/@JsonSubTypes get rounded",
      "bug_description": "When using an `ObjectMapper` to serialize/deserialize a class with an `Object` field annotated with a `@JsonSubTypes.Type` that indicate `BigDecimal`, it looks like the value is getting rounded to a double.\n\nI tried configuring `DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS`, but that didn't seem to help.\n\nWhat I think is a valid repro is below, but let me know if I'm actually doing something wrong here.\n\nThanks!\n\n``` java\nimport org.junit.Test;\nimport org.junit.Assert;\n\nimport java.math.BigDecimal;\n\nimport com.fasterxml.jackson.annotation.*;\nimport com.fasterxml.jackson.databind.DeserializationFeature;\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\npublic class JacksonTest {\n\n    enum Type { BIG_DECIMAL }\n\n    static class Wrapper {\n\n        @JsonIgnore\n        Type typeEnum;\n\n        @JsonIgnore\n        Object value;\n\n        Wrapper() { }\n\n        @JsonGetter(value = \"type\")\n        String getTypeString() {\n            return typeEnum.name();\n        }\n\n        @JsonSetter(value = \"type\")\n        void setTypeString(String type) {\n            this.typeEnum = Type.valueOf(type);\n        }\n\n        @JsonGetter(value = \"objectValue\") \n        Object getValue() {\n            return value;\n        }\n\n        @JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.EXTERNAL_PROPERTY, property = \"type\")\n        @JsonSubTypes({ @JsonSubTypes.Type(name = \"BIG_DECIMAL\", value = BigDecimal.class) })\n        @JsonSetter(value = \"objectValue\") \n        private void setValue(Object value) {\n            this.value = value;\n        }\n    }\n\n    @Test\n    public void test() throws Exception {\n\n        ObjectMapper m = new ObjectMapper();\n        m.configure(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS, true);\n\n        Wrapper w = new Wrapper();\n        w.typeEnum = Type.BIG_DECIMAL;\n        w.value = new BigDecimal(\"-10000000000.0000000001\");\n\n        String json = m.writeValueAsString(w);\n        Wrapper w2 = m.readValue(json, Wrapper.class);\n\n        Assert.assertEquals(w.typeEnum, w2.typeEnum);\n        Assert.assertTrue(String.format(\"Expected %s = %s; got back %s = %s\",\n            w.value.getClass().getSimpleName(), w.value.toString(), w2.value.getClass().getSimpleName(), w2.value.toString()),\n            w.value.equals(w2.value));\n    }\n}\n```"
    }
  },
  "Compress_33": {
    "buggy_hunks": {
      "0": {
        "start_line": 240,
        "end_line": 239,
        "file": "src/main/java/org/apache/commons/compress/compressors/CompressorStreamFactory.java",
        "code": "<START_BUG>\n<END_BUG>"
      },
      "1": {
        "start_line": 33,
        "end_line": 32,
        "file": "src/main/java/org/apache/commons/compress/compressors/deflate/DeflateCompressorInputStream.java",
        "code": "<START_BUG>\n<END_BUG>"
      },
      "2": {
        "start_line": 106,
        "end_line": 106,
        "file": "src/main/java/org/apache/commons/compress/compressors/deflate/DeflateCompressorInputStream.java",
        "code": "<START_BUG>\n}\n<END_BUG>"
      }
    },
    "buggy_code": {
      "0": {
        "start_line": 204,
        "end_line": 256,
        "file": "src/main/java/org/apache/commons/compress/compressors/CompressorStreamFactory.java",
        "code": "public CompressorInputStream createCompressorInputStream(final InputStream in)\n            throws CompressorException {\n        if (in == null) {\n            throw new IllegalArgumentException(\"Stream must not be null.\");\n        }\n\n        if (!in.markSupported()) {\n            throw new IllegalArgumentException(\"Mark is not supported.\");\n        }\n\n        final byte[] signature = new byte[12];\n        in.mark(signature.length);\n        try {\n            int signatureLength = IOUtils.readFully(in, signature);\n            in.reset();\n\n            if (BZip2CompressorInputStream.matches(signature, signatureLength)) {\n                return new BZip2CompressorInputStream(in, decompressConcatenated);\n            }\n\n            if (GzipCompressorInputStream.matches(signature, signatureLength)) {\n                return new GzipCompressorInputStream(in, decompressConcatenated);\n            }\n\n            if (Pack200CompressorInputStream.matches(signature, signatureLength)) {\n                return new Pack200CompressorInputStream(in);\n            }\n\n            if (FramedSnappyCompressorInputStream.matches(signature, signatureLength)) {\n                return new FramedSnappyCompressorInputStream(in);\n            }\n\n            if (ZCompressorInputStream.matches(signature, signatureLength)) {\n                return new ZCompressorInputStream(in);\n            }\n\n\n            if (XZUtils.matches(signature, signatureLength) &&\n                XZUtils.isXZCompressionAvailable()) {\n                return new XZCompressorInputStream(in, decompressConcatenated);\n            }\n\n            if (LZMAUtils.matches(signature, signatureLength) &&\n                LZMAUtils.isLZMACompressionAvailable()) {\n                return new LZMACompressorInputStream(in);\n            }\n\n        } catch (IOException e) {\n            throw new CompressorException(\"Failed to detect Compressor from InputStream.\", e);\n        }\n\n        throw new CompressorException(\"No Compressor found for the stream signature.\");\n    }",
        "javadoc": "/**\n * Create an compressor input stream from an input stream, autodetecting\n * the compressor type from the first few bytes of the stream. The InputStream\n * must support marks, like BufferedInputStream.\n *\n * @param in the input stream\n * @return the compressor input stream\n * @throws CompressorException if the compressor name is not known\n * @throws IllegalArgumentException if the stream is null or does not support mark\n * @since 1.1\n */\n"
      },
      "1": {
        "start_line": 33,
        "end_line": 33,
        "file": "src/main/java/org/apache/commons/compress/compressors/deflate/DeflateCompressorInputStream.java",
        "code": "",
        "javadoc": ""
      },
      "2": {
        "start_line": 106,
        "end_line": 106,
        "file": "src/main/java/org/apache/commons/compress/compressors/deflate/DeflateCompressorInputStream.java",
        "code": "}",
        "javadoc": ""
      }
    },
    "delineated_bug": {
      "0": {
        "start_line": 204,
        "end_line": 256,
        "file": "src/main/java/org/apache/commons/compress/compressors/CompressorStreamFactory.java",
        "code": "public CompressorInputStream createCompressorInputStream(final InputStream in)\n            throws CompressorException {\n        if (in == null) {\n            throw new IllegalArgumentException(\"Stream must not be null.\");\n        }\n\n        if (!in.markSupported()) {\n            throw new IllegalArgumentException(\"Mark is not supported.\");\n        }\n\n        final byte[] signature = new byte[12];\n        in.mark(signature.length);\n        try {\n            int signatureLength = IOUtils.readFully(in, signature);\n            in.reset();\n\n            if (BZip2CompressorInputStream.matches(signature, signatureLength)) {\n                return new BZip2CompressorInputStream(in, decompressConcatenated);\n            }\n\n            if (GzipCompressorInputStream.matches(signature, signatureLength)) {\n                return new GzipCompressorInputStream(in, decompressConcatenated);\n            }\n\n            if (Pack200CompressorInputStream.matches(signature, signatureLength)) {\n                return new Pack200CompressorInputStream(in);\n            }\n\n            if (FramedSnappyCompressorInputStream.matches(signature, signatureLength)) {\n                return new FramedSnappyCompressorInputStream(in);\n            }\n\n            if (ZCompressorInputStream.matches(signature, signatureLength)) {\n                return new ZCompressorInputStream(in);\n            }\n\n<END_BUG>\n<START_BUG>\n\n            if (XZUtils.matches(signature, signatureLength) &&\n                XZUtils.isXZCompressionAvailable()) {\n                return new XZCompressorInputStream(in, decompressConcatenated);\n            }\n\n            if (LZMAUtils.matches(signature, signatureLength) &&\n                LZMAUtils.isLZMACompressionAvailable()) {\n                return new LZMACompressorInputStream(in);\n            }\n\n        } catch (IOException e) {\n            throw new CompressorException(\"Failed to detect Compressor from InputStream.\", e);\n        }\n\n        throw new CompressorException(\"No Compressor found for the stream signature.\");\n    }",
        "javadoc": "/**\n * Create an compressor input stream from an input stream, autodetecting\n * the compressor type from the first few bytes of the stream. The InputStream\n * must support marks, like BufferedInputStream.\n *\n * @param in the input stream\n * @return the compressor input stream\n * @throws CompressorException if the compressor name is not known\n * @throws IllegalArgumentException if the stream is null or does not support mark\n * @since 1.1\n */\n"
      },
      "1": {
        "start_line": 33,
        "end_line": 33,
        "file": "src/main/java/org/apache/commons/compress/compressors/deflate/DeflateCompressorInputStream.java",
        "code": "<START_BUG>\n\n<END_BUG>",
        "javadoc": ""
      },
      "2": {
        "start_line": 106,
        "end_line": 106,
        "file": "src/main/java/org/apache/commons/compress/compressors/deflate/DeflateCompressorInputStream.java",
        "code": "<START_BUG>\n}\n<END_BUG>",
        "javadoc": ""
      }
    },
    "contained_scope": "file",
    "bug_count": 3,
    "triggered_tests": {
      "0": {
        "test_path": "org.apache.commons.compress.compressors.DetectCompressorTestCase",
        "test_method": "testDetection",
        "test_code": "testDetection() throws Exception {\n        CompressorInputStream bzip2 = getStreamFor(\"bla.txt.bz2\"); \n        assertNotNull(bzip2);\n        assertTrue(bzip2 instanceof BZip2CompressorInputStream);\n\n        CompressorInputStream gzip = getStreamFor(\"bla.tgz\");\n        assertNotNull(gzip);\n        assertTrue(gzip instanceof GzipCompressorInputStream);\n        \n        CompressorInputStream pack200 = getStreamFor(\"bla.pack\");\n        assertNotNull(pack200);\n        assertTrue(pack200 instanceof Pack200CompressorInputStream);\n\n        CompressorInputStream xz = getStreamFor(\"bla.tar.xz\");\n        assertNotNull(xz);\n        assertTrue(xz instanceof XZCompressorInputStream);\n\n        CompressorInputStream zlib = getStreamFor(\"bla.tar.deflatez\");\n        assertNotNull(zlib);\n        assertTrue(zlib instanceof DeflateCompressorInputStream);\n\n        try {\n            factory.createCompressorInputStream(new ByteArrayInputStream(new byte[0]));\n            fail(\"No exception thrown for an empty input stream\");\n        } catch (CompressorException e) {\n            // expected\n        }\n    }",
        "clean_err_msg": "org.apache.commons.compress.compressors.CompressorException: No Compressor found for the stream signature."
      }
    },
    "buggy_files": {
      "0": "src/main/java/org/apache/commons/compress/compressors/CompressorStreamFactory.java",
      "1": "src/main/java/org/apache/commons/compress/compressors/deflate/DeflateCompressorInputStream.java"
    },
    "hunk_type": "multi_file_three_hunks",
    "hunk_mapping": {
      "0": [
        {
          "start_line": 240,
          "end_line": 239,
          "file": "src/main/java/org/apache/commons/compress/compressors/CompressorStreamFactory.java",
          "code": "<START_BUG>\n<END_BUG>"
        }
      ],
      "1": [
        {
          "start_line": 33,
          "end_line": 32,
          "file": "src/main/java/org/apache/commons/compress/compressors/deflate/DeflateCompressorInputStream.java",
          "code": "<START_BUG>\n<END_BUG>"
        }
      ],
      "2": [
        {
          "start_line": 106,
          "end_line": 106,
          "file": "src/main/java/org/apache/commons/compress/compressors/deflate/DeflateCompressorInputStream.java",
          "code": "<START_BUG>\n}\n<END_BUG>"
        }
      ]
    },
    "bug_report": {
      "url": "https://issues.apache.org/jira/browse/COMPRESS-316",
      "title": "CompressorStreamFactory doesn't handle deflate streams with a zlib header",
      "bug_description": "If you take a zlib / deflate compressed file, with the zlib header (eg the test file bla.tar.deflatez) and pass it to CompressorStreamFactory.createCompressorInputStream, it won't be detected and you'll get a CompressorException(\"No Compressor found for the stream signature.\")\nWhile detecting header-less zlib files is probably too tricky to manage, those with the header ought to be possible to spot and handle"
    }
  },
  "JacksonCore_18": {
    "buggy_hunks": {
      "0": {
        "start_line": 53,
        "end_line": 52,
        "file": "src/main/java/com/fasterxml/jackson/core/base/GeneratorBase.java",
        "code": "<START_BUG>\n<END_BUG>"
      },
      "1": {
        "start_line": 434,
        "end_line": 434,
        "file": "src/main/java/com/fasterxml/jackson/core/base/GeneratorBase.java",
        "code": "<START_BUG>\n            // 24-Aug-2016, tatu: [core#315] prevent possible DoS vector\n<END_BUG>"
      },
      "2": {
        "start_line": 910,
        "end_line": 913,
        "file": "src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "code": "<START_BUG>\n            String raw = Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features) ? value.toPlainString() : value.toString();\n            _writeQuotedRaw(raw);\n        } else if (Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features)) {\n            writeRaw(value.toPlainString());\n<END_BUG>"
      },
      "3": {
        "start_line": 687,
        "end_line": 690,
        "file": "src/main/java/com/fasterxml/jackson/core/json/WriterBasedJsonGenerator.java",
        "code": "<START_BUG>\n            String raw = isEnabled(Feature.WRITE_BIGDECIMAL_AS_PLAIN) ? value.toPlainString() : value.toString();\n            _writeQuotedRaw(raw);\n        } else if (isEnabled(Feature.WRITE_BIGDECIMAL_AS_PLAIN)) {\n            writeRaw(value.toPlainString());\n<END_BUG>"
      }
    },
    "buggy_code": {
      "0": {
        "start_line": 53,
        "end_line": 53,
        "file": "src/main/java/com/fasterxml/jackson/core/base/GeneratorBase.java",
        "code": "",
        "javadoc": "/**\n * Helper method used to serialize a {@link java.math.BigDecimal} as a String,\n * for serialization, taking into account configuration settings\n *\n * @since 2.7.7\n */\n"
      },
      "1": {
        "start_line": 433,
        "end_line": 436,
        "file": "src/main/java/com/fasterxml/jackson/core/base/GeneratorBase.java",
        "code": "protected String _asString(BigDecimal value) throws IOException {\n            // 24-Aug-2016, tatu: [core#315] prevent possible DoS vector\n        return value.toString();\n    }",
        "javadoc": ""
      },
      "2": {
        "start_line": 902,
        "end_line": 917,
        "file": "src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "code": "@Override\n    public void writeNumber(BigDecimal value) throws IOException\n    {\n        // Don't really know max length for big decimal, no point checking\n        _verifyValueWrite(WRITE_NUMBER);\n        if (value == null) {\n            _writeNull();\n        } else  if (_cfgNumbersAsStrings) {\n            String raw = Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features) ? value.toPlainString() : value.toString();\n            _writeQuotedRaw(raw);\n        } else if (Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features)) {\n            writeRaw(value.toPlainString());\n        } else {\n            writeRaw(_asString(value));\n        }\n    }",
        "javadoc": ""
      },
      "3": {
        "start_line": 679,
        "end_line": 694,
        "file": "src/main/java/com/fasterxml/jackson/core/json/WriterBasedJsonGenerator.java",
        "code": "@Override\n    public void writeNumber(BigDecimal value) throws IOException\n    {\n        // Don't really know max length for big decimal, no point checking\n        _verifyValueWrite(WRITE_NUMBER);\n        if (value == null) {\n            _writeNull();\n        } else  if (_cfgNumbersAsStrings) {\n            String raw = isEnabled(Feature.WRITE_BIGDECIMAL_AS_PLAIN) ? value.toPlainString() : value.toString();\n            _writeQuotedRaw(raw);\n        } else if (isEnabled(Feature.WRITE_BIGDECIMAL_AS_PLAIN)) {\n            writeRaw(value.toPlainString());\n        } else {\n            writeRaw(_asString(value));\n        }\n    }",
        "javadoc": ""
      }
    },
    "delineated_bug": {
      "0": {
        "start_line": 53,
        "end_line": 53,
        "file": "src/main/java/com/fasterxml/jackson/core/base/GeneratorBase.java",
        "code": "<START_BUG>\n\n<END_BUG>",
        "javadoc": "/**\n * Helper method used to serialize a {@link java.math.BigDecimal} as a String,\n * for serialization, taking into account configuration settings\n *\n * @since 2.7.7\n */\n"
      },
      "1": {
        "start_line": 433,
        "end_line": 436,
        "file": "src/main/java/com/fasterxml/jackson/core/base/GeneratorBase.java",
        "code": "protected String _asString(BigDecimal value) throws IOException {\n<START_BUG>\n            // 24-Aug-2016, tatu: [core#315] prevent possible DoS vector\n<END_BUG>\n        return value.toString();\n    }",
        "javadoc": ""
      },
      "2": {
        "start_line": 902,
        "end_line": 917,
        "file": "src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "code": "@Override\n    public void writeNumber(BigDecimal value) throws IOException\n    {\n        // Don't really know max length for big decimal, no point checking\n        _verifyValueWrite(WRITE_NUMBER);\n        if (value == null) {\n            _writeNull();\n        } else  if (_cfgNumbersAsStrings) {\n<START_BUG>\n            String raw = Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features) ? value.toPlainString() : value.toString();\n            _writeQuotedRaw(raw);\n        } else if (Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features)) {\n            writeRaw(value.toPlainString());\n<END_BUG>\n        } else {\n            writeRaw(_asString(value));\n        }\n    }",
        "javadoc": ""
      },
      "3": {
        "start_line": 679,
        "end_line": 694,
        "file": "src/main/java/com/fasterxml/jackson/core/json/WriterBasedJsonGenerator.java",
        "code": "@Override\n    public void writeNumber(BigDecimal value) throws IOException\n    {\n        // Don't really know max length for big decimal, no point checking\n        _verifyValueWrite(WRITE_NUMBER);\n        if (value == null) {\n            _writeNull();\n        } else  if (_cfgNumbersAsStrings) {\n<START_BUG>\n            String raw = isEnabled(Feature.WRITE_BIGDECIMAL_AS_PLAIN) ? value.toPlainString() : value.toString();\n            _writeQuotedRaw(raw);\n        } else if (isEnabled(Feature.WRITE_BIGDECIMAL_AS_PLAIN)) {\n            writeRaw(value.toPlainString());\n<END_BUG>\n        } else {\n            writeRaw(_asString(value));\n        }\n    }",
        "javadoc": ""
      }
    },
    "contained_scope": "file",
    "bug_count": 4,
    "triggered_tests": {
      "0": {
        "test_path": "com.fasterxml.jackson.core.json.TestJsonGeneratorFeatures",
        "test_method": "testTooBigBigDecimal",
        "test_code": "testTooBigBigDecimal() throws Exception\n    {\n        JsonFactory f = new JsonFactory();\n        f.enable(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN);\n\n        // 24-Aug-2016, tatu: Initial check limits scale to [-9999,+9999]\n        BigDecimal BIG = new BigDecimal(\"1E+9999\");\n        BigDecimal TOO_BIG = new BigDecimal(\"1E+10000\");\n        BigDecimal SMALL = new BigDecimal(\"1E-9999\");\n        BigDecimal TOO_SMALL = new BigDecimal(\"1E-10000\");\n\n        for (boolean useBytes : new boolean[] { false, true } ) {\n            for (boolean asString : new boolean[] { false, true } ) {\n                JsonGenerator g;\n                \n                if (useBytes) {\n                    g = f.createGenerator(new ByteArrayOutputStream());\n                } else {\n                    g = f.createGenerator(new StringWriter());\n                }\n                if (asString) {\n                    g.enable(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS);\n                }\n\n                // first, ok cases:\n                g.writeStartArray();\n                g.writeNumber(BIG);\n                g.writeNumber(SMALL);\n                g.writeEndArray();\n                g.close();\n\n                // then invalid\n                for (BigDecimal input : new BigDecimal[] { TOO_BIG, TOO_SMALL }) {\n                    if (useBytes) {\n                        g = f.createGenerator(new ByteArrayOutputStream());\n                    } else {\n                        g = f.createGenerator(new StringWriter());\n                    }\n                    if (asString) {\n                        g.enable(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS);\n                    }\n                    try {\n                        g.writeNumber(input);\n                        fail(\"Should not have written without exception: \"+input);\n                    } catch (JsonGenerationException e) {\n                        verifyException(e, \"Attempt to write plain `java.math.BigDecimal`\");\n                        verifyException(e, \"illegal scale\");\n                    }\n                    g.close();\n                }\n            }\n        }\n    }",
        "clean_err_msg": "junit.framework.AssertionFailedError: Should not have written without exception: 1E+10000"
      }
    },
    "buggy_files": {
      "0": "src/main/java/com/fasterxml/jackson/core/base/GeneratorBase.java",
      "1": "src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
      "2": "src/main/java/com/fasterxml/jackson/core/json/WriterBasedJsonGenerator.java"
    },
    "hunk_type": "multi_file_four_or_more_hunks",
    "hunk_mapping": {
      "0": [
        {
          "start_line": 53,
          "end_line": 52,
          "file": "src/main/java/com/fasterxml/jackson/core/base/GeneratorBase.java",
          "code": "<START_BUG>\n<END_BUG>"
        }
      ],
      "1": [
        {
          "start_line": 434,
          "end_line": 434,
          "file": "src/main/java/com/fasterxml/jackson/core/base/GeneratorBase.java",
          "code": "<START_BUG>\n            // 24-Aug-2016, tatu: [core#315] prevent possible DoS vector\n<END_BUG>"
        }
      ],
      "2": [
        {
          "start_line": 910,
          "end_line": 913,
          "file": "src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
          "code": "<START_BUG>\n            String raw = Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features) ? value.toPlainString() : value.toString();\n            _writeQuotedRaw(raw);\n        } else if (Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features)) {\n            writeRaw(value.toPlainString());\n<END_BUG>"
        }
      ],
      "3": [
        {
          "start_line": 687,
          "end_line": 690,
          "file": "src/main/java/com/fasterxml/jackson/core/json/WriterBasedJsonGenerator.java",
          "code": "<START_BUG>\n            String raw = isEnabled(Feature.WRITE_BIGDECIMAL_AS_PLAIN) ? value.toPlainString() : value.toString();\n            _writeQuotedRaw(raw);\n        } else if (isEnabled(Feature.WRITE_BIGDECIMAL_AS_PLAIN)) {\n            writeRaw(value.toPlainString());\n<END_BUG>"
        }
      ]
    },
    "bug_report": {
      "url": "https://github.com/FasterXML/jackson-core/issues/315",
      "title": "OutOfMemoryError when writing BigDecimal",
      "bug_description": "(note: moved from https://github.com/FasterXML/jackson-databind/issues/1316 reported by @gmethvin)\n\nWhen I've enabled the `WRITE_BIGDECIMAL_AS_PLAIN` setting on Jackson 2.7.5, Jackson will attempt to write out the whole number, no matter how large the exponent.\n\nFor example, the following code:\n\n``` java\nObjectMapper mapper = new ObjectMapper().enable(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN);\nmapper.writeValueAsString(new java.math.BigDecimal(\"9.223372E+1010671858\"));\n```\n\ntriggers the exception:\n\n```\njava.lang.OutOfMemoryError: Java heap space\n  at java.lang.AbstractStringBuilder.<init>(AbstractStringBuilder.java:68)\n  at java.lang.StringBuilder.<init>(StringBuilder.java:101)\n  at java.math.BigDecimal.toPlainString(BigDecimal.java:2964)\n  at com.fasterxml.jackson.core.json.WriterBasedJsonGenerator.writeNumber(WriterBasedJsonGenerator.java:690)\n  at com.fasterxml.jackson.databind.ser.std.NumberSerializer.serialize(NumberSerializer.java:45)\n  at com.fasterxml.jackson.databind.ser.std.NumberSerializer.serialize(NumberSerializer.java:19)\n  at com.fasterxml.jackson.databind.ser.DefaultSerializerProvider.serializeValue(DefaultSerializerProvider.java:130)\n  at com.fasterxml.jackson.databind.ObjectMapper._configAndWriteValue(ObjectMapper.java:3612)\n  at com.fasterxml.jackson.databind.ObjectMapper.writeValueAsString(ObjectMapper.java:2980)\n  ... 23 elided\n```\n\nI know technically Jackson is doing what you're telling it to do (so if you don't feel this is an issue feel free to close it). But it would be nice if `WRITE_BIGDECIMAL_AS_PLAIN` set a reasonable length on the number, so as not to leave users open to denial of service vulnerabilities.\n\n(Actually, I think this might technically be an issue in jackson-core; let me know if I should resubmit.)"
    }
  },
  "Math_14": {
    "buggy_hunks": {
      "0": {
        "start_line": 267,
        "end_line": 267,
        "file": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizer.java",
        "code": "<START_BUG>\n            final EigenDecomposition dec = new EigenDecomposition(m);\n<END_BUG>"
      },
      "1": {
        "start_line": 43,
        "end_line": 46,
        "file": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/Weight.java",
        "code": "<START_BUG>\n        weightMatrix = org.apache.commons.math3.linear.MatrixUtils.createRealMatrix(dim, dim);\n        for (int i = 0; i < dim; i++) {\n            weightMatrix.setEntry(i, i, weight[i]);\n        }\n<END_BUG>"
      }
    },
    "buggy_code": {
      "0": {
        "start_line": 266,
        "end_line": 269,
        "file": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizer.java",
        "code": "private RealMatrix squareRoot(RealMatrix m) {\n            final EigenDecomposition dec = new EigenDecomposition(m);\n            return dec.getSquareRoot();\n    }",
        "javadoc": "/**\n * Computes the square-root of the weight matrix.\n *\n * @param m Symmetric, positive-definite (weight) matrix.\n * @return the square-root of the weight matrix.\n */\n"
      },
      "1": {
        "start_line": 41,
        "end_line": 47,
        "file": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/Weight.java",
        "code": "public Weight(double[] weight) {\n        final int dim = weight.length;\n        weightMatrix = org.apache.commons.math3.linear.MatrixUtils.createRealMatrix(dim, dim);\n        for (int i = 0; i < dim; i++) {\n            weightMatrix.setEntry(i, i, weight[i]);\n        }\n    }",
        "javadoc": "/**\n * Creates a diagonal weight matrix.\n *\n * @param weight List of the values of the diagonal.\n */\n"
      }
    },
    "delineated_bug": {
      "0": {
        "start_line": 266,
        "end_line": 269,
        "file": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizer.java",
        "code": "private RealMatrix squareRoot(RealMatrix m) {\n<START_BUG>\n            final EigenDecomposition dec = new EigenDecomposition(m);\n<END_BUG>\n            return dec.getSquareRoot();\n    }",
        "javadoc": "/**\n * Computes the square-root of the weight matrix.\n *\n * @param m Symmetric, positive-definite (weight) matrix.\n * @return the square-root of the weight matrix.\n */\n"
      },
      "1": {
        "start_line": 41,
        "end_line": 47,
        "file": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/Weight.java",
        "code": "public Weight(double[] weight) {\n        final int dim = weight.length;\n<START_BUG>\n        weightMatrix = org.apache.commons.math3.linear.MatrixUtils.createRealMatrix(dim, dim);\n        for (int i = 0; i < dim; i++) {\n            weightMatrix.setEntry(i, i, weight[i]);\n        }\n<END_BUG>\n    }",
        "javadoc": "/**\n * Creates a diagonal weight matrix.\n *\n * @param weight List of the values of the diagonal.\n */\n"
      }
    },
    "contained_scope": "method",
    "bug_count": 2,
    "triggered_tests": {
      "0": {
        "test_path": "org.apache.commons.math3.fitting.PolynomialFitterTest",
        "test_method": "testLargeSample",
        "test_code": "testLargeSample() {\n        Random randomizer = new Random(0x5551480dca5b369bl);\n        double maxError = 0;\n        for (int degree = 0; degree < 10; ++degree) {\n            PolynomialFunction p = buildRandomPolynomial(degree, randomizer);\n\n            PolynomialFitter fitter = new PolynomialFitter(new LevenbergMarquardtOptimizer());\n            for (int i = 0; i < 40000; ++i) {\n                double x = -1.0 + i / 20000.0;\n                fitter.addObservedPoint(1.0, x,\n                                        p.value(x) + 0.1 * randomizer.nextGaussian());\n            }\n\n            final double[] init = new double[degree + 1];\n            PolynomialFunction fitted = new PolynomialFunction(fitter.fit(init));\n\n            for (double x = -1.0; x < 1.0; x += 0.01) {\n                double error = FastMath.abs(p.value(x) - fitted.value(x)) /\n                              (1.0 + FastMath.abs(p.value(x)));\n                maxError = FastMath.max(maxError, error);\n                Assert.assertTrue(FastMath.abs(error) < 0.01);\n            }\n        }\n        Assert.assertTrue(maxError > 0.001);\n    }",
        "clean_err_msg": "java.lang.OutOfMemoryError: Java heap space"
      }
    },
    "buggy_files": {
      "0": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizer.java",
      "1": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/Weight.java"
    },
    "hunk_type": "multi_file_two_hunks",
    "hunk_mapping": {
      "0": [
        {
          "start_line": 267,
          "end_line": 267,
          "file": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizer.java",
          "code": "<START_BUG>\n            final EigenDecomposition dec = new EigenDecomposition(m);\n<END_BUG>"
        }
      ],
      "1": [
        {
          "start_line": 43,
          "end_line": 46,
          "file": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/Weight.java",
          "code": "<START_BUG>\n        weightMatrix = org.apache.commons.math3.linear.MatrixUtils.createRealMatrix(dim, dim);\n        for (int i = 0; i < dim; i++) {\n            weightMatrix.setEntry(i, i, weight[i]);\n        }\n<END_BUG>"
        }
      ]
    },
    "bug_report": {
      "url": "https://issues.apache.org/jira/browse/MATH-924",
      "title": "new multivariate vector optimizers cannot be used with large number of weights",
      "bug_description": "When using the Weigth class to pass a large number of weights to multivariate vector optimizers, an nxn full matrix is created (and copied) when a n elements vector is used. This exhausts memory when n is large.\nThis happens for example when using curve fitters (even simple curve fitters like polynomial ones for low degree) with large number of points. I encountered this with curve fitting on 41200 points, which created a matrix with 1.7 billion elements."
    }
  },
  "Codec_13": {
    "buggy_hunks": {
      "0": {
        "start_line": 70,
        "end_line": 69,
        "file": "src/main/java/org/apache/commons/codec/binary/StringUtils.java",
        "code": "<START_BUG>\n<END_BUG>"
      },
      "1": {
        "start_line": 22,
        "end_line": 21,
        "file": "src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "code": "<START_BUG>\n<END_BUG>"
      },
      "2": {
        "start_line": 244,
        "end_line": 244,
        "file": "src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "code": "<START_BUG>\n        return doubleMetaphone(value1, alternate).equals(doubleMetaphone(value2, alternate));\n<END_BUG>"
      }
    },
    "buggy_code": {
      "0": {
        "start_line": 70,
        "end_line": 70,
        "file": "src/main/java/org/apache/commons/codec/binary/StringUtils.java",
        "code": "",
        "javadoc": "/**\n * Check if the Double Metaphone values of two <code>String</code> values\n * are equal, optionally using the alternate value.\n *\n * @param value1 The left-hand side of the encoded {@link String#equals(Object)}.\n * @param value2 The right-hand side of the encoded {@link String#equals(Object)}.\n * @param alternate use the alternate value if {@code true}.\n * @return {@code true} if the encoded <code>String</code>s are equal;\n *          {@code false} otherwise.\n */\n"
      },
      "1": {
        "start_line": 22,
        "end_line": 22,
        "file": "src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "code": "",
        "javadoc": ""
      },
      "2": {
        "start_line": 243,
        "end_line": 245,
        "file": "src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "code": "public boolean isDoubleMetaphoneEqual(final String value1, final String value2, final boolean alternate) {\n        return doubleMetaphone(value1, alternate).equals(doubleMetaphone(value2, alternate));\n    }",
        "javadoc": ""
      }
    },
    "delineated_bug": {
      "0": {
        "start_line": 70,
        "end_line": 70,
        "file": "src/main/java/org/apache/commons/codec/binary/StringUtils.java",
        "code": "<START_BUG>\n\n<END_BUG>",
        "javadoc": "/**\n * Check if the Double Metaphone values of two <code>String</code> values\n * are equal, optionally using the alternate value.\n *\n * @param value1 The left-hand side of the encoded {@link String#equals(Object)}.\n * @param value2 The right-hand side of the encoded {@link String#equals(Object)}.\n * @param alternate use the alternate value if {@code true}.\n * @return {@code true} if the encoded <code>String</code>s are equal;\n *          {@code false} otherwise.\n */\n"
      },
      "1": {
        "start_line": 22,
        "end_line": 22,
        "file": "src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "code": "<START_BUG>\n\n<END_BUG>",
        "javadoc": ""
      },
      "2": {
        "start_line": 243,
        "end_line": 245,
        "file": "src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "code": "public boolean isDoubleMetaphoneEqual(final String value1, final String value2, final boolean alternate) {\n<START_BUG>\n        return doubleMetaphone(value1, alternate).equals(doubleMetaphone(value2, alternate));\n<END_BUG>\n    }",
        "javadoc": ""
      }
    },
    "contained_scope": "file",
    "bug_count": 3,
    "triggered_tests": {
      "0": {
        "test_path": "org.apache.commons.codec.language.DoubleMetaphoneTest",
        "test_method": "testIsDoubleMetaphoneEqualBasic",
        "test_code": "testIsDoubleMetaphoneEqualBasic() {\n        final String[][] testFixture = new String[][] { { \n                \"\", \"\" }, {\n                \"Case\", \"case\" }, {\n                \"CASE\", \"Case\" }, {\n                \"caSe\", \"cAsE\" }, {\n                \"cookie\", \"quick\" }, {\n                \"quick\", \"cookie\" }, {\n                \"Brian\", \"Bryan\" }, {\n                \"Auto\", \"Otto\" }, {\n                \"Steven\", \"Stefan\" }, {\n                \"Philipowitz\", \"Filipowicz\" }\n        };\n        doubleMetaphoneEqualTest(testFixture, false);\n        doubleMetaphoneEqualTest(testFixture, true);\n    }",
        "clean_err_msg": "java.lang.NullPointerException"
      },
      "1": {
        "test_path": "org.apache.commons.codec.language.DoubleMetaphoneTest",
        "test_method": "testCodec184",
        "test_code": "testCodec184() throws Throwable {\n        assertTrue(new DoubleMetaphone().isDoubleMetaphoneEqual(\"\", \"\", false));\n        assertTrue(new DoubleMetaphone().isDoubleMetaphoneEqual(\"\", \"\", true));\n        assertFalse(new DoubleMetaphone().isDoubleMetaphoneEqual(\"aa\", \"\", false));\n        assertFalse(new DoubleMetaphone().isDoubleMetaphoneEqual(\"aa\", \"\", true));\n        assertFalse(new DoubleMetaphone().isDoubleMetaphoneEqual(\"\", \"aa\", false));\n        assertFalse(new DoubleMetaphone().isDoubleMetaphoneEqual(\"\", \"aa\", true));\n      }",
        "clean_err_msg": "java.lang.NullPointerException"
      }
    },
    "buggy_files": {
      "0": "src/main/java/org/apache/commons/codec/binary/CharSequenceUtils.java",
      "1": "src/main/java/org/apache/commons/codec/binary/StringUtils.java",
      "2": "src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java"
    },
    "hunk_type": "multi_file_four_or_more_hunks",
    "hunk_mapping": {
      "0": [
        {
          "start_line": 70,
          "end_line": 69,
          "file": "src/main/java/org/apache/commons/codec/binary/StringUtils.java",
          "code": "<START_BUG>\n<END_BUG>"
        }
      ],
      "1": [
        {
          "start_line": 22,
          "end_line": 21,
          "file": "src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java",
          "code": "<START_BUG>\n<END_BUG>"
        }
      ],
      "2": [
        {
          "start_line": 244,
          "end_line": 244,
          "file": "src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java",
          "code": "<START_BUG>\n        return doubleMetaphone(value1, alternate).equals(doubleMetaphone(value2, alternate));\n<END_BUG>"
        }
      ]
    },
    "bug_report": {
      "url": "https://issues.apache.org/jira/browse/CODEC-184",
      "title": "NullPointerException in DoubleMetaPhone.isDoubleMetaphoneEqual when using empty strings",
      "bug_description": "isDoubleMetaphoneEqual\ndoes not work with empty strings: The following test throws a\nNullPointerException\n:\npublic\nvoid test1()\nthrows\nThrowable {\n    org.apache.commons.codec.language.DoubleMetaphone var0 =\nnew\norg.apache.commons.codec.language.DoubleMetaphone();\nboolean\nvar3 = var0.isDoubleMetaphoneEqual(\n\"\", \"\n\",\nfalse\n);\n  }"
    }
  },
  "Closure_54": {
    "buggy_hunks": {
      "0": {
        "start_line": 1413,
        "end_line": 1413,
        "file": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "code": "<START_BUG>\n          if (!qVar.isTypeInferred()) {\n<END_BUG>"
      },
      "1": {
        "start_line": 341,
        "end_line": 341,
        "file": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "code": "<START_BUG>\n        baseType.isUnknownType() ||\n<END_BUG>"
      },
      "2": {
        "start_line": 366,
        "end_line": 373,
        "file": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "code": "<START_BUG>\n    boolean replacedPrototype = prototype != null;\n\n    this.prototype = prototype;\n    this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n    this.prototype.setOwnerFunction(this);\n\n      // Disassociating the old prototype makes this easier to debug--\n      // we don't have to worry about two prototypes running around.\n<END_BUG>"
      }
    },
    "buggy_code": {
      "0": {
        "start_line": 1373,
        "end_line": 1489,
        "file": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "code": "void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n        Node n, Node parent, Node rhsValue) {\n      Node ownerNode = n.getFirstChild();\n      String ownerName = ownerNode.getQualifiedName();\n      String qName = n.getQualifiedName();\n      String propName = n.getLastChild().getString();\n      Preconditions.checkArgument(qName != null && ownerName != null);\n\n      // Precedence of type information on GETPROPs:\n      // 1) @type annnotation / @enum annotation\n      // 2) ASSIGN to FUNCTION literal\n      // 3) @param/@return annotation (with no function literal)\n      // 4) ASSIGN to something marked @const\n      // 5) ASSIGN to anything else\n      //\n      // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n      // the function has jsdoc or has not been declared before.\n      //\n      // FUNCTION literals are special because TypedScopeCreator is very smart\n      // about getting as much type information as possible for them.\n\n      // Determining type for #1 + #2 + #3 + #4\n      JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n      if (valueType == null && rhsValue != null) {\n        // Determining type for #5\n        valueType = rhsValue.getJSType();\n      }\n      // Function prototypes are special.\n      // It's a common JS idiom to do:\n      // F.prototype = { ... };\n      // So if F does not have an explicitly declared super type,\n      // allow F.prototype to be redefined arbitrarily.\n      if (\"prototype\".equals(propName)) {\n        Var qVar = scope.getVar(qName);\n        if (qVar != null) {\n          // If the programmer has declared that F inherits from Super,\n          // and they assign F.prototype to an object literal,\n          // then they are responsible for making sure that the object literal's\n          // implicit prototype is set up appropriately. We just obey\n          // the @extends tag.\n          if (!qVar.isTypeInferred()) {\n            // If the programmer has declared that F inherits from Super,\n            // and they assign F.prototype to some arbitrary expression,\n            // there's not much we can do. We just ignore the expression,\n            // and hope they've annotated their code in a way to tell us\n            // what props are going to be on that prototype.\n            return;\n          }\n          if (qVar.getScope() == scope) {\n            scope.undeclare(qVar);\n          }\n        }\n      }\n\n      if (valueType == null) {\n        if (parent.getType() == Token.EXPR_RESULT) {\n          stubDeclarations.add(new StubDeclaration(\n              n,\n              t.getInput() != null && t.getInput().isExtern(),\n              ownerName));\n        }\n\n        return;\n      }\n\n      boolean inferred = true;\n      if (info != null) {\n        // Determining declaration for #1 + #3 + #4\n        inferred = !(info.hasType()\n            || info.hasEnumParameterType()\n            || (info.isConstant() && valueType != null\n                && !valueType.isUnknownType())\n            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n      }\n\n      if (inferred) {\n        // Determining declaration for #2\n        inferred = !(rhsValue != null &&\n            rhsValue.getType() == Token.FUNCTION &&\n            (info != null || !scope.isDeclared(qName, false)));\n      }\n\n      if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n          // Only declare this as an official property if it has not been\n          // declared yet.\n          boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n          if ((!ownerType.hasOwnProperty(propName) ||\n               ownerType.isPropertyTypeInferred(propName)) &&\n              ((isExtern && !ownerType.isNativeObjectType()) ||\n               !ownerType.isInstanceType())) {\n            // If the property is undeclared or inferred, declare it now.\n            ownerType.defineDeclaredProperty(propName, valueType, n);\n          }\n        }\n\n        // If the property is already declared, the error will be\n        // caught when we try to declare it in the current scope.\n        defineSlot(n, parent, valueType, inferred);\n      } else if (rhsValue != null &&\n          rhsValue.getType() == Token.TRUE) {\n        // We declare these for delegate proxy method properties.\n        FunctionType ownerType =\n            JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n        if (ownerType != null) {\n          JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n          String delegateName = codingConvention.getDelegateSuperclassName();\n          JSType delegateType = delegateName == null ?\n              null : typeRegistry.getType(delegateName);\n          if (delegateType != null &&\n              ownerTypeOfThis.isSubtype(delegateType)) {\n            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n          }\n        }\n      }\n    }",
        "javadoc": "/**\n * Declare the symbol for a qualified name in the global scope.\n *\n * @param info The doc info for this property.\n * @param n A top-level GETPROP node (it should not be contained inside\n *     another GETPROP).\n * @param parent The parent of {@code n}.\n * @param rhsValue The node that {@code n} is being initialized to,\n *     or {@code null} if this is a stub declaration.\n */\n"
      },
      "1": {
        "start_line": 322,
        "end_line": 350,
        "file": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "code": "public void setPrototypeBasedOn(ObjectType baseType) {\n    // This is a bit weird. We need to successfully handle these\n    // two cases:\n    // Foo.prototype = new Bar();\n    // and\n    // Foo.prototype = {baz: 3};\n    // In the first case, we do not want new properties to get\n    // added to Bar. In the second case, we do want new properties\n    // to get added to the type of the anonymous object.\n    //\n    // We handle this by breaking it into two cases:\n    //\n    // In the first case, we create a new PrototypeObjectType and set\n    // its implicit prototype to the type being assigned. This ensures\n    // that Bar will not get any properties of Foo.prototype, but properties\n    // later assigned to Bar will get inherited properly.\n    //\n    // In the second case, we just use the anonymous object as the prototype.\n    if (baseType.hasReferenceName() ||\n        baseType.isUnknownType() ||\n        isNativeObjectType() ||\n        baseType.isFunctionPrototypeType() ||\n        !(baseType instanceof PrototypeObjectType)) {\n\n      baseType = new PrototypeObjectType(\n          registry, this.getReferenceName() + \".prototype\", baseType);\n    }\n    setPrototype((PrototypeObjectType) baseType);\n  }",
        "javadoc": "/**\n * Sets the prototype, creating the prototype object from the given\n * base type.\n * @param baseType The base type.\n */\n"
      },
      "2": {
        "start_line": 357,
        "end_line": 395,
        "file": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "code": "public boolean setPrototype(PrototypeObjectType prototype) {\n    if (prototype == null) {\n      return false;\n    }\n    // getInstanceType fails if the function is not a constructor\n    if (isConstructor() && prototype == getInstanceType()) {\n      return false;\n    }\n\n    boolean replacedPrototype = prototype != null;\n\n    this.prototype = prototype;\n    this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n    this.prototype.setOwnerFunction(this);\n\n      // Disassociating the old prototype makes this easier to debug--\n      // we don't have to worry about two prototypes running around.\n\n    if (isConstructor() || isInterface()) {\n      FunctionType superClass = getSuperClassConstructor();\n      if (superClass != null) {\n        superClass.addSubType(this);\n      }\n\n      if (isInterface()) {\n        for (ObjectType interfaceType : getExtendedInterfaces()) {\n          if (interfaceType.getConstructor() != null) {\n            interfaceType.getConstructor().addSubType(this);\n          }\n        }\n      }\n    }\n\n    if (replacedPrototype) {\n      clearCachedValues();\n    }\n\n    return true;\n  }",
        "javadoc": "/**\n * Sets the prototype.\n * @param prototype the prototype. If this value is {@code null} it will\n *        silently be discarded.\n */\n"
      }
    },
    "delineated_bug": {
      "0": {
        "start_line": 1373,
        "end_line": 1489,
        "file": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "code": "void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n        Node n, Node parent, Node rhsValue) {\n      Node ownerNode = n.getFirstChild();\n      String ownerName = ownerNode.getQualifiedName();\n      String qName = n.getQualifiedName();\n      String propName = n.getLastChild().getString();\n      Preconditions.checkArgument(qName != null && ownerName != null);\n\n      // Precedence of type information on GETPROPs:\n      // 1) @type annnotation / @enum annotation\n      // 2) ASSIGN to FUNCTION literal\n      // 3) @param/@return annotation (with no function literal)\n      // 4) ASSIGN to something marked @const\n      // 5) ASSIGN to anything else\n      //\n      // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n      // the function has jsdoc or has not been declared before.\n      //\n      // FUNCTION literals are special because TypedScopeCreator is very smart\n      // about getting as much type information as possible for them.\n\n      // Determining type for #1 + #2 + #3 + #4\n      JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n      if (valueType == null && rhsValue != null) {\n        // Determining type for #5\n        valueType = rhsValue.getJSType();\n      }\n      // Function prototypes are special.\n      // It's a common JS idiom to do:\n      // F.prototype = { ... };\n      // So if F does not have an explicitly declared super type,\n      // allow F.prototype to be redefined arbitrarily.\n      if (\"prototype\".equals(propName)) {\n        Var qVar = scope.getVar(qName);\n        if (qVar != null) {\n          // If the programmer has declared that F inherits from Super,\n          // and they assign F.prototype to an object literal,\n          // then they are responsible for making sure that the object literal's\n          // implicit prototype is set up appropriately. We just obey\n          // the @extends tag.\n<START_BUG>\n          if (!qVar.isTypeInferred()) {\n<END_BUG>\n            // If the programmer has declared that F inherits from Super,\n            // and they assign F.prototype to some arbitrary expression,\n            // there's not much we can do. We just ignore the expression,\n            // and hope they've annotated their code in a way to tell us\n            // what props are going to be on that prototype.\n            return;\n          }\n          if (qVar.getScope() == scope) {\n            scope.undeclare(qVar);\n          }\n        }\n      }\n\n      if (valueType == null) {\n        if (parent.getType() == Token.EXPR_RESULT) {\n          stubDeclarations.add(new StubDeclaration(\n              n,\n              t.getInput() != null && t.getInput().isExtern(),\n              ownerName));\n        }\n\n        return;\n      }\n\n      boolean inferred = true;\n      if (info != null) {\n        // Determining declaration for #1 + #3 + #4\n        inferred = !(info.hasType()\n            || info.hasEnumParameterType()\n            || (info.isConstant() && valueType != null\n                && !valueType.isUnknownType())\n            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n      }\n\n      if (inferred) {\n        // Determining declaration for #2\n        inferred = !(rhsValue != null &&\n            rhsValue.getType() == Token.FUNCTION &&\n            (info != null || !scope.isDeclared(qName, false)));\n      }\n\n      if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n          // Only declare this as an official property if it has not been\n          // declared yet.\n          boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n          if ((!ownerType.hasOwnProperty(propName) ||\n               ownerType.isPropertyTypeInferred(propName)) &&\n              ((isExtern && !ownerType.isNativeObjectType()) ||\n               !ownerType.isInstanceType())) {\n            // If the property is undeclared or inferred, declare it now.\n            ownerType.defineDeclaredProperty(propName, valueType, n);\n          }\n        }\n\n        // If the property is already declared, the error will be\n        // caught when we try to declare it in the current scope.\n        defineSlot(n, parent, valueType, inferred);\n      } else if (rhsValue != null &&\n          rhsValue.getType() == Token.TRUE) {\n        // We declare these for delegate proxy method properties.\n        FunctionType ownerType =\n            JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n        if (ownerType != null) {\n          JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n          String delegateName = codingConvention.getDelegateSuperclassName();\n          JSType delegateType = delegateName == null ?\n              null : typeRegistry.getType(delegateName);\n          if (delegateType != null &&\n              ownerTypeOfThis.isSubtype(delegateType)) {\n            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n          }\n        }\n      }\n    }",
        "javadoc": "/**\n * Declare the symbol for a qualified name in the global scope.\n *\n * @param info The doc info for this property.\n * @param n A top-level GETPROP node (it should not be contained inside\n *     another GETPROP).\n * @param parent The parent of {@code n}.\n * @param rhsValue The node that {@code n} is being initialized to,\n *     or {@code null} if this is a stub declaration.\n */\n"
      },
      "1": {
        "start_line": 322,
        "end_line": 350,
        "file": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "code": "public void setPrototypeBasedOn(ObjectType baseType) {\n    // This is a bit weird. We need to successfully handle these\n    // two cases:\n    // Foo.prototype = new Bar();\n    // and\n    // Foo.prototype = {baz: 3};\n    // In the first case, we do not want new properties to get\n    // added to Bar. In the second case, we do want new properties\n    // to get added to the type of the anonymous object.\n    //\n    // We handle this by breaking it into two cases:\n    //\n    // In the first case, we create a new PrototypeObjectType and set\n    // its implicit prototype to the type being assigned. This ensures\n    // that Bar will not get any properties of Foo.prototype, but properties\n    // later assigned to Bar will get inherited properly.\n    //\n    // In the second case, we just use the anonymous object as the prototype.\n    if (baseType.hasReferenceName() ||\n<START_BUG>\n        baseType.isUnknownType() ||\n<END_BUG>\n        isNativeObjectType() ||\n        baseType.isFunctionPrototypeType() ||\n        !(baseType instanceof PrototypeObjectType)) {\n\n      baseType = new PrototypeObjectType(\n          registry, this.getReferenceName() + \".prototype\", baseType);\n    }\n    setPrototype((PrototypeObjectType) baseType);\n  }",
        "javadoc": "/**\n * Sets the prototype, creating the prototype object from the given\n * base type.\n * @param baseType The base type.\n */\n"
      },
      "2": {
        "start_line": 357,
        "end_line": 395,
        "file": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "code": "public boolean setPrototype(PrototypeObjectType prototype) {\n    if (prototype == null) {\n      return false;\n    }\n    // getInstanceType fails if the function is not a constructor\n    if (isConstructor() && prototype == getInstanceType()) {\n      return false;\n    }\n\n<START_BUG>\n    boolean replacedPrototype = prototype != null;\n\n    this.prototype = prototype;\n    this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n    this.prototype.setOwnerFunction(this);\n\n      // Disassociating the old prototype makes this easier to debug--\n      // we don't have to worry about two prototypes running around.\n<END_BUG>\n\n    if (isConstructor() || isInterface()) {\n      FunctionType superClass = getSuperClassConstructor();\n      if (superClass != null) {\n        superClass.addSubType(this);\n      }\n\n      if (isInterface()) {\n        for (ObjectType interfaceType : getExtendedInterfaces()) {\n          if (interfaceType.getConstructor() != null) {\n            interfaceType.getConstructor().addSubType(this);\n          }\n        }\n      }\n    }\n\n    if (replacedPrototype) {\n      clearCachedValues();\n    }\n\n    return true;\n  }",
        "javadoc": "/**\n * Sets the prototype.\n * @param prototype the prototype. If this value is {@code null} it will\n *        silently be discarded.\n */\n"
      }
    },
    "contained_scope": "method",
    "bug_count": 3,
    "triggered_tests": {
      "0": {
        "test_path": "com.google.javascript.jscomp.TypeCheckTest",
        "test_method": "testIssue537a",
        "test_code": "testIssue537a() throws Exception {\n    testTypes(\n        \"/** @constructor */ function Foo() {}\" +\n        \"Foo.prototype = {method: function() {}};\" +\n        \"/**\\n\" +\n        \" * @constructor\\n\" +\n        \" * @extends {Foo}\\n\" +\n        \" */\\n\" +\n        \"function Bar() {\" +\n        \"  Foo.call(this);\" +\n        \"  if (this.baz()) this.method(1);\" +\n        \"}\" +\n        \"Bar.prototype = {\" +\n        \"  baz: function() {\" +\n        \"    return true;\" +\n        \"  }\" +\n        \"};\" +\n        \"Bar.prototype.__proto__ = Foo.prototype;\",\n        \"Function Foo.prototype.method: called with 1 argument(s). \" +\n        \"Function requires at least 0 argument(s) \" +\n        \"and no more than 0 argument(s).\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<[Function Foo.prototype.method: called with 1 argument(s). Function requires at least 0 argument(s) and no more than 0 argument(s).]> but was:<[Property baz never defined on Bar]>"
      },
      "1": {
        "test_path": "com.google.javascript.jscomp.TypeCheckTest",
        "test_method": "testIssue537b",
        "test_code": "testIssue537b() throws Exception {\n    testTypes(\n        \"/** @constructor */ function Foo() {}\" +\n        \"Foo.prototype = {method: function() {}};\" +\n        \"/**\\n\" +\n        \" * @constructor\\n\" +\n        \" * @extends {Foo}\\n\" +\n        \" */\\n\" +\n        \"function Bar() {\" +\n        \"  Foo.call(this);\" +\n        \"  if (this.baz(1)) this.method();\" +\n        \"}\" +\n        \"Bar.prototype = {\" +\n        \"  baz: function() {\" +\n        \"    return true;\" +\n        \"  }\" +\n        \"};\" +\n        \"Bar.prototype.__proto__ = Foo.prototype;\",\n        \"Function Bar.prototype.baz: called with 1 argument(s). \" +\n        \"Function requires at least 0 argument(s) \" +\n        \"and no more than 0 argument(s).\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<[Function Bar.prototype.baz: called with 1 argument(s). Function requires at least 0 argument(s) and no more than 0 argument(s).]> but was:<[Property baz never defined on Bar]>"
      },
      "2": {
        "test_path": "com.google.javascript.jscomp.TypedScopeCreatorTest",
        "test_method": "testPropertyOnUnknownSuperClass2",
        "test_code": "testPropertyOnUnknownSuperClass2() {\n    testSame(\n        \"var goog = this.foo();\" +\n        \"/** @constructor \\n * @extends {goog.Unknown} */\" +\n        \"function Foo() {}\" +\n        \"Foo.prototype = {bar: 1};\" +\n        \"var x = new Foo();\",\n        RhinoErrorReporter.TYPE_PARSE_ERROR);\n    ObjectType x = (ObjectType) findNameType(\"x\", globalScope);\n    assertEquals(\"Foo\", x.toString());\n    assertEquals(\"Foo.prototype\", x.getImplicitPrototype().toString());\n    assertTrue(x.getImplicitPrototype().hasOwnProperty(\"bar\"));\n    assertEquals(\"?\", x.getPropertyType(\"bar\").toString());\n    assertTrue(x.isPropertyTypeInferred(\"bar\"));\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<[?]> but was:<[number]>"
      }
    },
    "buggy_files": {
      "0": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "1": "src/com/google/javascript/rhino/jstype/FunctionType.java"
    },
    "hunk_type": "multi_file_three_hunks",
    "hunk_mapping": {
      "0": [
        {
          "start_line": 1413,
          "end_line": 1413,
          "file": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
          "code": "<START_BUG>\n          if (!qVar.isTypeInferred()) {\n<END_BUG>"
        }
      ],
      "1": [
        {
          "start_line": 341,
          "end_line": 341,
          "file": "src/com/google/javascript/rhino/jstype/FunctionType.java",
          "code": "<START_BUG>\n        baseType.isUnknownType() ||\n<END_BUG>"
        }
      ],
      "2": [
        {
          "start_line": 366,
          "end_line": 373,
          "file": "src/com/google/javascript/rhino/jstype/FunctionType.java",
          "code": "<START_BUG>\n    boolean replacedPrototype = prototype != null;\n\n    this.prototype = prototype;\n    this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n    this.prototype.setOwnerFunction(this);\n\n      // Disassociating the old prototype makes this easier to debug--\n      // we don't have to worry about two prototypes running around.\n<END_BUG>"
        }
      ]
    },
    "bug_report": {
      "url": "https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-537.json",
      "bug_description": "Prototype methods can't be used from the constructor in case prototype is explicitly defined.",
      "title": ""
    }
  },
  "Closure_144": {
    "buggy_hunks": {
      "0": {
        "start_line": 74,
        "end_line": 73,
        "file": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "code": "<START_BUG>\n<END_BUG>"
      },
      "1": {
        "start_line": 200,
        "end_line": 202,
        "file": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "code": "<START_BUG>\n        info.getReturnType().evaluate(scope, typeRegistry) :\n        typeRegistry.getNativeType(UNKNOWN_TYPE);\n    if (templateTypeName != null &&\n<END_BUG>"
      },
      "2": {
        "start_line": 213,
        "end_line": 213,
        "file": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "code": "<START_BUG>\n\n<END_BUG>"
      },
      "3": {
        "start_line": 496,
        "end_line": 496,
        "file": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "code": "<START_BUG>\n          .withReturnType(returnType)\n<END_BUG>"
      },
      "4": {
        "start_line": 577,
        "end_line": 576,
        "file": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "code": "<START_BUG>\n<END_BUG>"
      },
      "5": {
        "start_line": 617,
        "end_line": 616,
        "file": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "code": "<START_BUG>\n<END_BUG>"
      },
      "6": {
        "start_line": 634,
        "end_line": 633,
        "file": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "code": "<START_BUG>\n<END_BUG>"
      },
      "7": {
        "start_line": 101,
        "end_line": 100,
        "file": "src/com/google/javascript/rhino/jstype/FunctionBuilder.java",
        "code": "<START_BUG>\n<END_BUG>"
      },
      "8": {
        "start_line": 517,
        "end_line": 517,
        "file": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "code": "<START_BUG>\n        registry, null, null,\n<END_BUG>"
      }
    },
    "buggy_code": {
      "0": {
        "start_line": 74,
        "end_line": 74,
        "file": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "code": "private List<ObjectType> implementedInterfaces = null;",
        "javadoc": "/**\n * Infer the return type from JSDocInfo.\n */\n"
      },
      "1": {
        "start_line": 198,
        "end_line": 207,
        "file": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "code": "FunctionTypeBuilder inferReturnType(@Nullable JSDocInfo info) {\n    returnType = info != null && info.hasReturnType() ?\n        info.getReturnType().evaluate(scope, typeRegistry) :\n        typeRegistry.getNativeType(UNKNOWN_TYPE);\n    if (templateTypeName != null &&\n        returnType.restrictByNotNullOrUndefined().isTemplateType()) {\n      reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n    }\n    return this;\n  }",
        "javadoc": "/**\n * Builds the function type, and puts it in the registry.\n */\n"
      },
      "2": {
        "start_line": 213,
        "end_line": 213,
        "file": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "code": "",
        "javadoc": "/**\n * Gets the function type from the function node and its attached\n * {@link JSDocInfo}.\n * @param name the function's name\n * @param rValue the function node. It must be a {@link Token#FUNCTION}.\n * @param info the {@link JSDocInfo} attached to the function definition\n * @param lvalueNode The node where this function is being\n *     assigned. For example, {@code A.prototype.foo = ...} would be used to\n *     determine that this function is a method of A.prototype. May be\n *     null to indicate that this is not being assigned to a qualified name.\n */\n"
      },
      "3": {
        "start_line": 472,
        "end_line": 510,
        "file": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "code": "FunctionType buildAndRegister() {\n    if (returnType == null) {\n      returnType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n    }\n\n    if (parametersNode == null) {\n      throw new IllegalStateException(\n          \"All Function types must have params and a return type\");\n    }\n\n    FunctionType fnType;\n    if (isConstructor) {\n      fnType = getOrCreateConstructor();\n    } else if (isInterface) {\n      fnType = typeRegistry.createInterfaceType(fnName, sourceNode);\n      if (scope.isGlobal() && !fnName.isEmpty()) {\n        typeRegistry.declareType(fnName, fnType.getInstanceType());\n      }\n      maybeSetBaseType(fnType);\n    } else {\n      fnType = new FunctionBuilder(typeRegistry)\n          .withName(fnName)\n          .withSourceNode(sourceNode)\n          .withParamsNode(parametersNode)\n          .withReturnType(returnType)\n          .withTypeOfThis(thisType)\n          .withTemplateName(templateTypeName)\n          .build();\n      maybeSetBaseType(fnType);\n    }\n\n    if (implementedInterfaces != null) {\n      fnType.setImplementedInterfaces(implementedInterfaces);\n    }\n\n    typeRegistry.clearTemplateTypeName();\n\n    return fnType;\n  }",
        "javadoc": "/**\n * Gets the function type from the function node and its attached\n * {@link JSDocInfo}.\n * @param name the function's name\n * @param rValue the function node. It must be a {@link Token#FUNCTION}.\n * @param info the {@link JSDocInfo} attached to the function definition\n * @param lvalueNode The node where this function is being\n *     assigned. For example, {@code A.prototype.foo = ...} would be used to\n *     determine that this function is a method of A.prototype. May be\n *     null to indicate that this is not being assigned to a qualified name.\n */\n"
      },
      "4": {
        "start_line": 550,
        "end_line": 644,
        "file": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "code": "private FunctionType getFunctionType(String name,\n        Node rValue, JSDocInfo info, @Nullable Node lvalueNode) {\n      FunctionType functionType = null;\n\n      // Handle function aliases.\n      if (rValue != null && rValue.isQualifiedName()) {\n        Var var = scope.getVar(rValue.getQualifiedName());\n        if (var != null && var.getType() instanceof FunctionType) {\n          functionType = (FunctionType) var.getType();\n          if (functionType != null && functionType.isConstructor()) {\n            typeRegistry.declareType(name, functionType.getInstanceType());\n          }\n        }\n        return functionType;\n      }\n\n      Node owner = null;\n      if (lvalueNode != null) {\n        owner = getPrototypePropertyOwner(lvalueNode);\n      }\n\n      Node errorRoot = rValue == null ? lvalueNode : rValue;\n      boolean isFnLiteral =\n          rValue != null && rValue.getType() == Token.FUNCTION;\n      Node fnRoot = isFnLiteral ? rValue : null;\n      Node parametersNode = isFnLiteral ?\n          rValue.getFirstChild().getNext() : null;\n\n      if (functionType == null && info != null && info.hasType()) {\n        JSType type = info.getType().evaluate(scope, typeRegistry);\n\n        // Known to be not null since we have the FUNCTION token there.\n        type = type.restrictByNotNullOrUndefined();\n        if (type.isFunctionType()) {\n          functionType = (FunctionType) type;\n          functionType.setJSDocInfo(info);\n        }\n      }\n\n      if (functionType == null) {\n        if (info == null ||\n            !FunctionTypeBuilder.isFunctionTypeDeclaration(info)) {\n          // We don't really have any type information in the annotation.\n          // Before we give up on this function, look at the object we're\n          // assigning it to. For example, if the function looks like this:\n          // SubFoo.prototype.bar = function() { ... };\n          // We can use type information on Foo.prototype.bar and apply it\n          // to this function.\n          if (lvalueNode != null && lvalueNode.getType() == Token.GETPROP &&\n              lvalueNode.isQualifiedName()) {\n            Var var = scope.getVar(\n                lvalueNode.getFirstChild().getQualifiedName());\n            if (var != null) {\n              ObjectType ownerType = ObjectType.cast(var.getType());\n              FunctionType propType = null;\n              if (ownerType != null) {\n                String propName = lvalueNode.getLastChild().getString();\n                propType = findOverriddenFunction(ownerType, propName);\n              }\n\n              if (propType != null) {\n                functionType =\n                    new FunctionTypeBuilder(\n                        name, compiler, errorRoot, sourceName, scope)\n                    .setSourceNode(fnRoot)\n                    .inferFromOverriddenFunction(propType, parametersNode)\n                    .inferThisType(info, owner)\n                    .buildAndRegister();\n              }\n            }\n          }\n        }\n      } // end if (functionType == null)\n\n      if (functionType == null) {\n        functionType =\n            new FunctionTypeBuilder(name, compiler, errorRoot, sourceName,\n                scope)\n            .setSourceNode(fnRoot)\n            .inferTemplateTypeName(info)\n            .inferReturnType(info)\n            .inferInheritance(info)\n            .inferThisType(info, owner)\n            .inferParameterTypes(parametersNode, info)\n            .buildAndRegister();\n      }\n\n      // assigning the function type to the function node\n      if (rValue != null) {\n        setDeferredType(rValue, functionType);\n      }\n\n      // all done\n      return functionType;\n    }",
        "javadoc": "/**\n * Gets the function type from the function node and its attached\n * {@link JSDocInfo}.\n * @param name the function's name\n * @param rValue the function node. It must be a {@link Token#FUNCTION}.\n * @param info the {@link JSDocInfo} attached to the function definition\n * @param lvalueNode The node where this function is being\n *     assigned. For example, {@code A.prototype.foo = ...} would be used to\n *     determine that this function is a method of A.prototype. May be\n *     null to indicate that this is not being assigned to a qualified name.\n */\n"
      },
      "5": {
        "start_line": 101,
        "end_line": 101,
        "file": "src/com/google/javascript/rhino/jstype/FunctionBuilder.java",
        "code": "",
        "javadoc": ""
      },
      "6": {
        "start_line": 515,
        "end_line": 521,
        "file": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "code": "FunctionType cloneWithNewReturnType(JSType newReturnType, boolean inferred) {\n    return new FunctionType(\n        registry, null, null,\n        new ArrowType(\n            registry, call.parameters, newReturnType, inferred),\n        typeOfThis, null, false, false);\n  }",
        "javadoc": ""
      }
    },
    "delineated_bug": {
      "0": {
        "start_line": 74,
        "end_line": 74,
        "file": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "code": "<START_BUG>\nprivate List<ObjectType> implementedInterfaces = null;\n<END_BUG>",
        "javadoc": "/**\n * Infer the return type from JSDocInfo.\n */\n"
      },
      "1": {
        "start_line": 198,
        "end_line": 207,
        "file": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "code": "FunctionTypeBuilder inferReturnType(@Nullable JSDocInfo info) {\n    returnType = info != null && info.hasReturnType() ?\n<START_BUG>\n        info.getReturnType().evaluate(scope, typeRegistry) :\n        typeRegistry.getNativeType(UNKNOWN_TYPE);\n    if (templateTypeName != null &&\n<END_BUG>\n        returnType.restrictByNotNullOrUndefined().isTemplateType()) {\n      reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n    }\n    return this;\n  }",
        "javadoc": "/**\n * Builds the function type, and puts it in the registry.\n */\n"
      },
      "2": {
        "start_line": 213,
        "end_line": 213,
        "file": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "code": "<START_BUG>\n\n<END_BUG>",
        "javadoc": "/**\n * Gets the function type from the function node and its attached\n * {@link JSDocInfo}.\n * @param name the function's name\n * @param rValue the function node. It must be a {@link Token#FUNCTION}.\n * @param info the {@link JSDocInfo} attached to the function definition\n * @param lvalueNode The node where this function is being\n *     assigned. For example, {@code A.prototype.foo = ...} would be used to\n *     determine that this function is a method of A.prototype. May be\n *     null to indicate that this is not being assigned to a qualified name.\n */\n"
      },
      "3": {
        "start_line": 472,
        "end_line": 510,
        "file": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "code": "FunctionType buildAndRegister() {\n    if (returnType == null) {\n      returnType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n    }\n\n    if (parametersNode == null) {\n      throw new IllegalStateException(\n          \"All Function types must have params and a return type\");\n    }\n\n    FunctionType fnType;\n    if (isConstructor) {\n      fnType = getOrCreateConstructor();\n    } else if (isInterface) {\n      fnType = typeRegistry.createInterfaceType(fnName, sourceNode);\n      if (scope.isGlobal() && !fnName.isEmpty()) {\n        typeRegistry.declareType(fnName, fnType.getInstanceType());\n      }\n      maybeSetBaseType(fnType);\n    } else {\n      fnType = new FunctionBuilder(typeRegistry)\n          .withName(fnName)\n          .withSourceNode(sourceNode)\n          .withParamsNode(parametersNode)\n<START_BUG>\n          .withReturnType(returnType)\n<END_BUG>\n          .withTypeOfThis(thisType)\n          .withTemplateName(templateTypeName)\n          .build();\n      maybeSetBaseType(fnType);\n    }\n\n    if (implementedInterfaces != null) {\n      fnType.setImplementedInterfaces(implementedInterfaces);\n    }\n\n    typeRegistry.clearTemplateTypeName();\n\n    return fnType;\n  }",
        "javadoc": "/**\n * Gets the function type from the function node and its attached\n * {@link JSDocInfo}.\n * @param name the function's name\n * @param rValue the function node. It must be a {@link Token#FUNCTION}.\n * @param info the {@link JSDocInfo} attached to the function definition\n * @param lvalueNode The node where this function is being\n *     assigned. For example, {@code A.prototype.foo = ...} would be used to\n *     determine that this function is a method of A.prototype. May be\n *     null to indicate that this is not being assigned to a qualified name.\n */\n"
      },
      "4": {
        "start_line": 550,
        "end_line": 644,
        "file": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "code": "private FunctionType getFunctionType(String name,\n        Node rValue, JSDocInfo info, @Nullable Node lvalueNode) {\n      FunctionType functionType = null;\n\n      // Handle function aliases.\n      if (rValue != null && rValue.isQualifiedName()) {\n        Var var = scope.getVar(rValue.getQualifiedName());\n        if (var != null && var.getType() instanceof FunctionType) {\n          functionType = (FunctionType) var.getType();\n          if (functionType != null && functionType.isConstructor()) {\n            typeRegistry.declareType(name, functionType.getInstanceType());\n          }\n        }\n        return functionType;\n      }\n\n      Node owner = null;\n      if (lvalueNode != null) {\n        owner = getPrototypePropertyOwner(lvalueNode);\n      }\n\n      Node errorRoot = rValue == null ? lvalueNode : rValue;\n      boolean isFnLiteral =\n          rValue != null && rValue.getType() == Token.FUNCTION;\n      Node fnRoot = isFnLiteral ? rValue : null;\n      Node parametersNode = isFnLiteral ?\n          rValue.getFirstChild().getNext() : null;\n<END_BUG>\n<START_BUG>\n\n      if (functionType == null && info != null && info.hasType()) {\n        JSType type = info.getType().evaluate(scope, typeRegistry);\n\n        // Known to be not null since we have the FUNCTION token there.\n        type = type.restrictByNotNullOrUndefined();\n        if (type.isFunctionType()) {\n          functionType = (FunctionType) type;\n          functionType.setJSDocInfo(info);\n        }\n      }\n\n      if (functionType == null) {\n        if (info == null ||\n            !FunctionTypeBuilder.isFunctionTypeDeclaration(info)) {\n          // We don't really have any type information in the annotation.\n          // Before we give up on this function, look at the object we're\n          // assigning it to. For example, if the function looks like this:\n          // SubFoo.prototype.bar = function() { ... };\n          // We can use type information on Foo.prototype.bar and apply it\n          // to this function.\n          if (lvalueNode != null && lvalueNode.getType() == Token.GETPROP &&\n              lvalueNode.isQualifiedName()) {\n            Var var = scope.getVar(\n                lvalueNode.getFirstChild().getQualifiedName());\n            if (var != null) {\n              ObjectType ownerType = ObjectType.cast(var.getType());\n              FunctionType propType = null;\n              if (ownerType != null) {\n                String propName = lvalueNode.getLastChild().getString();\n                propType = findOverriddenFunction(ownerType, propName);\n              }\n\n              if (propType != null) {\n                functionType =\n                    new FunctionTypeBuilder(\n                        name, compiler, errorRoot, sourceName, scope)\n                    .setSourceNode(fnRoot)\n                    .inferFromOverriddenFunction(propType, parametersNode)\n                    .inferThisType(info, owner)\n<END_BUG>\n<START_BUG>\n                    .buildAndRegister();\n              }\n            }\n          }\n        }\n      } // end if (functionType == null)\n\n      if (functionType == null) {\n        functionType =\n            new FunctionTypeBuilder(name, compiler, errorRoot, sourceName,\n                scope)\n            .setSourceNode(fnRoot)\n            .inferTemplateTypeName(info)\n            .inferReturnType(info)\n            .inferInheritance(info)\n            .inferThisType(info, owner)\n            .inferParameterTypes(parametersNode, info)\n<END_BUG>\n<START_BUG>\n            .buildAndRegister();\n      }\n\n      // assigning the function type to the function node\n      if (rValue != null) {\n        setDeferredType(rValue, functionType);\n      }\n\n      // all done\n      return functionType;\n    }",
        "javadoc": "/**\n * Gets the function type from the function node and its attached\n * {@link JSDocInfo}.\n * @param name the function's name\n * @param rValue the function node. It must be a {@link Token#FUNCTION}.\n * @param info the {@link JSDocInfo} attached to the function definition\n * @param lvalueNode The node where this function is being\n *     assigned. For example, {@code A.prototype.foo = ...} would be used to\n *     determine that this function is a method of A.prototype. May be\n *     null to indicate that this is not being assigned to a qualified name.\n */\n"
      },
      "5": {
        "start_line": 101,
        "end_line": 101,
        "file": "src/com/google/javascript/rhino/jstype/FunctionBuilder.java",
        "code": "<START_BUG>\n\n<END_BUG>",
        "javadoc": ""
      },
      "6": {
        "start_line": 515,
        "end_line": 521,
        "file": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "code": "FunctionType cloneWithNewReturnType(JSType newReturnType, boolean inferred) {\n    return new FunctionType(\n<START_BUG>\n        registry, null, null,\n<END_BUG>\n        new ArrowType(\n            registry, call.parameters, newReturnType, inferred),\n        typeOfThis, null, false, false);\n  }",
        "javadoc": ""
      }
    },
    "contained_scope": "file",
    "bug_count": 7,
    "triggered_tests": {
      "0": {
        "test_path": "com.google.javascript.jscomp.CodePrinterTest",
        "test_method": "testTypeAnnotationsAssign",
        "test_code": "testTypeAnnotationsAssign() {\n    assertTypeAnnotations(\"/** @constructor */ var Foo = function(){}\",\n        \"/**\\n * @return {undefined}\\n * @constructor\\n */\\n\"\n        + \"var Foo = function() {\\n}\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:</**"
      },
      "1": {
        "test_path": "com.google.javascript.jscomp.CodePrinterTest",
        "test_method": "testTypeAnnotationsMember",
        "test_code": "testTypeAnnotationsMemberSubclass() {\n    assertTypeAnnotations(\"var a = {};\"\n        + \"/** @constructor */ a.Foo = function(){};\"\n        + \"/** @constructor \\n @extends {a.Foo} */ a.Bar = function(){}\",\n        \"var a = {};\\n\"\n        + \"/**\\n * @return {undefined}\\n * @constructor\\n */\\n\"\n        + \"a.Foo = function() {\\n};\\n\"\n        + \"/**\\n * @return {undefined}\\n * @extends {a.Foo}\\n\"\n        + \" * @constructor\\n */\\n\"\n        + \"a.Bar = function() {\\n}\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<var a = {};"
      },
      "2": {
        "test_path": "com.google.javascript.jscomp.CodePrinterTest",
        "test_method": "testOptionalTypesAnnotation",
        "test_code": "testOptionalTypesAnnotation() {\n    assertTypeAnnotations(\n        \"/**\\n\" +\n        \" * @param {string=} x \\n\" +\n        \" */\\n\" +\n        \"var a = function(x) {}\",\n        \"/**\\n\" +\n        \" * @param {string=} x\\n\" +\n        \" * @return {undefined}\\n\" +\n        \" */\\n\" +\n        \"var a = function(x) {\\n}\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<...param {string=} x"
      },
      "3": {
        "test_path": "com.google.javascript.jscomp.CodePrinterTest",
        "test_method": "testTempConstructor",
        "test_code": "testTempConstructor() {\n    assertTypeAnnotations(\n        \"var x = function() {\\n/**\\n * @constructor\\n */\\nfunction t1() {}\\n\" +\n        \" /**\\n * @constructor\\n */\\nfunction t2() {}\\n\" +\n        \" t1.prototype = t2.prototype}\",\n        \"/**\\n * @return {undefined}\\n */\\nvar x = function() {\\n\" +\n        \"  /**\\n * @return {undefined}\\n * @constructor\\n */\\n\" +\n        \"function t1() {\\n  }\\n\" +\n        \"  /**\\n * @return {undefined}\\n * @constructor\\n */\\n\" +\n        \"function t2() {\\n  }\\n\" +\n        \"  t1.prototype = t2.prototype\\n}\"\n    );\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:</**"
      },
      "4": {
        "test_path": "com.google.javascript.jscomp.CodePrinterTest",
        "test_method": "testTypeAnnotationsDispatcher1",
        "test_code": "testTypeAnnotationsDispatcher1() {\n    assertTypeAnnotations(\n        \"var a = {};\\n\" +\n        \"/** \\n\" +\n        \" * @constructor \\n\" +\n        \" * @javadispatch \\n\" +\n        \" */\\n\" +\n        \"a.Foo = function(){}\",\n        \"var a = {};\\n\" +\n        \"/**\\n\" +\n        \" * @return {undefined}\\n\" +\n        \" * @constructor\\n\" +\n        \" * @javadispatch\\n\" +\n        \" */\\n\" +\n        \"a.Foo = function() {\\n\" +\n        \"}\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<var a = {};"
      },
      "5": {
        "test_path": "com.google.javascript.jscomp.CodePrinterTest",
        "test_method": "testTypeAnnotationsDispatcher2",
        "test_code": "testTypeAnnotationsDispatcher2() {\n    assertTypeAnnotations(\n        \"var a = {};\\n\" +\n        \"/** \\n\" +\n        \" * @constructor \\n\" +\n        \" */\\n\" +\n        \"a.Foo = function(){}\\n\" +\n        \"/**\\n\" +\n        \" * @javadispatch\\n\" +\n        \" */\\n\" +\n        \"a.Foo.prototype.foo = function() {};\",\n\n        \"var a = {};\\n\" +\n        \"/**\\n\" +\n        \" * @return {undefined}\\n\" +\n        \" * @constructor\\n\" +\n        \" */\\n\" +\n        \"a.Foo = function() {\\n\" +\n        \"};\\n\" +\n        \"/**\\n\" +\n        \" * @return {undefined}\\n\" +\n        \" * @javadispatch\\n\" +\n        \" */\\n\" +\n        \"a.Foo.prototype.foo = function() {\\n\" +\n        \"}\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<var a = {};"
      },
      "6": {
        "test_path": "com.google.javascript.jscomp.CodePrinterTest",
        "test_method": "testTypeAnnotationsImplements",
        "test_code": "testTypeAnnotationsImplements() {\n    assertTypeAnnotations(\"var a = {};\"\n        + \"/** @constructor */ a.Foo = function(){};\\n\"\n        + \"/** @interface */ a.I = function(){};\\n\"\n        + \"/** @interface */ a.I2 = function(){};\\n\"\n        + \"/** @constructor \\n @extends {a.Foo}\\n\"\n        + \" * @implements {a.I} \\n @implements {a.I2}\\n\"\n        + \"*/ a.Bar = function(){}\",\n        \"var a = {};\\n\"\n        + \"/**\\n * @return {undefined}\\n * @constructor\\n */\\n\"\n        + \"a.Foo = function() {\\n};\\n\"\n        + \"/**\\n * @interface\\n */\\n\"\n        + \"a.I = function() {\\n};\\n\"\n        + \"/**\\n * @interface\\n */\\n\"\n        + \"a.I2 = function() {\\n};\\n\"\n        + \"/**\\n * @return {undefined}\\n * @extends {a.Foo}\\n\"\n        + \" * @implements {a.I}\\n\"\n        + \" * @implements {a.I2}\\n * @constructor\\n */\\n\"\n        + \"a.Bar = function() {\\n}\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<var a = {};"
      },
      "7": {
        "test_path": "com.google.javascript.jscomp.CodePrinterTest",
        "test_method": "testTypeAnnotationsNamespace",
        "test_code": "testTypeAnnotationsNamespace() {\n    assertTypeAnnotations(\"var a = {};\"\n        + \"/** @constructor */ a.Foo = function(){}\",\n        \"var a = {};\\n\"\n        + \"/**\\n * @return {undefined}\\n * @constructor\\n */\\n\"\n        + \"a.Foo = function() {\\n}\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<var a = {};"
      },
      "8": {
        "test_path": "com.google.javascript.jscomp.CodePrinterTest",
        "test_method": "testTypeAnnotations",
        "test_code": "testTypeAnnotations() {\n    assertTypeAnnotations(\n        \"/** @constructor */ function Foo(){}\",\n        \"/**\\n * @return {undefined}\\n * @constructor\\n */\\n\"\n        + \"function Foo() {\\n}\\n\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:</**"
      },
      "9": {
        "test_path": "com.google.javascript.jscomp.CodePrinterTest",
        "test_method": "testVariableArgumentsTypesAnnotation",
        "test_code": "testVariableArgumentsTypesAnnotation() {\n    assertTypeAnnotations(\n        \"/**\\n\" +\n        \" * @param {...string} x \\n\" +\n        \" */\\n\" +\n        \"var a = function(x) {}\",\n        \"/**\\n\" +\n        \" * @param {...string} x\\n\" +\n        \" * @return {undefined}\\n\" +\n        \" */\\n\" +\n        \"var a = function(x) {\\n}\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<...ram {...string} x"
      },
      "10": {
        "test_path": "com.google.javascript.jscomp.CodePrinterTest",
        "test_method": "testEmitUnknownParamTypesAsAllType",
        "test_code": "testEmitUnknownParamTypesAsAllType() {\n    assertTypeAnnotations(\n        \"var a = function(x) {}\",\n        \"/**\\n\" +\n        \" * @param {*} x\\n\" +\n        \" * @return {undefined}\\n\" +\n        \" */\\n\" + \n        \"var a = function(x) {\\n}\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<...*"
      },
      "11": {
        "test_path": "com.google.javascript.jscomp.CodePrinterTest",
        "test_method": "testTypeAnnotationsMemberSubclass",
        "test_code": "testTypeAnnotationsMemberSubclass() {\n    assertTypeAnnotations(\"var a = {};\"\n        + \"/** @constructor */ a.Foo = function(){};\"\n        + \"/** @constructor \\n @extends {a.Foo} */ a.Bar = function(){}\",\n        \"var a = {};\\n\"\n        + \"/**\\n * @return {undefined}\\n * @constructor\\n */\\n\"\n        + \"a.Foo = function() {\\n};\\n\"\n        + \"/**\\n * @return {undefined}\\n * @extends {a.Foo}\\n\"\n        + \" * @constructor\\n */\\n\"\n        + \"a.Bar = function() {\\n}\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<var a = {};"
      },
      "12": {
        "test_path": "com.google.javascript.jscomp.DevirtualizePrototypeMethodsTest",
        "test_method": "testRewritePrototypeMethods2",
        "test_code": "testRewritePrototypeMethods2() throws Exception {\n    // type checking on\n    enableTypeCheck(CheckLevel.ERROR);\n    checkTypes(RewritePrototypeMethodTestInput.INPUT,\n               RewritePrototypeMethodTestInput.EXPECTED,\n               RewritePrototypeMethodTestInput.EXPECTED_TYPE_CHECKING_ON);\n  }",
        "clean_err_msg": "junit.framework.AssertionFailedError: expected:<[FUNCTION a = function (this:a): undefined, NAME JSCompiler_StaticMethods_foo$self = a, FUNCTION JSCompiler_StaticMethods_foo = function (a): number, NAME JSCompiler_StaticMethods_bar$self = a, FUNCTION JSCompiler_StaticMethods_bar = function (a, number): number, FUNCTION JSCompiler_StaticMethods_baz = function (a): undefined, NEW a = a, CALL JSCompiler_StaticMethods_foo = number, CALL JSCompiler_StaticMethods_bar = number, CALL JSCompiler_StaticMethods_baz = undefined]> but was:<[FUNCTION a = function (this:a): ?, NAME JSCompiler_StaticMethods_foo$self = a, FUNCTION JSCompiler_StaticMethods_foo = function (a): number, NAME JSCompiler_StaticMethods_bar$self = a, FUNCTION JSCompiler_StaticMethods_bar = function (a, number): number, FUNCTION JSCompiler_StaticMethods_baz = function (a): ?, NEW a = a, CALL JSCompiler_StaticMethods_foo = number, CALL JSCompiler_StaticMethods_bar = number, CALL JSCompiler_StaticMethods_baz = ?]>"
      },
      "13": {
        "test_path": "com.google.javascript.jscomp.DisambiguatePropertiesTest",
        "test_method": "testStaticProperty",
        "test_code": "testStaticProperty() {\n    String js = \"\"\n      + \"/** @constructor */ function Foo() {} \\n\"\n      + \"/** @constructor */ function Bar() {}\\n\"\n      + \"Foo.a = 0;\"\n      + \"Bar.a = 0;\";\n    String output = \"\"\n        + \"function Foo(){}\"\n        + \"function Bar(){}\"\n        + \"Foo.function__this_Foo___undefined$a = 0;\"\n        + \"Bar.function__this_Bar___undefined$a = 0;\";\n\n    testSets(false, js, output,\n        \"{a=[[function (this:Bar): undefined],\" +\n        \" [function (this:Foo): undefined]]}\");\n  }",
        "clean_err_msg": "junit.framework.AssertionFailedError: "
      },
      "14": {
        "test_path": "com.google.javascript.jscomp.ExternExportsPassTest",
        "test_method": "testExportDontEmitPrototypePathPrefix",
        "test_code": "testExportDontEmitPrototypePathPrefix() { \n    compileAndCheck(\n        \"/**\\n\" +\n        \" * @constructor\\n\" +\n        \" */\\n\" +\n        \"var Foo = function() {};\" +\n        \"/**\\n\" +\n        \" * @return {number}\\n\" +\n        \" */\\n\" +\n        \"Foo.prototype.m = function() {return 6;};\\n\" +\n        \"goog.exportSymbol('Foo', Foo);\\n\" +\n        \"goog.exportProperty(Foo.prototype, 'm', Foo.prototype.m);\",\n        \"/**\\n\" +\n        \" * @return {undefined}\\n\" +\n        \" * @constructor\\n\" +\n        \" */\\n\" +\n        \"var Foo = function() {\\n};\\n\" +\n        \"/**\\n\" +\n        \" * @return {number}\\n\" +\n        \" */\\n\" +\n        \"Foo.prototype.m = function() {\\n}\"\n    );  \n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:</**"
      },
      "15": {
        "test_path": "com.google.javascript.jscomp.ExternExportsPassTest",
        "test_method": "testExportMultiple",
        "test_code": "testExportMultiple() throws Exception {\n    compileAndCheck(\"var a = {}; a.b = function(p1) {}; \" +\n                    \"a.b.c = function(d, e, f) {};\" +\n                    \"a.b.prototype.c = function(g, h, i) {};\" +\n                    \"goog.exportSymbol('a.b', a.b);\" +\n                    \"goog.exportProperty(a.b, 'c', a.b.c);\" +\n                    \"goog.exportProperty(a.b.prototype, 'c', a.b.prototype.c);\",\n\n                    \"var a = {};\\n\" +\n                    \"/**\\n\" +\n                    \" * @param {*} p1\\n\" +\n                    \" * @return {undefined}\\n\" +\n                    \" */\\n\" +\n                    \"a.b = function(p1) {\\n};\\n\" +\n                    \"/**\\n\" +\n                    \" * @param {*} d\\n\" +\n                    \" * @param {*} e\\n\" +\n                    \" * @param {*} f\\n\" +\n                    \" * @return {undefined}\\n\" +\n                    \" */\\n\" +\n                    \"a.b.c = function(d, e, f) {\\n};\\n\" +\n                    \"/**\\n\" +\n                    \" * @param {*} g\\n\" +\n                    \" * @param {*} h\\n\" +\n                    \" * @param {*} i\\n\" +\n                    \" * @return {undefined}\\n\" +\n                    \" */\\n\" +\n                    \"a.b.prototype.c = function(g, h, i) {\\n}\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<..."
      },
      "16": {
        "test_path": "com.google.javascript.jscomp.ExternExportsPassTest",
        "test_method": "testExportSymbolWithConstructor",
        "test_code": "testExportSymbolWithConstructor() {\n    compileAndCheck(\"var internalName;\\n\" +\n                    \"/**\\n\" +\n                    \" * @constructor\\n\" +\n                    \" */\\n\" +  \n                    \"internalName = function() {\" +\n                    \"};\" +\n                    \"goog.exportSymbol('externalName', internalName)\",\n                    \"/**\\n\" +\n                    \" * @return {undefined}\\n\" +\n                    \" * @constructor\\n\" +\n                    \" */\\n\" + \n                    \"var externalName = function() {\\n}\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:</**"
      },
      "17": {
        "test_path": "com.google.javascript.jscomp.ExternExportsPassTest",
        "test_method": "testExportSymbolDefinedInVar",
        "test_code": "testExportSymbolDefinedInVar() throws Exception {\n    compileAndCheck(\"var a = function(d, e, f) {};\" +\n                    \"goog.exportSymbol('foobar', a)\",\n                    \"/**\\n\" +\n                    \" * @param {*} d\\n\" +\n                    \" * @param {*} e\\n\" +\n                    \" * @param {*} f\\n\" +\n                    \" * @return {undefined}\\n\" +\n                    \" */\\n\" +\n                    \"var foobar = function(d, e, f) {\\n}\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<...e"
      },
      "18": {
        "test_path": "com.google.javascript.jscomp.ExternExportsPassTest",
        "test_method": "testExportSymbol",
        "test_code": "testExportSymbol() throws Exception {\n    compileAndCheck(\"var a = {}; a.b = {}; a.b.c = function(d, e, f) {};\" +\n                    \"goog.exportSymbol('foobar', a.b.c)\",\n                    \"/**\\n\" +\n                    \" * @param {*} d\\n\" +\n                    \" * @param {*} e\\n\" +\n                    \" * @param {*} f\\n\" +\n                    \" * @return {undefined}\\n\" +\n                    \" */\\n\" +\n                    \"var foobar = function(d, e, f) {\\n}\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<...e"
      },
      "19": {
        "test_path": "com.google.javascript.jscomp.ExternExportsPassTest",
        "test_method": "testExportMultiple2",
        "test_code": "testExportMultiple2() throws Exception {\n    compileAndCheck(\"var a = {}; a.b = function(p1) {}; \" +\n                    \"a.b.c = function(d, e, f) {};\" +\n                    \"a.b.prototype.c = function(g, h, i) {};\" +\n                    \"goog.exportSymbol('hello', a);\" +\n                    \"goog.exportProperty(a.b, 'c', a.b.c);\" +\n                    \"goog.exportProperty(a.b.prototype, 'c', a.b.prototype.c);\",\n\n                    \"var hello = {};\\n\" +\n                    \"hello.b = {};\\n\" +\n                    \"/**\\n\" +\n                    \" * @param {*} d\\n\" +\n                    \" * @param {*} e\\n\" +\n                    \" * @param {*} f\\n\" +\n                    \" * @return {undefined}\\n\" +\n                    \" */\\n\" +\n                    \"hello.b.c = function(d, e, f) {\\n};\\n\" +\n                    \"/**\\n\" +\n                    \" * @param {*} g\\n\" +\n                    \" * @param {*} h\\n\" +\n                    \" * @param {*} i\\n\" +\n                    \" * @return {undefined}\\n\" +\n                    \" */\\n\" +\n                    \"hello.b.prototype.c = function(g, h, i) {\\n}\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<...e"
      },
      "20": {
        "test_path": "com.google.javascript.jscomp.ExternExportsPassTest",
        "test_method": "testExportMultiple3",
        "test_code": "testExportMultiple3() throws Exception {\n    compileAndCheck(\"var a = {}; a.b = function(p1) {}; \" +\n                    \"a.b.c = function(d, e, f) {};\" +\n                    \"a.b.prototype.c = function(g, h, i) {};\" +\n                    \"goog.exportSymbol('prefix', a.b);\" +\n                    \"goog.exportProperty(a.b, 'c', a.b.c);\",\n\n                    \"/**\\n\" +\n                    \" * @param {*} p1\\n\" +\n                    \" * @return {undefined}\\n\" +\n                    \" */\\n\" +\n                    \"var prefix = function(p1) {\\n};\\n\" +\n                    \"/**\\n\" +\n                    \" * @param {*} d\\n\" +\n                    \" * @param {*} e\\n\" +\n                    \" * @param {*} f\\n\" +\n                    \" * @return {undefined}\\n\" +\n                    \" */\\n\" +\n                    \"prefix.c = function(d, e, f) {\\n}\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<..."
      },
      "21": {
        "test_path": "com.google.javascript.jscomp.ExternExportsPassTest",
        "test_method": "testExportProperty",
        "test_code": "testExportProperty() throws Exception {\n    compileAndCheck(\"var a = {}; a.b = {}; a.b.c = function(d, e, f) {};\" +\n                    \"goog.exportProperty(a.b, 'cprop', a.b.c)\",\n                    \"var a = {};\\n\" +\n                    \"a.b = {};\\n\" +\n                    \"/**\\n\" +\n                    \" * @param {*} d\\n\" +\n                    \" * @param {*} e\\n\" +\n                    \" * @param {*} f\\n\" +\n                    \" * @return {undefined}\\n\" +\n                    \" */\\n\" +\n                    \"a.b.cprop = function(d, e, f) {\\n}\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<...e"
      },
      "22": {
        "test_path": "com.google.javascript.jscomp.LooseTypeCheckTest",
        "test_method": "testNestedFunctionInference1",
        "test_code": "testNestedFunctionInference1() throws Exception {\n    String nestedAssignOfFooAndBar =\n        \"/** @constructor */ function f() {};\" +\n        \"f.prototype.foo = f.prototype.bar = function(){};\";\n    testFunctionType(nestedAssignOfFooAndBar, \"(new f).bar\",\n        \"function (this:f): undefined\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<... function (this:f): [undefined]"
      },
      "23": {
        "test_path": "com.google.javascript.jscomp.LooseTypeCheckTest",
        "test_method": "testScoping10",
        "test_code": "testScoping10() throws Exception {\n    TypeCheckResult p = parseAndTypeCheckWithScope(\"var a = function b(){};\");\n\n    // a declared, b is not\n    assertTrue(p.scope.isDeclared(\"a\", false));\n    assertFalse(p.scope.isDeclared(\"b\", false));\n\n    // checking that a has the correct assigned type\n    assertEquals(\"function (): undefined\",\n        p.scope.getVar(\"a\").getType().toString());\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<function (): [undefined]> but was:<function (): [?]>"
      },
      "24": {
        "test_path": "com.google.javascript.jscomp.LooseTypeCheckTest",
        "test_method": "testDuplicateOldTypeDef",
        "test_code": "testDuplicateOldTypeDef() throws Exception {\n    testTypes(\n        \"var goog = {}; goog.typedef = true;\" +\n        \"/** @constructor */ goog.Bar = function() {};\" +\n        \"/** @type {number} */ goog.Bar = goog.typedef\",\n        \"variable goog.Bar redefined with type number, \" +\n        \"original definition at [testcode]:1 \" +\n        \"with type function (this:goog.Bar): undefined\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<...on (this:goog.Bar): [undefined]> but was:<...on (this:goog.Bar): [?]>"
      },
      "25": {
        "test_path": "com.google.javascript.jscomp.LooseTypeCheckTest",
        "test_method": "testBadConstructorCall",
        "test_code": "testBadConstructorCall() throws Exception {\n    testTypes(\n        \"/** @constructor */ function Foo() {}\" +\n        \"Foo();\",\n        \"Constructor function (this:Foo): undefined should be called \" +\n        \"with the \\\"new\\\" keyword\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<...unction (this:Foo): [undefined] should be called wi...> but was:<...unction (this:Foo): [?] should be called wi...>"
      },
      "26": {
        "test_path": "com.google.javascript.jscomp.LooseTypeCheckTest",
        "test_method": "testDontAddMethodsIfNoConstructor",
        "test_code": "testDontAddMethodsIfNoConstructor()\n      throws Exception {\n    Node js1Node = parseAndTypeCheck(\n        \"function A() {}\" +\n        \"A.prototype = {m1: 5, m2: true}\");\n\n    JSType functionAType = js1Node.getFirstChild().getJSType();\n    assertEquals(\"function (): undefined\", functionAType.toString());\n    assertEquals(UNKNOWN_TYPE,\n        U2U_FUNCTION_TYPE.getPropertyType(\"m1\"));\n    assertEquals(UNKNOWN_TYPE,\n        U2U_FUNCTION_TYPE.getPropertyType(\"m2\"));\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<function (): [undefined]> but was:<function (): [?]>"
      },
      "27": {
        "test_path": "com.google.javascript.jscomp.LooseTypeCheckTest",
        "test_method": "testInterfaceInheritanceCheck11",
        "test_code": "testInterfaceInheritanceCheck11() throws Exception {\n    testTypes(\n        \"/** @constructor */function Super() {};\" +\n        \"/** @param {number} bar */Super.prototype.foo = function(bar) {};\" +\n        \"/** @constructor\\n @extends {Super} */function Sub() {};\" +\n        \"/** @override\\n  @param {string} bar */Sub.prototype.foo =\\n\" +\n        \"function(bar) {};\",\n        \"mismatch of the foo property type and the type of the property it \" +\n        \"overrides from superclass Super\\n\" +\n        \"original: function (this:Super, number): undefined\\n\" +\n        \"override: function (this:Sub, string): undefined\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<...his:Super, number): [undefined"
      },
      "28": {
        "test_path": "com.google.javascript.jscomp.LooseTypeCheckTest",
        "test_method": "testErrorMismatchingPropertyOnInterface5",
        "test_code": "testErrorMismatchingPropertyOnInterface5() throws Exception {\n    testTypes(\"/** @interface */ function T() {};\\n\" +\n        \"/** @type {number} */T.prototype.x = function() { };\",\n        \"assignment to property x of T.prototype\\n\" +\n        \"found   : function (): undefined\\n\" +\n        \"required: number\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<...nd   : function (): [undefined]"
      },
      "29": {
        "test_path": "com.google.javascript.jscomp.LooseTypeCheckTest",
        "test_method": "testDuplicateTypeDef",
        "test_code": "testDuplicateTypeDef() throws Exception {\n    testTypes(\n        \"var goog = {};\" +\n        \"/** @constructor */ goog.Bar = function() {};\" +\n        \"/** @typedef {number} */ goog.Bar;\",\n        \"variable goog.Bar redefined with type None, \" +\n        \"original definition at [testcode]:1 \" +\n        \"with type function (this:goog.Bar): undefined\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<...on (this:goog.Bar): [undefined]> but was:<...on (this:goog.Bar): [?]>"
      },
      "30": {
        "test_path": "com.google.javascript.jscomp.LooseTypeCheckTest",
        "test_method": "testBug911118",
        "test_code": "testBug911118() throws Exception {\n    // verifying the type assigned to anonymous functions assigned variables\n    Scope s = parseAndTypeCheckWithScope(\"var a = function(){};\").scope;\n    JSType type = s.getVar(\"a\").getType();\n    assertEquals(\"function (): undefined\", type.toString());\n\n    // verifying the bug example\n    testTypes(\"function nullFunction() {};\" +\n        \"var foo = nullFunction;\" +\n        \"foo = function() {};\" +\n        \"foo();\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<function (): [undefined]> but was:<function (): [?]>"
      },
      "31": {
        "test_path": "com.google.javascript.jscomp.LooseTypeCheckTest",
        "test_method": "testFunctionInference12",
        "test_code": "testFunctionInference12() throws Exception {\n    testFunctionType(\n        \"var goog = {};\" +\n        \"goog.f = function(){};\",\n        \"goog.f\",\n        \"function (): undefined\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<...nd   : function (): [undefined]"
      },
      "32": {
        "test_path": "com.google.javascript.jscomp.LooseTypeCheckTest",
        "test_method": "testFunctionInference13",
        "test_code": "testFunctionInference13() throws Exception {\n    testFunctionType(\n        \"var goog = {};\" +\n        \"/** @constructor */ goog.Foo = function(){};\" +\n        \"/** @param {!goog.Foo} f */function eatFoo(f){};\",\n        \"eatFoo\",\n        \"function (goog.Foo): undefined\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<...unction (goog.Foo): [undefined]"
      },
      "33": {
        "test_path": "com.google.javascript.jscomp.LooseTypeCheckTest",
        "test_method": "testFunctionInference15",
        "test_code": "testFunctionInference15() throws Exception {\n    testFunctionType(\n        \"/** @constructor */ function f() {};\" +\n        \"f.prototype.foo = function(){};\",\n        \"f.prototype.foo\",\n        \"function (this:f): undefined\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<... function (this:f): [undefined]"
      },
      "34": {
        "test_path": "com.google.javascript.jscomp.LooseTypeCheckTest",
        "test_method": "testFunctionInference16",
        "test_code": "testFunctionInference16() throws Exception {\n    testFunctionType(\n        \"/** @constructor */ function f() {};\" +\n        \"f.prototype.foo = function(){};\",\n        \"(new f).foo\",\n        \"function (this:f): undefined\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<... function (this:f): [undefined]"
      },
      "35": {
        "test_path": "com.google.javascript.jscomp.LooseTypeCheckTest",
        "test_method": "testPrototypePropertyReference",
        "test_code": "testPrototypePropertyReference() throws Exception {\n    TypeCheckResult p = parseAndTypeCheckWithScope(\"\"\n        + \"/** @constructor */\\n\"\n        + \"function Foo() {}\\n\"\n        + \"/** @param {number} a */\\n\"\n        + \"Foo.prototype.bar = function(a){};\\n\"\n        + \"/** @param {Foo} f */\\n\"\n        + \"function baz(f) {\\n\"\n        + \"  Foo.prototype.bar.call(f, 3);\\n\"\n        + \"}\");\n    assertEquals(0, compiler.getErrorCount());\n    assertEquals(0, compiler.getWarningCount());\n\n    assertTrue(p.scope.getVar(\"Foo\").getType() instanceof FunctionType);\n    FunctionType fooType = (FunctionType) p.scope.getVar(\"Foo\").getType();\n    assertEquals(\"function (this:Foo, number): undefined\",\n                 fooType.getPrototype().getPropertyType(\"bar\").toString());\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<...(this:Foo, number): [undefined]> but was:<...(this:Foo, number): [?]>"
      },
      "36": {
        "test_path": "com.google.javascript.jscomp.LooseTypeCheckTest",
        "test_method": "testGoodExtends7",
        "test_code": "testGoodExtends7() throws Exception {\n    testFunctionType(\n        \"Function.prototype.inherits = function(x) {};\" +\n        \"/** @constructor */function base() {}\\n\" +\n        \"/** @extends {base}\\n * @constructor */function derived() {}\\n\" +\n        \"derived.inherits(base);\",\n        \"(new derived).constructor\",\n        \"function (this:derived): undefined\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<...ion (this:derived): [undefined]"
      },
      "37": {
        "test_path": "com.google.javascript.jscomp.LooseTypeCheckTest",
        "test_method": "testTypeRedefinition",
        "test_code": "testTypeRedefinition() throws Exception {\n    testTypes(\"a={};/**@enum {string}*/ a.A = {ZOR:'b'};\"\n        + \"/** @constructor */ a.A = function() {}\",\n        \"variable a.A redefined with type function (this:a.A): undefined, \" +\n        \"original definition at [testcode]:1 with type enum{a.A}\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<...unction (this:a.A): [undefined], original definitio...> but was:<...unction (this:a.A): [?], original definitio...>"
      },
      "38": {
        "test_path": "com.google.javascript.jscomp.LooseTypeCheckTest",
        "test_method": "testFunctionInference1",
        "test_code": "testFunctionInference1() throws Exception {\n    testFunctionType(\n        \"function f(a) {}\",\n        \"function (?): undefined\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<...d   : function (?): [undefined]"
      },
      "39": {
        "test_path": "com.google.javascript.jscomp.LooseTypeCheckTest",
        "test_method": "testFunctionInference2",
        "test_code": "testFunctionInference2() throws Exception {\n    testFunctionType(\n        \"function f(a,b) {}\",\n        \"function (?, ?): undefined\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<... : function (?, ?): [undefined]"
      },
      "40": {
        "test_path": "com.google.javascript.jscomp.LooseTypeCheckTest",
        "test_method": "testFunctionInference3",
        "test_code": "testFunctionInference3() throws Exception {\n    testFunctionType(\n        \"function f(var_args) {}\",\n        \"function (...[?]): undefined\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<... function (...[?]): [undefined]"
      },
      "41": {
        "test_path": "com.google.javascript.jscomp.LooseTypeCheckTest",
        "test_method": "testFunctionInference4",
        "test_code": "testFunctionInference4() throws Exception {\n    testFunctionType(\n        \"function f(a,b,c,var_args) {}\",\n        \"function (?, ?, ?, ...[?]): undefined\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<... (?, ?, ?, ...[?]): [undefined]"
      },
      "42": {
        "test_path": "com.google.javascript.jscomp.LooseTypeCheckTest",
        "test_method": "testFunctionInference7",
        "test_code": "testFunctionInference7() throws Exception {\n    testFunctionType(\n        \"/** @this Date */function f(a,b,c,var_args) {}\",\n        \"function (this:Date, ?, ?, ?, ...[?]): undefined\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<..., ?, ?, ?, ...[?]): [undefined]"
      },
      "43": {
        "test_path": "com.google.javascript.jscomp.LooseTypeCheckTest",
        "test_method": "testFunctionInference8",
        "test_code": "testFunctionInference8() throws Exception {\n    testFunctionType(\n        \"function f() {}\",\n        \"function (): undefined\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<...nd   : function (): [undefined]"
      },
      "44": {
        "test_path": "com.google.javascript.jscomp.LooseTypeCheckTest",
        "test_method": "testFunctionInference9",
        "test_code": "testFunctionInference9() throws Exception {\n    testFunctionType(\n        \"var f = function() {};\",\n        \"function (): undefined\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<...nd   : function (): [undefined]"
      },
      "45": {
        "test_path": "com.google.javascript.jscomp.LooseTypeCheckTest",
        "test_method": "testInterfaceInheritanceCheck7",
        "test_code": "testInterfaceInheritanceCheck7() throws Exception {\n    testTypes(\n        \"/** @interface */function Super() {};\" +\n        \"/** @param {number} bar */Super.prototype.foo = function(bar) {};\" +\n        \"/** @constructor\\n @implements {Super} */function Sub() {};\" +\n        \"/** @override\\n  @param {string} bar */Sub.prototype.foo =\\n\" +\n        \"function(bar) {};\",\n        \"mismatch of the foo property type and the type of the property it \" +\n        \"overrides from interface Super\\n\" +\n        \"original: function (this:Super, number): undefined\\n\" +\n        \"override: function (this:Sub, string): undefined\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<...his:Super, number): [undefined"
      },
      "46": {
        "test_path": "com.google.javascript.jscomp.LooseTypeCheckTest",
        "test_method": "testDuplicateStaticMethodDecl1",
        "test_code": "testDuplicateStaticMethodDecl1() throws Exception {\n    testTypes(\n        \"var goog = goog || {};\" +\n        \"/** @param {number} x */ goog.foo = function(x) {};\" +\n        \"/** @param {number} x */ goog.foo = function(x) {};\",\n        \"variable goog.foo redefined with type function (number): undefined, \" +\n        \"original definition at [testcode]:1 \" +\n        \"with type function (number): undefined\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<... function (number): [undefined, original definition at [testcode]:1 with type function (number): undefined]> but was:<... function (number): [?, original definition at [testcode]:1 with type function (number): ?]>"
      },
      "47": {
        "test_path": "com.google.javascript.jscomp.LooseTypeCheckTest",
        "test_method": "testDuplicateStaticMethodDecl5",
        "test_code": "testDuplicateStaticMethodDecl5() throws Exception {\n    testTypes(\n        \"var goog = goog || {};\" +\n        \"goog.foo = function(x) {};\" +\n        \"/** @return {undefined} */ goog.foo = function(x) {};\",\n        \"variable goog.foo redefined with type function (?): undefined, \" +\n        \"original definition at [testcode]:1 with type \" +\n        \"function (?): undefined\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<... type function (?): [undefined]> but was:<... type function (?): [?]>"
      },
      "48": {
        "test_path": "com.google.javascript.jscomp.TypeCheckTest",
        "test_method": "testNestedFunctionInference1",
        "test_code": "testNestedFunctionInference1() throws Exception {\n    String nestedAssignOfFooAndBar =\n        \"/** @constructor */ function f() {};\" +\n        \"f.prototype.foo = f.prototype.bar = function(){};\";\n    testFunctionType(nestedAssignOfFooAndBar, \"(new f).bar\",\n        \"function (this:f): undefined\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<... function (this:f): [undefined]"
      },
      "49": {
        "test_path": "com.google.javascript.jscomp.TypeCheckTest",
        "test_method": "testScoping10",
        "test_code": "testScoping10() throws Exception {\n    TypeCheckResult p = parseAndTypeCheckWithScope(\"var a = function b(){};\");\n\n    // a declared, b is not\n    assertTrue(p.scope.isDeclared(\"a\", false));\n    assertFalse(p.scope.isDeclared(\"b\", false));\n\n    // checking that a has the correct assigned type\n    assertEquals(\"function (): undefined\",\n        p.scope.getVar(\"a\").getType().toString());\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<function (): [undefined]> but was:<function (): [?]>"
      },
      "50": {
        "test_path": "com.google.javascript.jscomp.TypeCheckTest",
        "test_method": "testDuplicateOldTypeDef",
        "test_code": "testDuplicateOldTypeDef() throws Exception {\n    testTypes(\n        \"var goog = {}; goog.typedef = true;\" +\n        \"/** @constructor */ goog.Bar = function() {};\" +\n        \"/** @type {number} */ goog.Bar = goog.typedef\",\n        \"variable goog.Bar redefined with type number, \" +\n        \"original definition at [testcode]:1 \" +\n        \"with type function (this:goog.Bar): undefined\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<...on (this:goog.Bar): [undefined]> but was:<...on (this:goog.Bar): [?]>"
      },
      "51": {
        "test_path": "com.google.javascript.jscomp.TypeCheckTest",
        "test_method": "testInferredReturn1",
        "test_code": "testInferredReturn1() throws Exception {\n    testTypes(\n        \"function f() {} /** @param {number} x */ function g(x) {}\" +\n        \"g(f());\",\n        \"actual parameter 1 of g does not match formal parameter\\n\" +\n        \"found   : undefined\\n\" +\n        \"required: number\");\n  }",
        "clean_err_msg": "junit.framework.AssertionFailedError: expected a warning"
      },
      "52": {
        "test_path": "com.google.javascript.jscomp.TypeCheckTest",
        "test_method": "testInferredReturn2",
        "test_code": "testInferredReturn2() throws Exception {\n    testTypes(\n        \"/** @constructor */ function Foo() {}\" +\n        \"Foo.prototype.bar = function() {}; \" +\n        \"/** @param {number} x */ function g(x) {}\" +\n        \"g((new Foo()).bar());\",\n        \"actual parameter 1 of g does not match formal parameter\\n\" +\n        \"found   : undefined\\n\" +\n        \"required: number\");\n  }",
        "clean_err_msg": "junit.framework.AssertionFailedError: expected a warning"
      },
      "53": {
        "test_path": "com.google.javascript.jscomp.TypeCheckTest",
        "test_method": "testInferredReturn3",
        "test_code": "testInferredReturn3() throws Exception {\n    testTypes(\n        \"/** @constructor */ function Foo() {}\" +\n        \"Foo.prototype.bar = function() {}; \" +\n        \"/** @constructor \\n * @extends {Foo} */ function SubFoo() {}\" +\n        \"/** @return {number} \\n * @override  */ \" +\n        \"SubFoo.prototype.bar = function() { return 3; }; \",\n        \"mismatch of the bar property type and the type of the property \" +\n        \"it overrides from superclass Foo\\n\" +\n        \"original: function (this:Foo): undefined\\n\" +\n        \"override: function (this:SubFoo): number\");\n  }",
        "clean_err_msg": "junit.framework.AssertionFailedError: expected a warning"
      },
      "54": {
        "test_path": "com.google.javascript.jscomp.TypeCheckTest",
        "test_method": "testInferredReturn4",
        "test_code": "testInferredReturn4() throws Exception {\n    // By design, this throws a warning. if you want global x to be\n    // defined to some other type of function, then you need to declare it\n    // as a greater type.\n    testTypes(\n        \"var x = function() {};\" +\n        \"x = /** @type {function(): number} */ (function() { return 3; });\",\n        \"assignment\\n\" +\n        \"found   : function (): number\\n\" +\n        \"required: function (): undefined\");\n  }",
        "clean_err_msg": "junit.framework.AssertionFailedError: expected a warning"
      },
      "55": {
        "test_path": "com.google.javascript.jscomp.TypeCheckTest",
        "test_method": "testInferredReturn6",
        "test_code": "testInferredReturn6() throws Exception {\n    testTypes(\n        \"/** @return {string} */\" +\n        \"function f() {\" +\n        \"  var x = function() {};\" +\n        \"  if (f()) \" +\n        \"    x = /** @type {function(): number} */ \" +\n        \"        (function() { return 3; });\" +\n        \"  return x();\" +\n        \"}\",\n        \"inconsistent return type\\n\" +\n        \"found   : (number|undefined)\\n\" +\n        \"required: string\");\n  }",
        "clean_err_msg": "junit.framework.AssertionFailedError: expected a warning"
      },
      "56": {
        "test_path": "com.google.javascript.jscomp.TypeCheckTest",
        "test_method": "testBadConstructorCall",
        "test_code": "testBadConstructorCall() throws Exception {\n    testTypes(\n        \"/** @constructor */ function Foo() {}\" +\n        \"Foo();\",\n        \"Constructor function (this:Foo): undefined should be called \" +\n        \"with the \\\"new\\\" keyword\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<...unction (this:Foo): [undefined] should be called wi...> but was:<...unction (this:Foo): [?] should be called wi...>"
      },
      "57": {
        "test_path": "com.google.javascript.jscomp.TypeCheckTest",
        "test_method": "testDontAddMethodsIfNoConstructor",
        "test_code": "testDontAddMethodsIfNoConstructor()\n      throws Exception {\n    Node js1Node = parseAndTypeCheck(\n        \"function A() {}\" +\n        \"A.prototype = {m1: 5, m2: true}\");\n\n    JSType functionAType = js1Node.getFirstChild().getJSType();\n    assertEquals(\"function (): undefined\", functionAType.toString());\n    assertEquals(UNKNOWN_TYPE,\n        U2U_FUNCTION_TYPE.getPropertyType(\"m1\"));\n    assertEquals(UNKNOWN_TYPE,\n        U2U_FUNCTION_TYPE.getPropertyType(\"m2\"));\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<function (): [undefined]> but was:<function (): [?]>"
      },
      "58": {
        "test_path": "com.google.javascript.jscomp.TypeCheckTest",
        "test_method": "testInterfaceInheritanceCheck11",
        "test_code": "testInterfaceInheritanceCheck11() throws Exception {\n    testTypes(\n        \"/** @constructor */function Super() {};\" +\n        \"/** @param {number} bar */Super.prototype.foo = function(bar) {};\" +\n        \"/** @constructor\\n @extends {Super} */function Sub() {};\" +\n        \"/** @override\\n  @param {string} bar */Sub.prototype.foo =\\n\" +\n        \"function(bar) {};\",\n        \"mismatch of the foo property type and the type of the property it \" +\n        \"overrides from superclass Super\\n\" +\n        \"original: function (this:Super, number): undefined\\n\" +\n        \"override: function (this:Sub, string): undefined\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<...his:Super, number): [undefined"
      },
      "59": {
        "test_path": "com.google.javascript.jscomp.TypeCheckTest",
        "test_method": "testErrorMismatchingPropertyOnInterface5",
        "test_code": "testErrorMismatchingPropertyOnInterface5() throws Exception {\n    testTypes(\"/** @interface */ function T() {};\\n\" +\n        \"/** @type {number} */T.prototype.x = function() { };\",\n        \"assignment to property x of T.prototype\\n\" +\n        \"found   : function (): undefined\\n\" +\n        \"required: number\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<...nd   : function (): [undefined]"
      },
      "60": {
        "test_path": "com.google.javascript.jscomp.TypeCheckTest",
        "test_method": "testDuplicateTypeDef",
        "test_code": "testDuplicateTypeDef() throws Exception {\n    testTypes(\n        \"var goog = {};\" +\n        \"/** @constructor */ goog.Bar = function() {};\" +\n        \"/** @typedef {number} */ goog.Bar;\",\n        \"variable goog.Bar redefined with type None, \" +\n        \"original definition at [testcode]:1 \" +\n        \"with type function (this:goog.Bar): undefined\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<...on (this:goog.Bar): [undefined]> but was:<...on (this:goog.Bar): [?]>"
      },
      "61": {
        "test_path": "com.google.javascript.jscomp.TypeCheckTest",
        "test_method": "testBug911118",
        "test_code": "testBug911118() throws Exception {\n    // verifying the type assigned to function expressions assigned variables\n    Scope s = parseAndTypeCheckWithScope(\"var a = function(){};\").scope;\n    JSType type = s.getVar(\"a\").getType();\n    assertEquals(\"function (): undefined\", type.toString());\n\n    // verifying the bug example\n    testTypes(\"function nullFunction() {};\" +\n        \"var foo = nullFunction;\" +\n        \"foo = function() {};\" +\n        \"foo();\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<function (): [undefined]> but was:<function (): [?]>"
      },
      "62": {
        "test_path": "com.google.javascript.jscomp.TypeCheckTest",
        "test_method": "testFunctionInference12",
        "test_code": "testFunctionInference12() throws Exception {\n    testFunctionType(\n        \"var goog = {};\" +\n        \"goog.f = function(){};\",\n        \"goog.f\",\n        \"function (): undefined\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<...nd   : function (): [undefined]"
      },
      "63": {
        "test_path": "com.google.javascript.jscomp.TypeCheckTest",
        "test_method": "testFunctionInference13",
        "test_code": "testFunctionInference13() throws Exception {\n    testFunctionType(\n        \"var goog = {};\" +\n        \"/** @constructor */ goog.Foo = function(){};\" +\n        \"/** @param {!goog.Foo} f */function eatFoo(f){};\",\n        \"eatFoo\",\n        \"function (goog.Foo): undefined\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<...unction (goog.Foo): [undefined]"
      },
      "64": {
        "test_path": "com.google.javascript.jscomp.TypeCheckTest",
        "test_method": "testFunctionInference15",
        "test_code": "testFunctionInference15() throws Exception {\n    testFunctionType(\n        \"/** @constructor */ function f() {};\" +\n        \"f.prototype.foo = function(){};\",\n        \"f.prototype.foo\",\n        \"function (this:f): undefined\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<... function (this:f): [undefined]"
      },
      "65": {
        "test_path": "com.google.javascript.jscomp.TypeCheckTest",
        "test_method": "testFunctionInference16",
        "test_code": "testFunctionInference16() throws Exception {\n    testFunctionType(\n        \"/** @constructor */ function f() {};\" +\n        \"f.prototype.foo = function(){};\",\n        \"(new f).foo\",\n        \"function (this:f): undefined\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<... function (this:f): [undefined]"
      },
      "66": {
        "test_path": "com.google.javascript.jscomp.TypeCheckTest",
        "test_method": "testPrototypePropertyReference",
        "test_code": "testPrototypePropertyReference() throws Exception {\n    TypeCheckResult p = parseAndTypeCheckWithScope(\"\"\n        + \"/** @constructor */\\n\"\n        + \"function Foo() {}\\n\"\n        + \"/** @param {number} a */\\n\"\n        + \"Foo.prototype.bar = function(a){};\\n\"\n        + \"/** @param {Foo} f */\\n\"\n        + \"function baz(f) {\\n\"\n        + \"  Foo.prototype.bar.call(f, 3);\\n\"\n        + \"}\");\n    assertEquals(0, compiler.getErrorCount());\n    assertEquals(0, compiler.getWarningCount());\n\n    assertTrue(p.scope.getVar(\"Foo\").getType() instanceof FunctionType);\n    FunctionType fooType = (FunctionType) p.scope.getVar(\"Foo\").getType();\n    assertEquals(\"function (this:Foo, number): undefined\",\n                 fooType.getPrototype().getPropertyType(\"bar\").toString());\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<...(this:Foo, number): [undefined]> but was:<...(this:Foo, number): [?]>"
      },
      "67": {
        "test_path": "com.google.javascript.jscomp.TypeCheckTest",
        "test_method": "testGoodExtends7",
        "test_code": "testGoodExtends7() throws Exception {\n    testFunctionType(\n        \"Function.prototype.inherits = function(x) {};\" +\n        \"/** @constructor */function base() {}\\n\" +\n        \"/** @extends {base}\\n * @constructor */function derived() {}\\n\" +\n        \"derived.inherits(base);\",\n        \"(new derived).constructor\",\n        \"function (this:derived): undefined\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<...ion (this:derived): [undefined]"
      },
      "68": {
        "test_path": "com.google.javascript.jscomp.TypeCheckTest",
        "test_method": "testTypeRedefinition",
        "test_code": "testTypeRedefinition() throws Exception {\n    testTypes(\"a={};/**@enum {string}*/ a.A = {ZOR:'b'};\"\n        + \"/** @constructor */ a.A = function() {}\",\n        \"variable a.A redefined with type function (this:a.A): undefined, \" +\n        \"original definition at [testcode]:1 with type enum{a.A}\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<...unction (this:a.A): [undefined], original definitio...> but was:<...unction (this:a.A): [?], original definitio...>"
      },
      "69": {
        "test_path": "com.google.javascript.jscomp.TypeCheckTest",
        "test_method": "testFunctionInference1",
        "test_code": "testFunctionInference1() throws Exception {\n    testFunctionType(\n        \"function f(a) {}\",\n        \"function (?): undefined\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<...d   : function (?): [undefined]"
      },
      "70": {
        "test_path": "com.google.javascript.jscomp.TypeCheckTest",
        "test_method": "testFunctionInference2",
        "test_code": "testFunctionInference2() throws Exception {\n    testFunctionType(\n        \"function f(a,b) {}\",\n        \"function (?, ?): undefined\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<... : function (?, ?): [undefined]"
      },
      "71": {
        "test_path": "com.google.javascript.jscomp.TypeCheckTest",
        "test_method": "testFunctionInference3",
        "test_code": "testFunctionInference3() throws Exception {\n    testFunctionType(\n        \"function f(var_args) {}\",\n        \"function (...[?]): undefined\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<... function (...[?]): [undefined]"
      },
      "72": {
        "test_path": "com.google.javascript.jscomp.TypeCheckTest",
        "test_method": "testFunctionInference4",
        "test_code": "testFunctionInference4() throws Exception {\n    testFunctionType(\n        \"function f(a,b,c,var_args) {}\",\n        \"function (?, ?, ?, ...[?]): undefined\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<... (?, ?, ?, ...[?]): [undefined]"
      },
      "73": {
        "test_path": "com.google.javascript.jscomp.TypeCheckTest",
        "test_method": "testFunctionInference7",
        "test_code": "testFunctionInference7() throws Exception {\n    testFunctionType(\n        \"/** @this Date */function f(a,b,c,var_args) {}\",\n        \"function (this:Date, ?, ?, ?, ...[?]): undefined\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<..., ?, ?, ?, ...[?]): [undefined]"
      },
      "74": {
        "test_path": "com.google.javascript.jscomp.TypeCheckTest",
        "test_method": "testFunctionInference8",
        "test_code": "testFunctionInference8() throws Exception {\n    testFunctionType(\n        \"function f() {}\",\n        \"function (): undefined\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<...nd   : function (): [undefined]"
      },
      "75": {
        "test_path": "com.google.javascript.jscomp.TypeCheckTest",
        "test_method": "testFunctionInference9",
        "test_code": "testFunctionInference9() throws Exception {\n    testFunctionType(\n        \"var f = function() {};\",\n        \"function (): undefined\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<...nd   : function (): [undefined]"
      },
      "76": {
        "test_path": "com.google.javascript.jscomp.TypeCheckTest",
        "test_method": "testInterfaceInheritanceCheck7",
        "test_code": "testInterfaceInheritanceCheck7() throws Exception {\n    testTypes(\n        \"/** @interface */function Super() {};\" +\n        \"/** @param {number} bar */Super.prototype.foo = function(bar) {};\" +\n        \"/** @constructor\\n @implements {Super} */function Sub() {};\" +\n        \"/** @override\\n  @param {string} bar */Sub.prototype.foo =\\n\" +\n        \"function(bar) {};\",\n        \"mismatch of the foo property type and the type of the property it \" +\n        \"overrides from interface Super\\n\" +\n        \"original: function (this:Super, number): undefined\\n\" +\n        \"override: function (this:Sub, string): undefined\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<...his:Super, number): [undefined"
      },
      "77": {
        "test_path": "com.google.javascript.jscomp.TypeCheckTest",
        "test_method": "testDuplicateStaticMethodDecl1",
        "test_code": "testDuplicateStaticMethodDecl1() throws Exception {\n    testTypes(\n        \"var goog = goog || {};\" +\n        \"/** @param {number} x */ goog.foo = function(x) {};\" +\n        \"/** @param {number} x */ goog.foo = function(x) {};\",\n        \"variable goog.foo redefined with type function (number): undefined, \" +\n        \"original definition at [testcode]:1 with type function (number): undefined\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<... function (number): [undefined, original definition at [testcode]:1 with type function (number): undefined]> but was:<... function (number): [?, original definition at [testcode]:1 with type function (number): ?]>"
      },
      "78": {
        "test_path": "com.google.javascript.jscomp.TypeCheckTest",
        "test_method": "testDuplicateStaticMethodDecl5",
        "test_code": "testDuplicateStaticMethodDecl5() throws Exception {\n    testTypes(\n        \"var goog = goog || {};\" +\n        \"goog.foo = function(x) {};\" +\n        \"/** @return {undefined} */ goog.foo = function(x) {};\",\n        \"variable goog.foo redefined with type function (?): undefined, \" +\n        \"original definition at [testcode]:1 with type \" +\n        \"function (?): undefined\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<... type function (?): [undefined]> but was:<... type function (?): [?]>"
      },
      "79": {
        "test_path": "com.google.javascript.jscomp.TypedScopeCreatorTest",
        "test_method": "testConstructorNode",
        "test_code": "testConstructorNode() {\n    testSame(\"var goog = {}; /** @constructor */ goog.Foo = function() {};\");\n\n    ObjectType ctor = (ObjectType) (findNameType(\"goog.Foo\", globalScope));\n    assertNotNull(ctor);\n    assertTrue(ctor.isConstructor());\n    assertEquals(\"function (this:goog.Foo): undefined\", ctor.toString());\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<...on (this:goog.Foo): [undefined]> but was:<...on (this:goog.Foo): [?]>"
      },
      "80": {
        "test_path": "com.google.javascript.jscomp.TypedScopeCreatorTest",
        "test_method": "testPropertiesOnInterface",
        "test_code": "testPropertiesOnInterface() throws Exception {\n    testSame(\"/** @interface */ var I = function() {};\" +\n        \"/** @type {number} */ I.prototype.bar;\" +\n        \"I.prototype.baz = function(){};\");\n\n    Var i = globalScope.getVar(\"I\");\n    assertEquals(\"function (this:I): ?\", i.getType().toString());\n    assertTrue(i.getType().isInterface());\n\n    ObjectType iPrototype = (ObjectType)\n        ((ObjectType) i.getType()).getPropertyType(\"prototype\");\n    assertEquals(\"I.prototype\", iPrototype.toString());\n    assertTrue(iPrototype.isFunctionPrototypeType());\n\n    assertEquals(\"number\", iPrototype.getPropertyType(\"bar\").toString());\n    assertEquals(\"function (this:I): undefined\",\n        iPrototype.getPropertyType(\"baz\").toString());\n\n    assertEquals(iPrototype, globalScope.getVar(\"I.prototype\").getType());\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<function (this:I): [undefined]> but was:<function (this:I): [?]>"
      },
      "81": {
        "test_path": "com.google.javascript.jscomp.TypedScopeCreatorTest",
        "test_method": "testMethodBeforeFunction",
        "test_code": "testMethodBeforeFunction() throws Exception {\n    testSame(\n        \"var y = Window.prototype;\" +\n        \"Window.prototype.alert = function(message) {};\" +\n        \"/** @constructor */ function Window() {}\\n\" +\n        \"var window = new Window(); \\n\" +\n        \"var x = window;\");\n    ObjectType x = (ObjectType) findNameType(\"x\", globalScope);\n    assertEquals(\"Window\", x.toString());\n    assertTrue(x.getImplicitPrototype().hasOwnProperty(\"alert\"));\n    assertEquals(\"function (this:Window, ?): undefined\",\n        x.getPropertyType(\"alert\").toString());\n    assertTrue(x.isPropertyTypeDeclared(\"alert\"));\n\n    ObjectType y = (ObjectType) findNameType(\"y\", globalScope);\n    assertEquals(\"function (this:Window, ?): undefined\",\n        y.getPropertyType(\"alert\").toString());\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<...n (this:Window, ?): [undefined]> but was:<...n (this:Window, ?): [?]>"
      },
      "82": {
        "test_path": "com.google.javascript.jscomp.TypedScopeCreatorTest",
        "test_method": "testConstructorProperty",
        "test_code": "testConstructorProperty() {\n    testSame(\"var foo = {}; /** @constructor */ foo.Bar = function() {};\");\n    ObjectType foo = (ObjectType) findNameType(\"foo\", globalScope);\n    assertTrue(foo.hasProperty(\"Bar\"));\n    assertFalse(foo.isPropertyTypeInferred(\"Bar\"));\n\n    JSType fooBar = foo.getPropertyType(\"Bar\");\n    assertEquals(\"function (this:foo.Bar): undefined\", fooBar.toString());\n    assertEquals(Sets.newHashSet(foo), registry.getTypesWithProperty(\"Bar\"));\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<...ion (this:foo.Bar): [undefined]> but was:<...ion (this:foo.Bar): [?]>"
      },
      "83": {
        "test_path": "com.google.javascript.jscomp.TypedScopeCreatorTest",
        "test_method": "testReturnTypeInference1",
        "test_code": "testReturnTypeInference1() {\n    testSame(\"function f() {}\");\n    assertEquals(\n        \"function (): undefined\",\n        findNameType(\"f\", globalScope).toString());\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<function (): [undefined]> but was:<function (): [?]>"
      }
    },
    "buggy_files": {
      "0": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
      "1": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "2": "src/com/google/javascript/rhino/jstype/FunctionBuilder.java",
      "3": "src/com/google/javascript/rhino/jstype/FunctionType.java"
    },
    "hunk_type": "multi_file_four_or_more_hunks",
    "hunk_mapping": {
      "0": [
        {
          "start_line": 74,
          "end_line": 73,
          "file": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
          "code": "<START_BUG>\n<END_BUG>"
        }
      ],
      "1": [
        {
          "start_line": 200,
          "end_line": 202,
          "file": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
          "code": "<START_BUG>\n        info.getReturnType().evaluate(scope, typeRegistry) :\n        typeRegistry.getNativeType(UNKNOWN_TYPE);\n    if (templateTypeName != null &&\n<END_BUG>"
        }
      ],
      "2": [
        {
          "start_line": 213,
          "end_line": 213,
          "file": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
          "code": "<START_BUG>\n\n<END_BUG>"
        }
      ],
      "3": [
        {
          "start_line": 496,
          "end_line": 496,
          "file": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
          "code": "<START_BUG>\n          .withReturnType(returnType)\n<END_BUG>"
        }
      ],
      "4": [
        {
          "start_line": 577,
          "end_line": 576,
          "file": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
          "code": "<START_BUG>\n<END_BUG>"
        },
        {
          "start_line": 617,
          "end_line": 616,
          "file": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
          "code": "<START_BUG>\n<END_BUG>"
        },
        {
          "start_line": 634,
          "end_line": 633,
          "file": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
          "code": "<START_BUG>\n<END_BUG>"
        }
      ],
      "5": [
        {
          "start_line": 101,
          "end_line": 100,
          "file": "src/com/google/javascript/rhino/jstype/FunctionBuilder.java",
          "code": "<START_BUG>\n<END_BUG>"
        }
      ],
      "6": [
        {
          "start_line": 517,
          "end_line": 517,
          "file": "src/com/google/javascript/rhino/jstype/FunctionType.java",
          "code": "<START_BUG>\n        registry, null, null,\n<END_BUG>"
        }
      ]
    },
    "bug_report": {
      "url": "https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-143.json",
      "bug_description": "Auto-identify void functions",
      "title": ""
    }
  },
  "Mockito_30": {
    "buggy_hunks": {
      "0": {
        "start_line": 438,
        "end_line": 441,
        "file": "src/org/mockito/exceptions/Reporter.java",
        "code": "<START_BUG>\n    public void smartNullPointerException(Location location) {\n        throw new SmartNullPointerException(join(\n                \"You have a NullPointerException here:\",\n                new Location(),\n<END_BUG>"
      },
      "1": {
        "start_line": 56,
        "end_line": 56,
        "file": "src/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java",
        "code": "<START_BUG>\n            new Reporter().smartNullPointerException(location);\n<END_BUG>"
      }
    },
    "buggy_code": {
      "0": {
        "start_line": 438,
        "end_line": 446,
        "file": "src/org/mockito/exceptions/Reporter.java",
        "code": "public void smartNullPointerException(Location location) {\n        throw new SmartNullPointerException(join(\n                \"You have a NullPointerException here:\",\n                new Location(),\n                \"Because this method was *not* stubbed correctly:\",\n                location,\n                \"\"\n                ));\n    }",
        "javadoc": ""
      },
      "1": {
        "start_line": 51,
        "end_line": 58,
        "file": "src/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java",
        "code": "public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {\n            if (new ObjectMethodsGuru().isToString(method)) {\n                return \"SmartNull returned by unstubbed \" + formatMethodCall()  + \" method on mock\";\n            }\n\n            new Reporter().smartNullPointerException(location);\n            return null;\n        }",
        "javadoc": ""
      }
    },
    "delineated_bug": {
      "0": {
        "start_line": 438,
        "end_line": 446,
        "file": "src/org/mockito/exceptions/Reporter.java",
        "code": "<START_BUG>\npublic void smartNullPointerException(Location location) {\n        throw new SmartNullPointerException(join(\n                \"You have a NullPointerException here:\",\n                new Location(),\n<END_BUG>\n                \"Because this method was *not* stubbed correctly:\",\n                location,\n                \"\"\n                ));\n    }",
        "javadoc": ""
      },
      "1": {
        "start_line": 51,
        "end_line": 58,
        "file": "src/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java",
        "code": "public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {\n            if (new ObjectMethodsGuru().isToString(method)) {\n                return \"SmartNull returned by unstubbed \" + formatMethodCall()  + \" method on mock\";\n            }\n\n<START_BUG>\n            new Reporter().smartNullPointerException(location);\n<END_BUG>\n            return null;\n        }",
        "javadoc": ""
      }
    },
    "contained_scope": "method",
    "bug_count": 2,
    "triggered_tests": {
      "0": {
        "test_path": "org.mockito.internal.stubbing.defaultanswers.ReturnsSmartNullsTest",
        "test_method": "shouldPrintTheParametersOnSmartNullPointerExceptionMessage",
        "test_code": "shouldPrintTheParametersOnSmartNullPointerExceptionMessage() throws Throwable {\n    \tAnswer<Object> answer = new ReturnsSmartNulls();\n\n        Foo smartNull = (Foo) answer.answer(invocationOf(Foo.class, \"withArgs\", \"oompa\", \"lumpa\"));\n\n        try {\n            smartNull.get();\n            fail();\n        } catch (SmartNullPointerException ex) {\n        \tString message = ex.getMessage();\n        \tassertTrue(\"Exception message should include oompa and lumpa, but was: \" + message,\n        \t\t\tmessage.contains(\"oompa, lumpa\"));\n        }\n\t}",
        "clean_err_msg": "junit.framework.AssertionFailedError: Exception message should include oompa and lumpa, but was: "
      }
    },
    "buggy_files": {
      "0": "src/org/mockito/exceptions/Reporter.java",
      "1": "src/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java"
    },
    "hunk_type": "multi_file_two_hunks",
    "hunk_mapping": {
      "0": [
        {
          "start_line": 438,
          "end_line": 441,
          "file": "src/org/mockito/exceptions/Reporter.java",
          "code": "<START_BUG>\n    public void smartNullPointerException(Location location) {\n        throw new SmartNullPointerException(join(\n                \"You have a NullPointerException here:\",\n                new Location(),\n<END_BUG>"
        }
      ],
      "1": [
        {
          "start_line": 56,
          "end_line": 56,
          "file": "src/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java",
          "code": "<START_BUG>\n            new Reporter().smartNullPointerException(location);\n<END_BUG>"
        }
      ]
    },
    "bug_report": {
      "url": "https://code.google.com/archive/p/mockito/issues/225",
      "bug_description": "SmartNulls should identify the arguments that the stubbed method was invoked with",
      "title": ""
    }
  },
  "Closure_135": {
    "buggy_hunks": {
      "0": {
        "start_line": 362,
        "end_line": 361,
        "file": "src/com/google/javascript/jscomp/DevirtualizePrototypeMethods.java",
        "code": "<START_BUG>\n<END_BUG>"
      },
      "1": {
        "start_line": 412,
        "end_line": 411,
        "file": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "code": "<START_BUG>\n<END_BUG>"
      },
      "2": {
        "start_line": 472,
        "end_line": 471,
        "file": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "code": "<START_BUG>\n<END_BUG>"
      }
    },
    "buggy_code": {
      "0": {
        "start_line": 354,
        "end_line": 367,
        "file": "src/com/google/javascript/jscomp/DevirtualizePrototypeMethods.java",
        "code": "private void replaceReferencesToThis(Node node, String name) {\n    if (NodeUtil.isFunction(node)) {\n      return;\n    }\n\n    for (Node child : node.children()) {\n      if (NodeUtil.isThis(child)) {\n        Node newName = Node.newString(Token.NAME, name);\n        node.replaceChild(child, newName);\n      } else {\n        replaceReferencesToThis(child, name);\n      }\n    }\n  }",
        "javadoc": "/**\n * Replaces references to \"this\" with references to name.  Do not\n * traverse function boundaries.\n */\n"
      },
      "1": {
        "start_line": 412,
        "end_line": 412,
        "file": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "code": "",
        "javadoc": ""
      },
      "2": {
        "start_line": 466,
        "end_line": 480,
        "file": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "code": "@Override\n  boolean defineProperty(String name, JSType type,\n      boolean inferred, boolean inExterns) {\n    if (\"prototype\".equals(name)) {\n      ObjectType objType = type.toObjectType();\n      if (objType != null) {\n        return setPrototype(\n            new FunctionPrototypeType(\n                registry, this, objType, isNativeObjectType()));\n      } else {\n        return false;\n      }\n    }\n    return super.defineProperty(name, type, inferred, inExterns);\n  }",
        "javadoc": ""
      }
    },
    "delineated_bug": {
      "0": {
        "start_line": 354,
        "end_line": 367,
        "file": "src/com/google/javascript/jscomp/DevirtualizePrototypeMethods.java",
        "code": "private void replaceReferencesToThis(Node node, String name) {\n    if (NodeUtil.isFunction(node)) {\n      return;\n    }\n\n    for (Node child : node.children()) {\n      if (NodeUtil.isThis(child)) {\n        Node newName = Node.newString(Token.NAME, name);\n<END_BUG>\n<START_BUG>\n        node.replaceChild(child, newName);\n      } else {\n        replaceReferencesToThis(child, name);\n      }\n    }\n  }",
        "javadoc": "/**\n * Replaces references to \"this\" with references to name.  Do not\n * traverse function boundaries.\n */\n"
      },
      "1": {
        "start_line": 412,
        "end_line": 412,
        "file": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "code": "<START_BUG>\n\n<END_BUG>",
        "javadoc": ""
      },
      "2": {
        "start_line": 466,
        "end_line": 480,
        "file": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "code": "@Override\n  boolean defineProperty(String name, JSType type,\n      boolean inferred, boolean inExterns) {\n    if (\"prototype\".equals(name)) {\n      ObjectType objType = type.toObjectType();\n      if (objType != null) {\n<END_BUG>\n<START_BUG>\n        return setPrototype(\n            new FunctionPrototypeType(\n                registry, this, objType, isNativeObjectType()));\n      } else {\n        return false;\n      }\n    }\n    return super.defineProperty(name, type, inferred, inExterns);\n  }",
        "javadoc": ""
      }
    },
    "contained_scope": "file",
    "bug_count": 3,
    "triggered_tests": {
      "0": {
        "test_path": "com.google.javascript.jscomp.DevirtualizePrototypeMethodsTest",
        "test_method": "testRewritePrototypeMethods2",
        "test_code": "testRewritePrototypeMethods2() throws Exception {\n    // type checking on\n    enableTypeCheck(CheckLevel.ERROR);\n    checkTypes(RewritePrototypeMethodTestInput.INPUT,\n               RewritePrototypeMethodTestInput.EXPECTED,\n               RewritePrototypeMethodTestInput.EXPECTED_TYPE_CHECKING_ON);\n  }",
        "clean_err_msg": "junit.framework.AssertionFailedError: expected:<[FUNCTION a = function (this:a): ?, NAME JSCompiler_StaticMethods_foo$self = a, FUNCTION JSCompiler_StaticMethods_foo = function (a): number, NAME JSCompiler_StaticMethods_bar$self = a, FUNCTION JSCompiler_StaticMethods_bar = function (a, number): number, FUNCTION JSCompiler_StaticMethods_baz = function (a): ?, NEW a = a, CALL JSCompiler_StaticMethods_foo = number, CALL JSCompiler_StaticMethods_bar = number, CALL JSCompiler_StaticMethods_baz = ?]> but was:<[FUNCTION a = function (this:a): ?, NAME JSCompiler_StaticMethods_foo$self = null, FUNCTION JSCompiler_StaticMethods_foo = function (a): number, NAME JSCompiler_StaticMethods_bar$self = null, FUNCTION JSCompiler_StaticMethods_bar = function (a, number): number, FUNCTION JSCompiler_StaticMethods_baz = function (a): ?, NEW a = a, CALL JSCompiler_StaticMethods_foo = number, CALL JSCompiler_StaticMethods_bar = number, CALL JSCompiler_StaticMethods_baz = ?]>"
      },
      "1": {
        "test_path": "com.google.javascript.jscomp.TypeCheckTest",
        "test_method": "testGoodExtends9",
        "test_code": "testGoodExtends9() throws Exception {\n    testTypes(\n        \"/** @constructor */ function Super() {}\" +\n        \"Super.prototype.foo = function() {};\" +\n        \"/** @constructor \\n * @extends {Super} */ function Sub() {}\" +\n        \"Sub.prototype = new Super();\" +\n        \"/** @override */ Sub.prototype.foo = function() {};\");\n  }",
        "clean_err_msg": "junit.framework.AssertionFailedError: unexpected warnings(s):"
      }
    },
    "buggy_files": {
      "0": "src/com/google/javascript/jscomp/DevirtualizePrototypeMethods.java",
      "1": "src/com/google/javascript/rhino/jstype/FunctionType.java"
    },
    "hunk_type": "multi_file_three_hunks",
    "hunk_mapping": {
      "0": [
        {
          "start_line": 362,
          "end_line": 361,
          "file": "src/com/google/javascript/jscomp/DevirtualizePrototypeMethods.java",
          "code": "<START_BUG>\n<END_BUG>"
        }
      ],
      "1": [
        {
          "start_line": 412,
          "end_line": 411,
          "file": "src/com/google/javascript/rhino/jstype/FunctionType.java",
          "code": "<START_BUG>\n<END_BUG>"
        }
      ],
      "2": [
        {
          "start_line": 472,
          "end_line": 471,
          "file": "src/com/google/javascript/rhino/jstype/FunctionType.java",
          "code": "<START_BUG>\n<END_BUG>"
        }
      ]
    },
    "bug_report": {
      "url": "https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-59.json",
      "bug_description": "Inheritance not detected when prototype directly assigned",
      "title": ""
    }
  },
  "Mockito_17": {
    "buggy_hunks": {
      "0": {
        "start_line": 20,
        "end_line": 22,
        "file": "src/org/mockito/internal/creation/MockSettingsImpl.java",
        "code": "<START_BUG>\n\n    public MockSettings serializable() {\n        return this.extraInterfaces(java.io.Serializable.class);\n<END_BUG>"
      },
      "1": {
        "start_line": 74,
        "end_line": 74,
        "file": "src/org/mockito/internal/creation/MockSettingsImpl.java",
        "code": "<START_BUG>\n        return extraInterfaces != null && java.util.Arrays.asList(extraInterfaces).contains(java.io.Serializable.class);\n<END_BUG>"
      },
      "2": {
        "start_line": 19,
        "end_line": 18,
        "file": "src/org/mockito/internal/util/MockUtil.java",
        "code": "<START_BUG>\n<END_BUG>"
      },
      "3": {
        "start_line": 45,
        "end_line": 45,
        "file": "src/org/mockito/internal/util/MockUtil.java",
        "code": "<START_BUG>\n            ancillaryTypes = interfaces == null ? new Class<?>[0] : interfaces;\n<END_BUG>"
      }
    },
    "buggy_code": {
      "0": {
        "start_line": 21,
        "end_line": 23,
        "file": "src/org/mockito/internal/creation/MockSettingsImpl.java",
        "code": "public MockSettings serializable() {\n        return this.extraInterfaces(java.io.Serializable.class);\n    }",
        "javadoc": ""
      },
      "1": {
        "start_line": 73,
        "end_line": 75,
        "file": "src/org/mockito/internal/creation/MockSettingsImpl.java",
        "code": "public boolean isSerializable() {\n        return extraInterfaces != null && java.util.Arrays.asList(extraInterfaces).contains(java.io.Serializable.class);\n    }",
        "javadoc": ""
      },
      "2": {
        "start_line": 19,
        "end_line": 19,
        "file": "src/org/mockito/internal/util/MockUtil.java",
        "code": "",
        "javadoc": ""
      },
      "3": {
        "start_line": 33,
        "end_line": 56,
        "file": "src/org/mockito/internal/util/MockUtil.java",
        "code": "public <T> T createMock(Class<T> classToMock, MockSettingsImpl settings) {\n        creationValidator.validateType(classToMock);\n        creationValidator.validateExtraInterfaces(classToMock, settings.getExtraInterfaces());\n        creationValidator.validateMockedType(classToMock, settings.getSpiedInstance());\n\n        settings.initiateMockName(classToMock);\n\n        MockHandler<T> mockHandler = new MockHandler<T>(settings);\n        MethodInterceptorFilter filter = new MethodInterceptorFilter(mockHandler, settings);\n        Class<?>[] interfaces = settings.getExtraInterfaces();\n\n        Class<?>[] ancillaryTypes;\n            ancillaryTypes = interfaces == null ? new Class<?>[0] : interfaces;\n\n        Object spiedInstance = settings.getSpiedInstance();\n        \n        T mock = ClassImposterizer.INSTANCE.imposterise(filter, classToMock, ancillaryTypes);\n        \n        if (spiedInstance != null) {\n            new LenientCopyTool().copyToMock(spiedInstance, mock);\n        }\n        \n        return mock;\n    }",
        "javadoc": ""
      }
    },
    "delineated_bug": {
      "0": {
        "start_line": 21,
        "end_line": 23,
        "file": "src/org/mockito/internal/creation/MockSettingsImpl.java",
        "code": "<START_BUG>\npublic MockSettings serializable() {\n        return this.extraInterfaces(java.io.Serializable.class);\n<END_BUG>\n    }",
        "javadoc": ""
      },
      "1": {
        "start_line": 73,
        "end_line": 75,
        "file": "src/org/mockito/internal/creation/MockSettingsImpl.java",
        "code": "public boolean isSerializable() {\n<START_BUG>\n        return extraInterfaces != null && java.util.Arrays.asList(extraInterfaces).contains(java.io.Serializable.class);\n<END_BUG>\n    }",
        "javadoc": ""
      },
      "2": {
        "start_line": 19,
        "end_line": 19,
        "file": "src/org/mockito/internal/util/MockUtil.java",
        "code": "<START_BUG>\n\n<END_BUG>",
        "javadoc": ""
      },
      "3": {
        "start_line": 33,
        "end_line": 56,
        "file": "src/org/mockito/internal/util/MockUtil.java",
        "code": "public <T> T createMock(Class<T> classToMock, MockSettingsImpl settings) {\n        creationValidator.validateType(classToMock);\n        creationValidator.validateExtraInterfaces(classToMock, settings.getExtraInterfaces());\n        creationValidator.validateMockedType(classToMock, settings.getSpiedInstance());\n\n        settings.initiateMockName(classToMock);\n\n        MockHandler<T> mockHandler = new MockHandler<T>(settings);\n        MethodInterceptorFilter filter = new MethodInterceptorFilter(mockHandler, settings);\n        Class<?>[] interfaces = settings.getExtraInterfaces();\n\n        Class<?>[] ancillaryTypes;\n<START_BUG>\n            ancillaryTypes = interfaces == null ? new Class<?>[0] : interfaces;\n<END_BUG>\n\n        Object spiedInstance = settings.getSpiedInstance();\n        \n        T mock = ClassImposterizer.INSTANCE.imposterise(filter, classToMock, ancillaryTypes);\n        \n        if (spiedInstance != null) {\n            new LenientCopyTool().copyToMock(spiedInstance, mock);\n        }\n        \n        return mock;\n    }",
        "javadoc": ""
      }
    },
    "contained_scope": "file",
    "bug_count": 4,
    "triggered_tests": {
      "0": {
        "test_path": "org.mockitousage.basicapi.MocksSerializationTest",
        "test_method": "shouldBeSerializeAndHaveExtraInterfaces",
        "test_code": "shouldBeSerializeAndHaveExtraInterfaces() throws Exception {\n        //when\n        IMethods mock = mock(IMethods.class, withSettings().serializable().extraInterfaces(List.class));\n        IMethods mockTwo = mock(IMethods.class, withSettings().extraInterfaces(List.class).serializable());\n\n        //then\n        serializeAndBack((List) mock);\n        serializeAndBack((List) mockTwo);\n    }",
        "clean_err_msg": "java.io.NotSerializableException: org.mockitousage.IMethods$$EnhancerByMockitoWithCGLIB$$a155cf16"
      }
    },
    "buggy_files": {
      "0": "src/org/mockito/internal/creation/MockSettingsImpl.java",
      "1": "src/org/mockito/internal/util/MockUtil.java"
    },
    "hunk_type": "multi_file_four_or_more_hunks",
    "hunk_mapping": {
      "0": [
        {
          "start_line": 20,
          "end_line": 22,
          "file": "src/org/mockito/internal/creation/MockSettingsImpl.java",
          "code": "<START_BUG>\n\n    public MockSettings serializable() {\n        return this.extraInterfaces(java.io.Serializable.class);\n<END_BUG>"
        }
      ],
      "1": [
        {
          "start_line": 74,
          "end_line": 74,
          "file": "src/org/mockito/internal/creation/MockSettingsImpl.java",
          "code": "<START_BUG>\n        return extraInterfaces != null && java.util.Arrays.asList(extraInterfaces).contains(java.io.Serializable.class);\n<END_BUG>"
        }
      ],
      "2": [
        {
          "start_line": 19,
          "end_line": 18,
          "file": "src/org/mockito/internal/util/MockUtil.java",
          "code": "<START_BUG>\n<END_BUG>"
        }
      ],
      "3": [
        {
          "start_line": 45,
          "end_line": 45,
          "file": "src/org/mockito/internal/util/MockUtil.java",
          "code": "<START_BUG>\n            ancillaryTypes = interfaces == null ? new Class<?>[0] : interfaces;\n<END_BUG>"
        }
      ]
    },
    "bug_report": {
      "url": "https://code.google.com/archive/p/mockito/issues/152",
      "bug_description": "User should be able to set serializable and yet configure his own extra interfaces",
      "title": ""
    }
  },
  "Closure_90": {
    "buggy_hunks": {
      "0": {
        "start_line": 184,
        "end_line": 184,
        "file": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "code": "<START_BUG>\n      if (!type.isSubtype(\n<END_BUG>"
      },
      "1": {
        "start_line": 880,
        "end_line": 879,
        "file": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "code": "<START_BUG>\n<END_BUG>"
      }
    },
    "buggy_code": {
      "0": {
        "start_line": 176,
        "end_line": 190,
        "file": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "code": "@Override\n    public boolean apply(JSType type) {\n      // TODO(user): Doing an instanceof check here is too\n      // restrictive as (Date,Error) is, for instance, an object type\n      // even though its implementation is a UnionType. Would need to\n      // create interfaces JSType, ObjectType, FunctionType etc and have\n      // separate implementation instead of the class hierarchy, so that\n      // union types can also be object types, etc.\n      if (!type.isSubtype(\n              typeRegistry.getNativeType(OBJECT_TYPE))) {\n        reportWarning(THIS_TYPE_NON_OBJECT, type.toString());\n        return false;\n      }\n      return true;\n    }",
        "javadoc": ""
      },
      "1": {
        "start_line": 861,
        "end_line": 903,
        "file": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "code": "@Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    setResolvedTypeInternal(this);\n\n    call = (ArrowType) safeResolve(call, t, scope);\n    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n\n    // Warning about typeOfThis if it doesn't resolve to an ObjectType\n    // is handled further upstream.\n    //\n    // TODO(nicksantos): Handle this correctly if we have a UnionType.\n    //\n    // TODO(nicksantos): In ES3, the runtime coerces \"null\" to the global\n    // activation object. In ES5, it leaves it as null. Just punt on this\n    // issue for now by coercing out null. This is complicated by the\n    // fact that when most people write @this {Foo}, they really don't\n    // mean \"nullable Foo\". For certain tags (like @extends) we de-nullify\n    // the name for them.\n    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n    if (maybeTypeOfThis instanceof ObjectType) {\n      typeOfThis = (ObjectType) maybeTypeOfThis;\n    }\n\n    boolean changed = false;\n    ImmutableList.Builder<ObjectType> resolvedInterfaces =\n        ImmutableList.builder();\n    for (ObjectType iface : implementedInterfaces) {\n      ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n      resolvedInterfaces.add(resolvedIface);\n      changed |= (resolvedIface != iface);\n    }\n    if (changed) {\n      implementedInterfaces = resolvedInterfaces.build();\n    }\n\n    if (subTypes != null) {\n      for (int i = 0; i < subTypes.size(); i++) {\n        subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n      }\n    }\n\n    return super.resolveInternal(t, scope);\n  }",
        "javadoc": ""
      }
    },
    "delineated_bug": {
      "0": {
        "start_line": 176,
        "end_line": 190,
        "file": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "code": "@Override\n    public boolean apply(JSType type) {\n      // TODO(user): Doing an instanceof check here is too\n      // restrictive as (Date,Error) is, for instance, an object type\n      // even though its implementation is a UnionType. Would need to\n      // create interfaces JSType, ObjectType, FunctionType etc and have\n      // separate implementation instead of the class hierarchy, so that\n      // union types can also be object types, etc.\n<START_BUG>\n      if (!type.isSubtype(\n<END_BUG>\n              typeRegistry.getNativeType(OBJECT_TYPE))) {\n        reportWarning(THIS_TYPE_NON_OBJECT, type.toString());\n        return false;\n      }\n      return true;\n    }",
        "javadoc": ""
      },
      "1": {
        "start_line": 861,
        "end_line": 903,
        "file": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "code": "@Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    setResolvedTypeInternal(this);\n\n    call = (ArrowType) safeResolve(call, t, scope);\n    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n\n    // Warning about typeOfThis if it doesn't resolve to an ObjectType\n    // is handled further upstream.\n    //\n    // TODO(nicksantos): Handle this correctly if we have a UnionType.\n    //\n    // TODO(nicksantos): In ES3, the runtime coerces \"null\" to the global\n    // activation object. In ES5, it leaves it as null. Just punt on this\n    // issue for now by coercing out null. This is complicated by the\n    // fact that when most people write @this {Foo}, they really don't\n    // mean \"nullable Foo\". For certain tags (like @extends) we de-nullify\n    // the name for them.\n    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n<END_BUG>\n<START_BUG>\n    if (maybeTypeOfThis instanceof ObjectType) {\n      typeOfThis = (ObjectType) maybeTypeOfThis;\n    }\n\n    boolean changed = false;\n    ImmutableList.Builder<ObjectType> resolvedInterfaces =\n        ImmutableList.builder();\n    for (ObjectType iface : implementedInterfaces) {\n      ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n      resolvedInterfaces.add(resolvedIface);\n      changed |= (resolvedIface != iface);\n    }\n    if (changed) {\n      implementedInterfaces = resolvedInterfaces.build();\n    }\n\n    if (subTypes != null) {\n      for (int i = 0; i < subTypes.size(); i++) {\n        subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n      }\n    }\n\n    return super.resolveInternal(t, scope);\n  }",
        "javadoc": ""
      }
    },
    "contained_scope": "method",
    "bug_count": 2,
    "triggered_tests": {
      "0": {
        "test_path": "com.google.javascript.jscomp.TypeCheckTest",
        "test_method": "testBackwardsTypedefUse8",
        "test_code": "testBackwardsTypedefUse8() throws Exception {\n    // Tehnically, this isn't quite right, because the JS runtime\n    // will coerce null -> the global object. But we'll punt on that for now.\n    testTypes(\n        \"/** @param {!Array} x */ function g(x) {}\" +\n        \"/** @this {goog.MyTypedef} */ function f() { g(this); }\" +\n        \"var goog = {};\" +\n        \"/** @typedef {(Array|null|undefined)} */ goog.MyTypedef;\");\n  }",
        "clean_err_msg": "junit.framework.AssertionFailedError: unexpected warnings(s):"
      },
      "1": {
        "test_path": "com.google.javascript.jscomp.TypeCheckTest",
        "test_method": "testBackwardsTypedefUse9",
        "test_code": "testBackwardsTypedefUse9() throws Exception {\n    testTypes(\n        \"/** @param {!Array} x */ function g(x) {}\" +\n        \"/** @this {goog.MyTypedef} */ function f() { g(this); }\" +\n        \"var goog = {};\" +\n        \"/** @typedef {(Error|null|undefined)} */ goog.MyTypedef;\",\n        \"actual parameter 1 of g does not match formal parameter\\n\" +\n        \"found   : Error\\n\" +\n        \"required: Array\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<[actual parameter 1 of g does not match formal parameter"
      }
    },
    "buggy_files": {
      "0": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
      "1": "src/com/google/javascript/rhino/jstype/FunctionType.java"
    },
    "hunk_type": "multi_file_two_hunks",
    "hunk_mapping": {
      "0": [
        {
          "start_line": 184,
          "end_line": 184,
          "file": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
          "code": "<START_BUG>\n      if (!type.isSubtype(\n<END_BUG>"
        }
      ],
      "1": [
        {
          "start_line": 880,
          "end_line": 879,
          "file": "src/com/google/javascript/rhino/jstype/FunctionType.java",
          "code": "<START_BUG>\n<END_BUG>"
        }
      ]
    },
    "bug_report": {
      "url": "https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-274.json",
      "bug_description": "@this emits warning when used with a typedef",
      "title": ""
    }
  },
  "Closure_110": {
    "buggy_hunks": {
      "0": {
        "start_line": 358,
        "end_line": 357,
        "file": "src/com/google/javascript/jscomp/ScopedAliases.java",
        "code": "<START_BUG>\n<END_BUG>"
      },
      "1": {
        "start_line": 366,
        "end_line": 371,
        "file": "src/com/google/javascript/jscomp/ScopedAliases.java",
        "code": "<START_BUG>\n        } else if (isVar) {\n          Node grandparent = parent.getParent();\n          Node value = n.hasChildren() ?\n              v.getInitialValue().detachFromParent() :\n              null;\n          Node varNode = parent;\n<END_BUG>"
      },
      "2": {
        "start_line": 383,
        "end_line": 383,
        "file": "src/com/google/javascript/jscomp/ScopedAliases.java",
        "code": "<START_BUG>\n            // Replace \"function NAME() { ... }\" with \"var NAME;\".\n<END_BUG>"
      },
      "3": {
        "start_line": 392,
        "end_line": 394,
        "file": "src/com/google/javascript/jscomp/ScopedAliases.java",
        "code": "<START_BUG>\n\n              // If this is a VAR, we can just detach the expression and\n              // the tree will still be valid.\n<END_BUG>"
      },
      "4": {
        "start_line": 408,
        "end_line": 408,
        "file": "src/com/google/javascript/jscomp/ScopedAliases.java",
        "code": "<START_BUG>\n              grandparent.addChildBefore(newDecl, varNode);\n<END_BUG>"
      },
      "5": {
        "start_line": 554,
        "end_line": 553,
        "file": "src/com/google/javascript/rhino/Node.java",
        "code": "<START_BUG>\n<END_BUG>"
      }
    },
    "buggy_code": {
      "0": {
        "start_line": 352,
        "end_line": 422,
        "file": "src/com/google/javascript/jscomp/ScopedAliases.java",
        "code": "private void findAliases(NodeTraversal t) {\n      Scope scope = t.getScope();\n      for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n          recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n          // Bleeding functions already get a BAD_PARAMETERS error, so just\n          // do nothing.\n        } else if (parent.getType() == Token.LP) {\n          // Parameters of the scope function also get a BAD_PARAMETERS\n          // error.\n        } else if (isVar) {\n          Node grandparent = parent.getParent();\n          Node value = n.hasChildren() ?\n              v.getInitialValue().detachFromParent() :\n              null;\n          Node varNode = parent;\n\n          String name = n.getString();\n          int nameCount = scopedAliasNames.count(name);\n          scopedAliasNames.add(name);\n          String globalName =\n              \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n\n          compiler.ensureLibraryInjected(\"base\");\n\n          // First, we need to free up the function expression (EXPR)\n          // to be used in another expression.\n            // Replace \"function NAME() { ... }\" with \"var NAME;\".\n\n            // We can't keep the local name on the function expression,\n            // because IE is buggy and will leak the name into the global\n            // scope. This is covered in more detail here:\n            // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n            //\n            // This will only cause problems if this is a hoisted, recursive\n            // function, and the programmer is using the hoisting.\n\n              // If this is a VAR, we can just detach the expression and\n              // the tree will still be valid.\n\n          // Add $jscomp.scope.name = EXPR;\n          // Make sure we copy over all the jsdoc and debug info.\n          if (value != null || v.getJSDocInfo() != null) {\n            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n                compiler.getCodingConvention(),\n                globalName,\n                value,\n                v.getJSDocInfo())\n                .useSourceInfoIfMissingFromForTree(n);\n            NodeUtil.setDebugInformation(\n                newDecl.getFirstChild().getFirstChild(), n, name);\n\n              grandparent.addChildBefore(newDecl, varNode);\n          }\n\n          // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n          v.getNameNode().addChildToFront(\n              NodeUtil.newQualifiedNameNode(\n                  compiler.getCodingConvention(), globalName, n, name));\n\n          recordAlias(v);\n        } else {\n          // Do not other kinds of local symbols, like catch params.\n          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n      }\n    }",
        "javadoc": ""
      },
      "1": {
        "start_line": 549,
        "end_line": 562,
        "file": "src/com/google/javascript/rhino/Node.java",
        "code": "public Node getChildBefore(Node child) {\n    if (child == first) {\n      return null;\n    }\n    Node n = first;\n\n    while (n.next != child) {\n      n = n.next;\n      if (n == null) {\n        throw new RuntimeException(\"node is not a child\");\n      }\n    }\n    return n;\n  }",
        "javadoc": ""
      }
    },
    "delineated_bug": {
      "0": {
        "start_line": 352,
        "end_line": 422,
        "file": "src/com/google/javascript/jscomp/ScopedAliases.java",
        "code": "private void findAliases(NodeTraversal t) {\n      Scope scope = t.getScope();\n      for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n<END_BUG>\n<START_BUG>\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n          recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n          // Bleeding functions already get a BAD_PARAMETERS error, so just\n          // do nothing.\n        } else if (parent.getType() == Token.LP) {\n          // Parameters of the scope function also get a BAD_PARAMETERS\n          // error.\n<START_BUG>\n        } else if (isVar) {\n          Node grandparent = parent.getParent();\n          Node value = n.hasChildren() ?\n              v.getInitialValue().detachFromParent() :\n              null;\n          Node varNode = parent;\n<END_BUG>\n\n          String name = n.getString();\n          int nameCount = scopedAliasNames.count(name);\n          scopedAliasNames.add(name);\n          String globalName =\n              \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n\n          compiler.ensureLibraryInjected(\"base\");\n\n          // First, we need to free up the function expression (EXPR)\n          // to be used in another expression.\n<START_BUG>\n            // Replace \"function NAME() { ... }\" with \"var NAME;\".\n<END_BUG>\n\n            // We can't keep the local name on the function expression,\n            // because IE is buggy and will leak the name into the global\n            // scope. This is covered in more detail here:\n            // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n            //\n            // This will only cause problems if this is a hoisted, recursive\n            // function, and the programmer is using the hoisting.\n<START_BUG>\n\n              // If this is a VAR, we can just detach the expression and\n              // the tree will still be valid.\n<END_BUG>\n\n          // Add $jscomp.scope.name = EXPR;\n          // Make sure we copy over all the jsdoc and debug info.\n          if (value != null || v.getJSDocInfo() != null) {\n            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n                compiler.getCodingConvention(),\n                globalName,\n                value,\n                v.getJSDocInfo())\n                .useSourceInfoIfMissingFromForTree(n);\n            NodeUtil.setDebugInformation(\n                newDecl.getFirstChild().getFirstChild(), n, name);\n\n<START_BUG>\n              grandparent.addChildBefore(newDecl, varNode);\n<END_BUG>\n          }\n\n          // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n          v.getNameNode().addChildToFront(\n              NodeUtil.newQualifiedNameNode(\n                  compiler.getCodingConvention(), globalName, n, name));\n\n          recordAlias(v);\n        } else {\n          // Do not other kinds of local symbols, like catch params.\n          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n      }\n    }",
        "javadoc": ""
      },
      "1": {
        "start_line": 549,
        "end_line": 562,
        "file": "src/com/google/javascript/rhino/Node.java",
        "code": "public Node getChildBefore(Node child) {\n    if (child == first) {\n      return null;\n    }\n    Node n = first;\n<END_BUG>\n<START_BUG>\n\n    while (n.next != child) {\n      n = n.next;\n      if (n == null) {\n        throw new RuntimeException(\"node is not a child\");\n      }\n    }\n    return n;\n  }",
        "javadoc": ""
      }
    },
    "contained_scope": "method",
    "bug_count": 2,
    "triggered_tests": {
      "0": {
        "test_path": "com.google.javascript.jscomp.ScopedAliasesTest",
        "test_method": "testHoistedFunctionDeclaration",
        "test_code": "testHoistedFunctionDeclaration() {\n    testScoped(\" g(f); function f() {} \",\n               SCOPE_NAMESPACE +\n               \" $jscomp.scope.f = function () {}; \" +\n               \"g($jscomp.scope.f); \");\n  }",
        "clean_err_msg": "junit.framework.AssertionFailedError: Unexpected error(s): JSC_GOOG_SCOPE_NON_ALIAS_LOCAL. The local variable f is in a goog.scope and is not an alias. at testcode line 1 : 39 expected:<0> but was:<1>"
      },
      "1": {
        "test_path": "com.google.javascript.jscomp.ScopedAliasesTest",
        "test_method": "testFunctionDeclaration",
        "test_code": "testFunctionDeclaration() {\n    testScoped(\"if (x) { function f() {} } g(f)\",\n               SCOPE_NAMESPACE +\n               \"if (x) { $jscomp.scope.f = function () {}; } \" +\n               \"g($jscomp.scope.f); \");\n  }",
        "clean_err_msg": "junit.framework.AssertionFailedError: Unexpected error(s): JSC_GOOG_SCOPE_NON_ALIAS_LOCAL. The local variable f is in a goog.scope and is not an alias. at testcode line 1 : 41 expected:<0> but was:<1>"
      }
    },
    "buggy_files": {
      "0": "src/com/google/javascript/jscomp/ScopedAliases.java",
      "1": "src/com/google/javascript/rhino/Node.java"
    },
    "hunk_type": "multi_file_four_or_more_hunks",
    "hunk_mapping": {
      "0": [
        {
          "start_line": 358,
          "end_line": 357,
          "file": "src/com/google/javascript/jscomp/ScopedAliases.java",
          "code": "<START_BUG>\n<END_BUG>"
        },
        {
          "start_line": 366,
          "end_line": 371,
          "file": "src/com/google/javascript/jscomp/ScopedAliases.java",
          "code": "<START_BUG>\n        } else if (isVar) {\n          Node grandparent = parent.getParent();\n          Node value = n.hasChildren() ?\n              v.getInitialValue().detachFromParent() :\n              null;\n          Node varNode = parent;\n<END_BUG>"
        },
        {
          "start_line": 383,
          "end_line": 383,
          "file": "src/com/google/javascript/jscomp/ScopedAliases.java",
          "code": "<START_BUG>\n            // Replace \"function NAME() { ... }\" with \"var NAME;\".\n<END_BUG>"
        },
        {
          "start_line": 392,
          "end_line": 394,
          "file": "src/com/google/javascript/jscomp/ScopedAliases.java",
          "code": "<START_BUG>\n\n              // If this is a VAR, we can just detach the expression and\n              // the tree will still be valid.\n<END_BUG>"
        },
        {
          "start_line": 408,
          "end_line": 408,
          "file": "src/com/google/javascript/jscomp/ScopedAliases.java",
          "code": "<START_BUG>\n              grandparent.addChildBefore(newDecl, varNode);\n<END_BUG>"
        }
      ],
      "1": [
        {
          "start_line": 554,
          "end_line": 553,
          "file": "src/com/google/javascript/rhino/Node.java",
          "code": "<START_BUG>\n<END_BUG>"
        }
      ]
    },
    "bug_report": {
      "url": "https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1111.json",
      "bug_description": "Allow @private top-level functions in goog.scope",
      "title": ""
    }
  },
  "Closure_167": {
    "buggy_hunks": {
      "0": {
        "start_line": 301,
        "end_line": 302,
        "file": "src/com/google/javascript/jscomp/type/SemanticReverseAbstractInterpreter.java",
        "code": "<START_BUG>\n          left, leftIsRefineable, merged.typeA,\n          right, rightIsRefineable, merged.typeB);\n<END_BUG>"
      },
      "1": {
        "start_line": 348,
        "end_line": 349,
        "file": "src/com/google/javascript/jscomp/type/SemanticReverseAbstractInterpreter.java",
        "code": "<START_BUG>\n          left, leftIsRefineable, restrictedLeftType,\n          right, rightIsRefineable, restrictedRightType);\n<END_BUG>"
      },
      "2": {
        "start_line": 394,
        "end_line": 394,
        "file": "src/com/google/javascript/jscomp/type/SemanticReverseAbstractInterpreter.java",
        "code": "<START_BUG>\n    if (restrictedType != null && !restrictedType.equals(originalType)) {\n<END_BUG>"
      },
      "3": {
        "start_line": 407,
        "end_line": 412,
        "file": "src/com/google/javascript/jscomp/type/SemanticReverseAbstractInterpreter.java",
        "code": "<START_BUG>\n      Node left, boolean leftIsRefineable, JSType restrictedLeftType,\n      Node right, boolean rightIsRefineable, JSType restrictedRightType) {\n    boolean shouldRefineLeft =\n        leftIsRefineable && restrictedLeftType != null;\n    boolean shouldRefineRight =\n        rightIsRefineable && restrictedRightType != null;\n<END_BUG>"
      },
      "4": {
        "start_line": 430,
        "end_line": 434,
        "file": "src/com/google/javascript/jscomp/type/SemanticReverseAbstractInterpreter.java",
        "code": "<START_BUG>\n      JSType restrictedType =\n          type.getRestrictedTypeGivenToBooleanOutcome(outcome);\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, name, restrictedType);\n      return informed;\n<END_BUG>"
      },
      "5": {
        "start_line": 883,
        "end_line": 882,
        "file": "src/com/google/javascript/rhino/jstype/JSType.java",
        "code": "<START_BUG>\n<END_BUG>"
      }
    },
    "buggy_code": {
      "0": {
        "start_line": 272,
        "end_line": 305,
        "file": "src/com/google/javascript/jscomp/type/SemanticReverseAbstractInterpreter.java",
        "code": "private FlowScope caseEquality(Node left, Node right, FlowScope blindScope,\n      Function<TypePair, TypePair> merging) {\n    // left type\n    JSType leftType = getTypeIfRefinable(left, blindScope);\n    boolean leftIsRefineable;\n    if (leftType != null) {\n      leftIsRefineable = true;\n    } else {\n      leftIsRefineable = false;\n      leftType = left.getJSType();\n    }\n\n    // right type\n    JSType rightType = getTypeIfRefinable(right, blindScope);\n    boolean rightIsRefineable;\n    if (rightType != null) {\n      rightIsRefineable = true;\n    } else {\n      rightIsRefineable = false;\n      rightType = right.getJSType();\n    }\n\n    // merged types\n    TypePair merged = merging.apply(new TypePair(leftType, rightType));\n\n    // creating new scope\n    if (merged != null) {\n      return maybeRestrictTwoNames(\n          blindScope,\n          left, leftIsRefineable, merged.typeA,\n          right, rightIsRefineable, merged.typeB);\n    }\n    return blindScope;\n  }",
        "javadoc": ""
      },
      "1": {
        "start_line": 307,
        "end_line": 352,
        "file": "src/com/google/javascript/jscomp/type/SemanticReverseAbstractInterpreter.java",
        "code": "private FlowScope caseAndOrNotShortCircuiting(Node left, Node right,\n        FlowScope blindScope, boolean condition) {\n    // left type\n    JSType leftType = getTypeIfRefinable(left, blindScope);\n    boolean leftIsRefineable;\n    if (leftType != null) {\n      leftIsRefineable = true;\n    } else {\n      leftIsRefineable = false;\n      leftType = left.getJSType();\n      blindScope = firstPreciserScopeKnowingConditionOutcome(\n          left, blindScope, condition);\n    }\n\n    // restricting left type\n    JSType restrictedLeftType = (leftType == null) ? null :\n        leftType.getRestrictedTypeGivenToBooleanOutcome(condition);\n    if (restrictedLeftType == null) {\n      return firstPreciserScopeKnowingConditionOutcome(\n          right, blindScope, condition);\n    }\n\n    // right type\n    JSType rightType = getTypeIfRefinable(right, blindScope);\n    boolean rightIsRefineable;\n    if (rightType != null) {\n      rightIsRefineable = true;\n    } else {\n      rightIsRefineable = false;\n      rightType = right.getJSType();\n      blindScope = firstPreciserScopeKnowingConditionOutcome(\n          right, blindScope, condition);\n    }\n\n    if (condition) {\n      JSType restrictedRightType = (rightType == null) ? null :\n          rightType.getRestrictedTypeGivenToBooleanOutcome(condition);\n\n      // creating new scope\n      return maybeRestrictTwoNames(\n          blindScope,\n          left, leftIsRefineable, restrictedLeftType,\n          right, rightIsRefineable, restrictedRightType);\n    }\n    return blindScope;\n  }",
        "javadoc": ""
      },
      "2": {
        "start_line": 392,
        "end_line": 400,
        "file": "src/com/google/javascript/jscomp/type/SemanticReverseAbstractInterpreter.java",
        "code": "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType) {\n    if (restrictedType != null && !restrictedType.equals(originalType)) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, node, restrictedType);\n      return informed;\n    }\n    return blindScope;\n  }",
        "javadoc": "/**\n * If the restrictedType differs from the originalType, then we should\n * branch the current flow scope and create a new flow scope with the name\n * declared with the new type.\n *\n * We try not to create spurious child flow scopes as this makes type\n * inference slower.\n *\n * We also do not want spurious slots around in type inference, because\n * we use these as a signal for \"checked unknown\" types. A \"checked unknown\"\n * type is a symbol that the programmer has already checked and verified that\n * it's defined, even if we don't know what it is.\n *\n * It is OK to pass non-name nodes into this method, as long as you pass\n * in {@code null} for a restricted type.\n */\n"
      },
      "3": {
        "start_line": 405,
        "end_line": 424,
        "file": "src/com/google/javascript/jscomp/type/SemanticReverseAbstractInterpreter.java",
        "code": "private FlowScope maybeRestrictTwoNames(\n      FlowScope blindScope,\n      Node left, boolean leftIsRefineable, JSType restrictedLeftType,\n      Node right, boolean rightIsRefineable, JSType restrictedRightType) {\n    boolean shouldRefineLeft =\n        leftIsRefineable && restrictedLeftType != null;\n    boolean shouldRefineRight =\n        rightIsRefineable && restrictedRightType != null;\n    if (shouldRefineLeft || shouldRefineRight) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      if (shouldRefineLeft) {\n        declareNameInScope(informed, left, restrictedLeftType);\n      }\n      if (shouldRefineRight) {\n        declareNameInScope(informed, right, restrictedRightType);\n      }\n      return informed;\n    }\n    return blindScope;\n  }",
        "javadoc": "/**\n * @see maybeRestrictName\n */\n"
      },
      "4": {
        "start_line": 426,
        "end_line": 437,
        "file": "src/com/google/javascript/jscomp/type/SemanticReverseAbstractInterpreter.java",
        "code": "private FlowScope caseNameOrGetProp(Node name, FlowScope blindScope,\n      boolean outcome) {\n    JSType type = getTypeIfRefinable(name, blindScope);\n    if (type != null) {\n      JSType restrictedType =\n          type.getRestrictedTypeGivenToBooleanOutcome(outcome);\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, name, restrictedType);\n      return informed;\n    }\n    return blindScope;\n  }",
        "javadoc": ""
      },
      "5": {
        "start_line": 882,
        "end_line": 890,
        "file": "src/com/google/javascript/rhino/jstype/JSType.java",
        "code": "public JSType getRestrictedTypeGivenToBooleanOutcome(boolean outcome) {\n\n    BooleanLiteralSet literals = getPossibleToBooleanOutcomes();\n    if (literals.contains(outcome)) {\n      return this;\n    } else {\n      return getNativeType(JSTypeNative.NO_TYPE);\n    }\n  }",
        "javadoc": "/**\n * Computes the restricted type of this type knowing that the\n * {@code ToBoolean} predicate has a specific value. For more information\n * about the {@code ToBoolean} predicate, see\n * {@link #getPossibleToBooleanOutcomes}.\n *\n * @param outcome the value of the {@code ToBoolean} predicate\n *\n * @return the restricted type, or the Any Type if the underlying type could\n *         not have yielded this ToBoolean value\n *\n * TODO(user): Move this method to the SemanticRAI and use the visit\n * method of types to get the restricted type.\n */\n"
      }
    },
    "delineated_bug": {
      "0": {
        "start_line": 272,
        "end_line": 305,
        "file": "src/com/google/javascript/jscomp/type/SemanticReverseAbstractInterpreter.java",
        "code": "private FlowScope caseEquality(Node left, Node right, FlowScope blindScope,\n      Function<TypePair, TypePair> merging) {\n    // left type\n    JSType leftType = getTypeIfRefinable(left, blindScope);\n    boolean leftIsRefineable;\n    if (leftType != null) {\n      leftIsRefineable = true;\n    } else {\n      leftIsRefineable = false;\n      leftType = left.getJSType();\n    }\n\n    // right type\n    JSType rightType = getTypeIfRefinable(right, blindScope);\n    boolean rightIsRefineable;\n    if (rightType != null) {\n      rightIsRefineable = true;\n    } else {\n      rightIsRefineable = false;\n      rightType = right.getJSType();\n    }\n\n    // merged types\n    TypePair merged = merging.apply(new TypePair(leftType, rightType));\n\n    // creating new scope\n    if (merged != null) {\n      return maybeRestrictTwoNames(\n          blindScope,\n<START_BUG>\n          left, leftIsRefineable, merged.typeA,\n          right, rightIsRefineable, merged.typeB);\n<END_BUG>\n    }\n    return blindScope;\n  }",
        "javadoc": ""
      },
      "1": {
        "start_line": 307,
        "end_line": 352,
        "file": "src/com/google/javascript/jscomp/type/SemanticReverseAbstractInterpreter.java",
        "code": "private FlowScope caseAndOrNotShortCircuiting(Node left, Node right,\n        FlowScope blindScope, boolean condition) {\n    // left type\n    JSType leftType = getTypeIfRefinable(left, blindScope);\n    boolean leftIsRefineable;\n    if (leftType != null) {\n      leftIsRefineable = true;\n    } else {\n      leftIsRefineable = false;\n      leftType = left.getJSType();\n      blindScope = firstPreciserScopeKnowingConditionOutcome(\n          left, blindScope, condition);\n    }\n\n    // restricting left type\n    JSType restrictedLeftType = (leftType == null) ? null :\n        leftType.getRestrictedTypeGivenToBooleanOutcome(condition);\n    if (restrictedLeftType == null) {\n      return firstPreciserScopeKnowingConditionOutcome(\n          right, blindScope, condition);\n    }\n\n    // right type\n    JSType rightType = getTypeIfRefinable(right, blindScope);\n    boolean rightIsRefineable;\n    if (rightType != null) {\n      rightIsRefineable = true;\n    } else {\n      rightIsRefineable = false;\n      rightType = right.getJSType();\n      blindScope = firstPreciserScopeKnowingConditionOutcome(\n          right, blindScope, condition);\n    }\n\n    if (condition) {\n      JSType restrictedRightType = (rightType == null) ? null :\n          rightType.getRestrictedTypeGivenToBooleanOutcome(condition);\n\n      // creating new scope\n      return maybeRestrictTwoNames(\n          blindScope,\n<START_BUG>\n          left, leftIsRefineable, restrictedLeftType,\n          right, rightIsRefineable, restrictedRightType);\n<END_BUG>\n    }\n    return blindScope;\n  }",
        "javadoc": ""
      },
      "2": {
        "start_line": 392,
        "end_line": 400,
        "file": "src/com/google/javascript/jscomp/type/SemanticReverseAbstractInterpreter.java",
        "code": "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType) {\n<START_BUG>\n    if (restrictedType != null && !restrictedType.equals(originalType)) {\n<END_BUG>\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, node, restrictedType);\n      return informed;\n    }\n    return blindScope;\n  }",
        "javadoc": "/**\n * If the restrictedType differs from the originalType, then we should\n * branch the current flow scope and create a new flow scope with the name\n * declared with the new type.\n *\n * We try not to create spurious child flow scopes as this makes type\n * inference slower.\n *\n * We also do not want spurious slots around in type inference, because\n * we use these as a signal for \"checked unknown\" types. A \"checked unknown\"\n * type is a symbol that the programmer has already checked and verified that\n * it's defined, even if we don't know what it is.\n *\n * It is OK to pass non-name nodes into this method, as long as you pass\n * in {@code null} for a restricted type.\n */\n"
      },
      "3": {
        "start_line": 405,
        "end_line": 424,
        "file": "src/com/google/javascript/jscomp/type/SemanticReverseAbstractInterpreter.java",
        "code": "private FlowScope maybeRestrictTwoNames(\n      FlowScope blindScope,\n<START_BUG>\n      Node left, boolean leftIsRefineable, JSType restrictedLeftType,\n      Node right, boolean rightIsRefineable, JSType restrictedRightType) {\n    boolean shouldRefineLeft =\n        leftIsRefineable && restrictedLeftType != null;\n    boolean shouldRefineRight =\n        rightIsRefineable && restrictedRightType != null;\n<END_BUG>\n    if (shouldRefineLeft || shouldRefineRight) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      if (shouldRefineLeft) {\n        declareNameInScope(informed, left, restrictedLeftType);\n      }\n      if (shouldRefineRight) {\n        declareNameInScope(informed, right, restrictedRightType);\n      }\n      return informed;\n    }\n    return blindScope;\n  }",
        "javadoc": "/**\n * @see maybeRestrictName\n */\n"
      },
      "4": {
        "start_line": 426,
        "end_line": 437,
        "file": "src/com/google/javascript/jscomp/type/SemanticReverseAbstractInterpreter.java",
        "code": "private FlowScope caseNameOrGetProp(Node name, FlowScope blindScope,\n      boolean outcome) {\n    JSType type = getTypeIfRefinable(name, blindScope);\n    if (type != null) {\n<START_BUG>\n      JSType restrictedType =\n          type.getRestrictedTypeGivenToBooleanOutcome(outcome);\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, name, restrictedType);\n      return informed;\n<END_BUG>\n    }\n    return blindScope;\n  }",
        "javadoc": ""
      },
      "5": {
        "start_line": 882,
        "end_line": 890,
        "file": "src/com/google/javascript/rhino/jstype/JSType.java",
        "code": "public JSType getRestrictedTypeGivenToBooleanOutcome(boolean outcome) {\n<END_BUG>\n<START_BUG>\n\n    BooleanLiteralSet literals = getPossibleToBooleanOutcomes();\n    if (literals.contains(outcome)) {\n      return this;\n    } else {\n      return getNativeType(JSTypeNative.NO_TYPE);\n    }\n  }",
        "javadoc": "/**\n * Computes the restricted type of this type knowing that the\n * {@code ToBoolean} predicate has a specific value. For more information\n * about the {@code ToBoolean} predicate, see\n * {@link #getPossibleToBooleanOutcomes}.\n *\n * @param outcome the value of the {@code ToBoolean} predicate\n *\n * @return the restricted type, or the Any Type if the underlying type could\n *         not have yielded this ToBoolean value\n *\n * TODO(user): Move this method to the SemanticRAI and use the visit\n * method of types to get the restricted type.\n */\n"
      }
    },
    "contained_scope": "method",
    "bug_count": 6,
    "triggered_tests": {
      "0": {
        "test_path": "com.google.javascript.jscomp.TypeCheckTest",
        "test_method": "testIssue783",
        "test_code": "testIssue783() throws Exception {\n    testTypes(\n        \"/** @constructor */\" +\n        \"var Type = function () {\" +\n        \"  /** @type {Type} */\" +\n        \"  this.me_ = this;\" +\n        \"};\" +\n        \"Type.prototype.doIt = function() {\" +\n        \"  var me = this.me_;\" +\n        \"  for (var i = 0; i < me.unknownProp; i++) {}\" +\n        \"};\",\n        \"Property unknownProp never defined on Type\");\n  }",
        "clean_err_msg": "junit.framework.AssertionFailedError: expected a warning"
      },
      "1": {
        "test_path": "com.google.javascript.jscomp.TypeCheckTest",
        "test_method": "testMissingProperty20",
        "test_code": "testMissingProperty20() throws Exception {\n    testTypes(\n        \"/** @param {Object} x */\" +\n        \"function f(x) { if (x.foo) { } else { x.foo(); } }\",\n        \"Property foo never defined on Object\");\n  }",
        "clean_err_msg": "junit.framework.AssertionFailedError: expected a warning"
      },
      "2": {
        "test_path": "com.google.javascript.rhino.jstype.JSTypeTest",
        "test_method": "testRestrictedTypeGivenToBoolean",
        "test_code": "testRestrictedTypeGivenToBoolean() {\n    // simple cases\n    assertTypeEquals(BOOLEAN_TYPE,\n        BOOLEAN_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));\n    assertTypeEquals(BOOLEAN_TYPE,\n        BOOLEAN_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));\n\n    assertTypeEquals(NO_TYPE,\n        NULL_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));\n    assertTypeEquals(NULL_TYPE,\n        NULL_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));\n\n    assertTypeEquals(NUMBER_TYPE,\n        NUMBER_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));\n    assertTypeEquals(NUMBER_TYPE,\n        NUMBER_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));\n\n    assertTypeEquals(STRING_TYPE,\n        STRING_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));\n    assertTypeEquals(STRING_TYPE,\n        STRING_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));\n\n    assertTypeEquals(STRING_OBJECT_TYPE,\n        STRING_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));\n    assertTypeEquals(NO_TYPE,\n        STRING_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));\n\n    assertTypeEquals(NO_TYPE,\n        VOID_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));\n    assertTypeEquals(VOID_TYPE,\n        VOID_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));\n\n    assertTypeEquals(NO_OBJECT_TYPE,\n        NO_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));\n    assertTypeEquals(NO_TYPE,\n        NO_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));\n\n    assertTypeEquals(NO_TYPE,\n        NO_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));\n    assertTypeEquals(NO_TYPE,\n        NO_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));\n\n    assertTypeEquals(ALL_TYPE,\n        ALL_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));\n    assertTypeEquals(ALL_TYPE,\n        ALL_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));\n\n    assertTypeEquals(CHECKED_UNKNOWN_TYPE,\n        UNKNOWN_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));\n    assertTypeEquals(UNKNOWN_TYPE,\n        UNKNOWN_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));\n\n    // unions\n    UnionType nullableStringValue =\n        (UnionType) createNullableType(STRING_TYPE);\n    assertTypeEquals(STRING_TYPE,\n        nullableStringValue.getRestrictedTypeGivenToBooleanOutcome(true));\n    assertTypeEquals(nullableStringValue,\n        nullableStringValue.getRestrictedTypeGivenToBooleanOutcome(false));\n\n    UnionType nullableStringObject =\n        (UnionType) createNullableType(STRING_OBJECT_TYPE);\n    assertTypeEquals(STRING_OBJECT_TYPE,\n        nullableStringObject.getRestrictedTypeGivenToBooleanOutcome(true));\n    assertTypeEquals(NULL_TYPE,\n        nullableStringObject.getRestrictedTypeGivenToBooleanOutcome(false));\n  }",
        "clean_err_msg": "junit.framework.AssertionFailedError: Expected: ??"
      }
    },
    "buggy_files": {
      "0": "src/com/google/javascript/jscomp/type/SemanticReverseAbstractInterpreter.java",
      "1": "src/com/google/javascript/rhino/jstype/JSType.java"
    },
    "hunk_type": "multi_file_four_or_more_hunks",
    "hunk_mapping": {
      "0": [
        {
          "start_line": 301,
          "end_line": 302,
          "file": "src/com/google/javascript/jscomp/type/SemanticReverseAbstractInterpreter.java",
          "code": "<START_BUG>\n          left, leftIsRefineable, merged.typeA,\n          right, rightIsRefineable, merged.typeB);\n<END_BUG>"
        }
      ],
      "1": [
        {
          "start_line": 348,
          "end_line": 349,
          "file": "src/com/google/javascript/jscomp/type/SemanticReverseAbstractInterpreter.java",
          "code": "<START_BUG>\n          left, leftIsRefineable, restrictedLeftType,\n          right, rightIsRefineable, restrictedRightType);\n<END_BUG>"
        }
      ],
      "2": [
        {
          "start_line": 394,
          "end_line": 394,
          "file": "src/com/google/javascript/jscomp/type/SemanticReverseAbstractInterpreter.java",
          "code": "<START_BUG>\n    if (restrictedType != null && !restrictedType.equals(originalType)) {\n<END_BUG>"
        }
      ],
      "3": [
        {
          "start_line": 407,
          "end_line": 412,
          "file": "src/com/google/javascript/jscomp/type/SemanticReverseAbstractInterpreter.java",
          "code": "<START_BUG>\n      Node left, boolean leftIsRefineable, JSType restrictedLeftType,\n      Node right, boolean rightIsRefineable, JSType restrictedRightType) {\n    boolean shouldRefineLeft =\n        leftIsRefineable && restrictedLeftType != null;\n    boolean shouldRefineRight =\n        rightIsRefineable && restrictedRightType != null;\n<END_BUG>"
        }
      ],
      "4": [
        {
          "start_line": 430,
          "end_line": 434,
          "file": "src/com/google/javascript/jscomp/type/SemanticReverseAbstractInterpreter.java",
          "code": "<START_BUG>\n      JSType restrictedType =\n          type.getRestrictedTypeGivenToBooleanOutcome(outcome);\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, name, restrictedType);\n      return informed;\n<END_BUG>"
        }
      ],
      "5": [
        {
          "start_line": 883,
          "end_line": 882,
          "file": "src/com/google/javascript/rhino/jstype/JSType.java",
          "code": "<START_BUG>\n<END_BUG>"
        }
      ]
    },
    "bug_report": {
      "url": "https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-783.json",
      "bug_description": "invalid property not erroring in for loop in prototype function",
      "title": ""
    }
  },
  "Closure_47": {
    "buggy_hunks": {
      "0": {
        "start_line": 489,
        "end_line": 490,
        "file": "src/com/google/debugging/sourcemap/SourceMapConsumerV3.java",
        "code": "<START_BUG>\n        .setLineNumber(entry.getSourceLine())\n        .setColumnPosition(entry.getSourceColumn());\n<END_BUG>"
      },
      "1": {
        "start_line": 138,
        "end_line": 141,
        "file": "src/com/google/javascript/jscomp/SourceMap.java",
        "code": "<START_BUG>\n\n    generator.addMapping(\n        sourceFile, originalName,\n        new FilePosition(node.getLineno(), node.getCharno()),\n<END_BUG>"
      }
    },
    "buggy_code": {
      "0": {
        "start_line": 482,
        "end_line": 496,
        "file": "src/com/google/debugging/sourcemap/SourceMapConsumerV3.java",
        "code": "private OriginalMapping getOriginalMappingForEntry(Entry entry) {\n    if (entry.getSourceFileId() == UNMAPPED) {\n      return null;\n    } else {\n      // Adjust the line/column here to be start at 1.\n      Builder x = OriginalMapping.newBuilder()\n        .setOriginalFile(sources[entry.getSourceFileId()])\n        .setLineNumber(entry.getSourceLine())\n        .setColumnPosition(entry.getSourceColumn());\n      if (entry.getNameId() != UNMAPPED) {\n        x.setIdentifier(names[entry.getNameId()]);\n      }\n      return x.build();\n    }\n  }",
        "javadoc": "/**\n * Creates an \"OriginalMapping\" object for the given entry object.\n */\n"
      },
      "1": {
        "start_line": 117,
        "end_line": 143,
        "file": "src/com/google/javascript/jscomp/SourceMap.java",
        "code": "public void addMapping(\n      Node node,\n      FilePosition outputStartPosition,\n      FilePosition outputEndPosition) {\n    String sourceFile = node.getSourceFileName();\n\n    // If the node does not have an associated source file or\n    // its line number is -1, then the node does not have sufficient\n    // information for a mapping to be useful.\n    if (sourceFile == null || node.getLineno() < 0) {\n      return;\n    }\n\n    sourceFile = fixupSourceLocation(sourceFile);\n\n    String originalName = (String) node.getProp(Node.ORIGINALNAME_PROP);\n\n    // Strangely, Rhino source lines are one based but columns are\n    // zero based.\n    // We don't change this for the v1 or v2 source maps but for\n    // v3 we make them both 0 based.\n\n    generator.addMapping(\n        sourceFile, originalName,\n        new FilePosition(node.getLineno(), node.getCharno()),\n        outputStartPosition, outputEndPosition);\n  }",
        "javadoc": ""
      }
    },
    "delineated_bug": {
      "0": {
        "start_line": 482,
        "end_line": 496,
        "file": "src/com/google/debugging/sourcemap/SourceMapConsumerV3.java",
        "code": "private OriginalMapping getOriginalMappingForEntry(Entry entry) {\n    if (entry.getSourceFileId() == UNMAPPED) {\n      return null;\n    } else {\n      // Adjust the line/column here to be start at 1.\n      Builder x = OriginalMapping.newBuilder()\n        .setOriginalFile(sources[entry.getSourceFileId()])\n<START_BUG>\n        .setLineNumber(entry.getSourceLine())\n        .setColumnPosition(entry.getSourceColumn());\n<END_BUG>\n      if (entry.getNameId() != UNMAPPED) {\n        x.setIdentifier(names[entry.getNameId()]);\n      }\n      return x.build();\n    }\n  }",
        "javadoc": "/**\n * Creates an \"OriginalMapping\" object for the given entry object.\n */\n"
      },
      "1": {
        "start_line": 117,
        "end_line": 143,
        "file": "src/com/google/javascript/jscomp/SourceMap.java",
        "code": "public void addMapping(\n      Node node,\n      FilePosition outputStartPosition,\n      FilePosition outputEndPosition) {\n    String sourceFile = node.getSourceFileName();\n\n    // If the node does not have an associated source file or\n    // its line number is -1, then the node does not have sufficient\n    // information for a mapping to be useful.\n    if (sourceFile == null || node.getLineno() < 0) {\n      return;\n    }\n\n    sourceFile = fixupSourceLocation(sourceFile);\n\n    String originalName = (String) node.getProp(Node.ORIGINALNAME_PROP);\n\n    // Strangely, Rhino source lines are one based but columns are\n    // zero based.\n    // We don't change this for the v1 or v2 source maps but for\n    // v3 we make them both 0 based.\n<START_BUG>\n\n    generator.addMapping(\n        sourceFile, originalName,\n        new FilePosition(node.getLineno(), node.getCharno()),\n<END_BUG>\n        outputStartPosition, outputEndPosition);\n  }",
        "javadoc": ""
      }
    },
    "contained_scope": "method",
    "bug_count": 2,
    "triggered_tests": {
      "0": {
        "test_path": "com.google.debugging.sourcemap.SourceMapGeneratorV3Test",
        "test_method": "testParseSourceMetaMap",
        "test_code": "testParseSourceMetaMap() throws Exception {\n    final String INPUT1 = \"file1\";\n    final String INPUT2 = \"file2\";\n    LinkedHashMap<String, String> inputs = Maps.newLinkedHashMap();\n    inputs.put(INPUT1, \"var __FOO__ = 1;\");\n    inputs.put(INPUT2, \"var __BAR__ = 2;\");\n    RunResult result1 = compile(inputs.get(INPUT1), INPUT1);\n    RunResult result2 = compile(inputs.get(INPUT2), INPUT2);\n\n    final String MAP1 = \"map1\";\n    final String MAP2 = \"map2\";\n    final LinkedHashMap<String, String> maps = Maps.newLinkedHashMap();\n    maps.put(MAP1, result1.sourceMapFileContent);\n    maps.put(MAP2, result2.sourceMapFileContent);\n\n    List<SourceMapSection> sections = Lists.newArrayList();\n\n    StringBuilder output = new StringBuilder();\n    FilePosition offset = appendAndCount(output, result1.generatedSource);\n    sections.add(SourceMapSection.forURL(MAP1, 0, 0));\n    output.append(result2.generatedSource);\n    sections.add(\n        SourceMapSection.forURL(MAP2, offset.getLine(), offset.getColumn()));\n\n    SourceMapGeneratorV3 generator = new SourceMapGeneratorV3();\n    StringBuilder mapContents = new StringBuilder();\n    generator.appendIndexMapTo(mapContents, \"out.js\", sections);\n\n    check(inputs, output.toString(), mapContents.toString(),\n      new SourceMapSupplier() {\n        @Override\n        public String getSourceMap(String url){\n          return maps.get(url);\n      }});\n  }",
        "clean_err_msg": "junit.framework.AssertionFailedError: expected:<5> but was:<4>"
      },
      "1": {
        "test_path": "com.google.debugging.sourcemap.SourceMapGeneratorV3Test",
        "test_method": "testGoldenOutput0a",
        "test_code": "testGoldenOutput0a() throws Exception {\n    // Empty source map test\n    checkSourceMap(\"a;\",\n\n                   \"{\\n\" +\n                   \"\\\"version\\\":3,\\n\" +\n                   \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n                   \"\\\"lineCount\\\":1,\\n\" +\n                   \"\\\"mappings\\\":\\\"AAAAA;\\\",\\n\" +\n                   \"\\\"sources\\\":[\\\"testcode\\\"],\\n\" +\n                   \"\\\"names\\\":[\\\"a\\\"]\\n\" +\n                   \"}\\n\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<...t\":1,"
      },
      "2": {
        "test_path": "com.google.debugging.sourcemap.SourceMapGeneratorV3Test",
        "test_method": "testMultilineMapping",
        "test_code": "testMultilineMapping() throws Exception {\n    compileAndCheck(\"function __BASIC__(__PARAM1__, __PARAM2__) {\\n\" +\n                    \"var __VAR__ = '__STR__';\\n\" +\n                    \"var __ANO__ = \\\"__STR2__\\\";\\n\" +\n                    \"}\");\n  }",
        "clean_err_msg": "junit.framework.AssertionFailedError: expected:<10> but was:<9>"
      },
      "3": {
        "test_path": "com.google.debugging.sourcemap.SourceMapGeneratorV3Test",
        "test_method": "testMultiFunctionMapping",
        "test_code": "testMultiFunctionMapping() throws Exception {\n    compileAndCheck(\"function __BASIC__(__PARAM1__, __PARAM2__) {\\n\" +\n                    \"var __VAR__ = '__STR__';\\n\" +\n                    \"var __ANO__ = \\\"__STR2__\\\";\\n\" +\n                    \"}\\n\" +\n\n                    \"function __BASIC2__(__PARAM3__, __PARAM4__) {\\n\" +\n                    \"var __VAR2__ = '__STR2__';\\n\" +\n                    \"var __ANO2__ = \\\"__STR3__\\\";\\n\" +\n                    \"}\\n\");\n  }",
        "clean_err_msg": "junit.framework.AssertionFailedError: expected:<10> but was:<9>"
      },
      "4": {
        "test_path": "com.google.debugging.sourcemap.SourceMapGeneratorV3Test",
        "test_method": "testLiteralMappingsGoldenOutput",
        "test_code": "testLiteralMappingsGoldenOutput() throws Exception {\n    // Empty source map test\n    checkSourceMap(\"function __BASIC__(__PARAM1__, __PARAM2__) { \" +\n                   \"var __VAR__ = '__STR__'; }\",\n\n                   \"{\\n\" +\n                   \"\\\"version\\\":3,\\n\" +\n                   \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n                   \"\\\"lineCount\\\":1,\\n\" +\n                   \"\\\"mappings\\\":\\\"AAAAA,QAASA,UAAS,CAACC,UAAD,CAAaC,UAAb,\" +\n                       \"CAAyB,CAAE,IAAIC,QAAU,SAAhB;\\\",\\n\" +\n                   \"\\\"sources\\\":[\\\"testcode\\\"],\\n\" +\n                   \"\\\"names\\\":[\\\"__BASIC__\\\",\\\"__PARAM1__\\\",\\\"__PARAM2__\\\",\" +\n                       \"\\\"__VAR__\\\"]\\n\" +\n                   \"}\\n\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<...t\":1,"
      },
      "5": {
        "test_path": "com.google.debugging.sourcemap.SourceMapGeneratorV3Test",
        "test_method": "testMultilineMapping2",
        "test_code": "testMultilineMapping2() throws Exception {\n    compileAndCheck(\"function __BASIC__(__PARAM1__, __PARAM2__) {\\n\" +\n                    \"var __VAR__ = 1;\\n\" +\n                    \"var __ANO__ = 2;\\n\" +\n                    \"}\");\n  }",
        "clean_err_msg": "junit.framework.AssertionFailedError: expected:<10> but was:<9>"
      },
      "6": {
        "test_path": "com.google.debugging.sourcemap.SourceMapGeneratorV3Test",
        "test_method": "testBasicMappingGoldenOutput",
        "test_code": "testBasicMappingGoldenOutput() throws Exception {\n    // Empty source map test\n    checkSourceMap(\"function __BASIC__() { }\",\n\n                   \"{\\n\" +\n                   \"\\\"version\\\":3,\\n\" +\n                   \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n                   \"\\\"lineCount\\\":1,\\n\" +\n                   \"\\\"mappings\\\":\\\"AAAAA,QAASA,UAAS,EAAG;\\\",\\n\" +\n                   \"\\\"sources\\\":[\\\"testcode\\\"],\\n\" +\n                   \"\\\"names\\\":[\\\"__BASIC__\\\"]\\n\" +\n                   \"}\\n\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<...t\":1,"
      },
      "7": {
        "test_path": "com.google.debugging.sourcemap.SourceMapGeneratorV3Test",
        "test_method": "testSourceMapMerging",
        "test_code": "testSourceMapMerging() throws Exception {\n    final String INPUT1 = \"file1\";\n    final String INPUT2 = \"file2\";\n    LinkedHashMap<String, String> inputs = Maps.newLinkedHashMap();\n    inputs.put(INPUT1, \"var __FOO__ = 1;\");\n    inputs.put(INPUT2, \"var __BAR__ = 2;\");\n    RunResult result1 = compile(inputs.get(INPUT1), INPUT1);\n    RunResult result2 = compile(inputs.get(INPUT2), INPUT2);\n\n    StringBuilder output = new StringBuilder();\n    FilePosition offset = appendAndCount(output, result1.generatedSource);\n    output.append(result2.generatedSource);\n\n    SourceMapGeneratorV3 generator = new SourceMapGeneratorV3();\n\n    generator.mergeMapSection(0, 0, result1.sourceMapFileContent);\n    generator.mergeMapSection(offset.getLine(), offset.getColumn(),\n        result2.sourceMapFileContent);\n\n    StringBuilder mapContents = new StringBuilder();\n    generator.appendTo(mapContents, \"out.js\");\n\n    check(inputs, output.toString(), mapContents.toString());\n  }",
        "clean_err_msg": "junit.framework.AssertionFailedError: expected:<5> but was:<4>"
      },
      "8": {
        "test_path": "com.google.debugging.sourcemap.SourceMapGeneratorV3Test",
        "test_method": "testLiteralMappings",
        "test_code": "testLiteralMappings() throws Exception {\n    compileAndCheck(\"function __BASIC__(__PARAM1__, __PARAM2__) { \" +\n                    \"var __VAR__ = '__STR__'; }\");\n  }",
        "clean_err_msg": "junit.framework.AssertionFailedError: expected:<10> but was:<9>"
      },
      "9": {
        "test_path": "com.google.debugging.sourcemap.SourceMapGeneratorV3Test",
        "test_method": "testBasicMapping1",
        "test_code": "testBasicMapping1() throws Exception {\n    compileAndCheck(\"function __BASIC__() { }\");\n  }",
        "clean_err_msg": "junit.framework.AssertionFailedError: expected:<10> but was:<9>"
      },
      "10": {
        "test_path": "com.google.debugging.sourcemap.SourceMapGeneratorV3Test",
        "test_method": "testBasicMapping2",
        "test_code": "testBasicMapping2() throws Exception {\n    compileAndCheck(\"function __BASIC__(__PARAM1__) {}\");\n  }",
        "clean_err_msg": "junit.framework.AssertionFailedError: expected:<10> but was:<9>"
      },
      "11": {
        "test_path": "com.google.debugging.sourcemap.SourceMapGeneratorV3Test",
        "test_method": "testGoldenOutput1",
        "test_code": "testGoldenOutput1() throws Exception {\n    detailLevel = SourceMap.DetailLevel.ALL;\n\n    checkSourceMap(\"function f(foo, bar) { foo = foo + bar + 2; return foo; }\",\n\n                   \"{\\n\" +\n                   \"\\\"version\\\":3,\\n\" +\n                   \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n                   \"\\\"lineCount\\\":1,\\n\" +\n                   \"\\\"mappings\\\":\\\"AAAAA,QAASA,EAAC,CAACC,GAAD,CAAMC,GAAN,\" +\n                       \"CAAW,CAAED,GAAA,CAAMA,GAAN,CAAYC,GAAZ,CAAkB,CAAG,\" +\n                       \"OAAOD,IAA9B;\\\",\\n\" +\n                   \"\\\"sources\\\":[\\\"testcode\\\"],\\n\" +\n                   \"\\\"names\\\":[\\\"f\\\",\\\"foo\\\",\\\"bar\\\"]\\n\" +\n                   \"}\\n\");\n\n    detailLevel = SourceMap.DetailLevel.SYMBOLS;\n\n    checkSourceMap(\"function f(foo, bar) { foo = foo + bar + 2; return foo; }\",\n\n                   \"{\\n\" +\n                   \"\\\"version\\\":3,\\n\" +\n                   \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n                   \"\\\"lineCount\\\":1,\\n\" +\n                   \"\\\"mappings\\\":\\\"AAAAA,QAASA,EAATA,CAAWC,GAAXD,CAAgBE,\" +\n                       \"GAAhBF,EAAuBC,GAAvBD,CAA6BC,GAA7BD,CAAmCE,GAAnCF,\" +\n                       \"SAAmDC,IAAnDD;\\\",\\n\" +\n                   \"\\\"sources\\\":[\\\"testcode\\\"],\\n\" +\n                   \"\\\"names\\\":[\\\"f\\\",\\\"foo\\\",\\\"bar\\\"]\\n\" +\n                   \"}\\n\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<...t\":1,"
      },
      "12": {
        "test_path": "com.google.debugging.sourcemap.SourceMapGeneratorV3Test",
        "test_method": "testGoldenOutput2",
        "test_code": "testGoldenOutput2() throws Exception {\n    checkSourceMap(\"function f(foo, bar) {\\r\\n\\n\\n\\nfoo = foo + bar + foo;\" +\n                   \"\\nreturn foo;\\n}\",\n\n                   \"{\\n\" +\n                   \"\\\"version\\\":3,\\n\" +\n                   \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n                   \"\\\"lineCount\\\":1,\\n\" +\n                   \"\\\"mappings\\\":\\\"AAAAA,QAASA,EAAC,CAACC,GAAD,CAAMC,GAAN,\" +\n                       \"CAAW,CAIrBD,GAAA,CAAMA,GAAN,CAAYC,GAAZ,CAAkBD,\" +\n                       \"GAClB,OAAOA,IALc;\\\",\\n\" +\n                   \"\\\"sources\\\":[\\\"testcode\\\"],\\n\" +\n                   \"\\\"names\\\":[\\\"f\\\",\\\"foo\\\",\\\"bar\\\"]\\n\" +\n                   \"}\\n\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<...t\":1,"
      },
      "13": {
        "test_path": "com.google.debugging.sourcemap.SourceMapGeneratorV3Test",
        "test_method": "testGoldenOutput3",
        "test_code": "testGoldenOutput3() throws Exception {\n    checkSourceMap(\"c:\\\\myfile.js\",\n                   \"foo;\",\n\n                   \"{\\n\" +\n                   \"\\\"version\\\":3,\\n\" +\n                   \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n                   \"\\\"lineCount\\\":1,\\n\" +\n                   \"\\\"mappings\\\":\\\"AAAAA;\\\",\\n\" +\n                   \"\\\"sources\\\":[\\\"c:\\\\\\\\myfile.js\\\"],\\n\" +\n                   \"\\\"names\\\":[\\\"foo\\\"]\\n\" +\n                   \"}\\n\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<...t\":1,"
      },
      "14": {
        "test_path": "com.google.debugging.sourcemap.SourceMapGeneratorV3Test",
        "test_method": "testGoldenOutput4",
        "test_code": "testGoldenOutput4() throws Exception {\n    checkSourceMap(\"c:\\\\myfile.js\",\n                   \"foo;   boo;   goo;\",\n\n                   \"{\\n\" +\n                   \"\\\"version\\\":3,\\n\" +\n                   \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n                   \"\\\"lineCount\\\":1,\\n\" +\n                   \"\\\"mappings\\\":\\\"AAAAA,GAAOC,IAAOC;\\\",\\n\" +\n                   \"\\\"sources\\\":[\\\"c:\\\\\\\\myfile.js\\\"],\\n\" +\n                   \"\\\"names\\\":[\\\"foo\\\",\\\"boo\\\",\\\"goo\\\"]\\n\" +\n                   \"}\\n\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<...t\":1,"
      },
      "15": {
        "test_path": "com.google.debugging.sourcemap.SourceMapGeneratorV3Test",
        "test_method": "testGoldenOutput5",
        "test_code": "testGoldenOutput5() throws Exception {\n    detailLevel = SourceMap.DetailLevel.ALL;\n\n    checkSourceMap(\n        \"c:\\\\myfile.js\",\n        \"/** @preserve\\n\" +\n        \" * this is a test.\\n\" +\n        \" */\\n\" +\n        \"var foo=a + 'this is a really long line that will force the\"\n        + \" mapping to span multiple lines 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \"' + c + d + e;\",\n\n        \"{\\n\" +\n        \"\\\"version\\\":3,\\n\" +\n        \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n        \"\\\"lineCount\\\":6,\\n\" +\n        \"\\\"mappings\\\":\\\"A;;;;AAGA,IAAIA,IAAIC,CAAJD,CAAQ,mxCAARA;AAA8xCE,\" +\n            \"CAA9xCF,CAAkyCG,CAAlyCH,CAAsyCI;\\\",\\n\" +\n        \"\\\"sources\\\":[\\\"c:\\\\\\\\myfile.js\\\"],\\n\" +\n        \"\\\"names\\\":[\\\"foo\\\",\\\"a\\\",\\\"c\\\",\\\"d\\\",\\\"e\\\"]\\n\" +\n        \"}\\n\");\n\n    detailLevel = SourceMap.DetailLevel.SYMBOLS;\n\n    checkSourceMap(\"c:\\\\myfile.js\",\n        \"/** @preserve\\n\" +\n        \" * this is a test.\\n\" +\n        \" */\\n\" +\n        \"var foo=a + 'this is a really long line that will force the\"\n        + \" mapping to span multiple lines 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \"' + c + d + e;\",\n\n        \"{\\n\" +\n        \"\\\"version\\\":3,\\n\" +\n        \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n        \"\\\"lineCount\\\":6,\\n\" +\n        \"\\\"mappings\\\":\\\"A;;;;IAGIA,IAAIC,CAAJD;AAA8xCE,CAA9xCF,CAAkyCG,\" +\n            \"CAAlyCH,CAAsyCI;\\\",\\n\" +\n        \"\\\"sources\\\":[\\\"c:\\\\\\\\myfile.js\\\"],\\n\" +\n        \"\\\"names\\\":[\\\"foo\\\",\\\"a\\\",\\\"c\\\",\\\"d\\\",\\\"e\\\"]\\n\" +\n        \"}\\n\");\n  }",
        "clean_err_msg": "junit.framework.ComparisonFailure: expected:<..."
      }
    },
    "buggy_files": {
      "0": "src/com/google/debugging/sourcemap/SourceMapConsumerV3.java",
      "1": "src/com/google/javascript/jscomp/SourceMap.java"
    },
    "hunk_type": "multi_file_two_hunks",
    "hunk_mapping": {
      "0": [
        {
          "start_line": 489,
          "end_line": 490,
          "file": "src/com/google/debugging/sourcemap/SourceMapConsumerV3.java",
          "code": "<START_BUG>\n        .setLineNumber(entry.getSourceLine())\n        .setColumnPosition(entry.getSourceColumn());\n<END_BUG>"
        }
      ],
      "1": [
        {
          "start_line": 138,
          "end_line": 141,
          "file": "src/com/google/javascript/jscomp/SourceMap.java",
          "code": "<START_BUG>\n\n    generator.addMapping(\n        sourceFile, originalName,\n        new FilePosition(node.getLineno(), node.getCharno()),\n<END_BUG>"
        }
      ]
    },
    "bug_report": {
      "url": "https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-575.json",
      "bug_description": "Original source line numbers are one-based in source maps.",
      "title": ""
    }
  },
  "Mockito_16": {
    "buggy_hunks": {
      "0": {
        "start_line": 32,
        "end_line": 35,
        "file": "src/org/mockito/internal/MockitoCore.java",
        "code": "<START_BUG>\n    public <T> T mock(Class<T> classToMock, MockSettings mockSettings, boolean shouldResetOngoingStubbing) { return mock(classToMock, mockSettings); }\n    public <T> T mock(Class<T> classToMock, MockSettings mockSettings) {\n        mockingProgress.validateState();\n            mockingProgress.resetOngoingStubbing();\n<END_BUG>"
      },
      "1": {
        "start_line": 827,
        "end_line": 827,
        "file": "src/org/mockito/Mockito.java",
        "code": "<START_BUG>\n        return MOCKITO_CORE.mock(classToMock, mockSettings);\n<END_BUG>"
      },
      "2": {
        "start_line": 899,
        "end_line": 899,
        "file": "src/org/mockito/Mockito.java",
        "code": "<START_BUG>\n                .defaultAnswer(CALLS_REAL_METHODS)); \n<END_BUG>"
      }
    },
    "buggy_code": {
      "0": {
        "start_line": 32,
        "end_line": 37,
        "file": "src/org/mockito/internal/MockitoCore.java",
        "code": "public <T> T mock(Class<T> classToMock, MockSettings mockSettings, boolean shouldResetOngoingStubbing) { return mock(classToMock, mockSettings); }\n    public <T> T mock(Class<T> classToMock, MockSettings mockSettings) {\n        mockingProgress.validateState();\n            mockingProgress.resetOngoingStubbing();\n        return mockUtil.createMock(classToMock, (MockSettingsImpl) mockSettings);\n    }",
        "javadoc": ""
      },
      "1": {
        "start_line": 826,
        "end_line": 828,
        "file": "src/org/mockito/Mockito.java",
        "code": "public static <T> T mock(Class<T> classToMock, MockSettings mockSettings) {\n        return MOCKITO_CORE.mock(classToMock, mockSettings);\n    }",
        "javadoc": "/**\n * Creates a mock with some non-standard settings.\n * <p>\n * The number of configuration points for a mock grows\n * so we need a fluent way to introduce new configuration without adding more and more overloaded Mockito.mock() methods.\n * Hence {@link MockSettings}.\n * <pre>\n *   Listener mock = mock(Listener.class, withSettings()\n *     .name(\"firstListner\").defaultBehavior(RETURNS_SMART_NULLS));\n *   );\n * </pre>\n * <b>Use it carefully and occasionally</b>. What might be reason your test needs non-standard mocks?\n * Is the code under test so complicated that it requires non-standard mocks?\n * Wouldn't you prefer to refactor the code under test so it is testable in a simple way?\n * <p>\n * See also {@link Mockito#withSettings()}\n * <p>\n * See examples in javadoc for {@link Mockito} class\n *\n * @param classToMock class or interface to mock\n * @param mockSettings additional mock settings\n * @return mock object\n */\n"
      },
      "2": {
        "start_line": 896,
        "end_line": 900,
        "file": "src/org/mockito/Mockito.java",
        "code": "public static <T> T spy(T object) {\n        return MOCKITO_CORE.mock((Class<T>) object.getClass(), withSettings()\n                .spiedInstance(object)\n                .defaultAnswer(CALLS_REAL_METHODS)); \n    }",
        "javadoc": "/**\n * Creates a spy of the real object. The spy calls <b>real</b> methods unless they are stubbed.\n * <p>\n * Real spies should be used <b>carefully and occasionally</b>, for example when dealing with legacy code.\n * <p>\n * As usual you are going to read <b>the partial mock warning</b>:\n * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.\n * How does partial mock fit into this paradigm? Well, it just doesn't...\n * Partial mock usually means that the complexity has been moved to a different method on the same object.\n * In most cases, this is not the way you want to design your application.\n * <p>\n * However, there are rare cases when partial mocks come handy:\n * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)\n * However, I wouldn't use partial mocks for new, test-driven & well-designed code.\n * <p>\n * Example:\n *\n * <pre>\n *   List list = new LinkedList();\n *   List spy = spy(list);\n *\n *   //optionally, you can stub out some methods:\n *   when(spy.size()).thenReturn(100);\n *\n *   //using the spy calls <b>real</b> methods\n *   spy.add(\"one\");\n *   spy.add(\"two\");\n *\n *   //prints \"one\" - the first element of a list\n *   System.out.println(spy.get(0));\n *\n *   //size() method was stubbed - 100 is printed\n *   System.out.println(spy.size());\n *\n *   //optionally, you can verify\n *   verify(spy).add(\"one\");\n *   verify(spy).add(\"two\");\n * </pre>\n *\n * <h4>Important gotcha on spying real objects!</h4>\n *\n * 1. Sometimes it's impossible to use {@link Mockito#when(Object)} for stubbing spies. Example:\n *\n * <pre>\n *   List list = new LinkedList();\n *   List spy = spy(list);\n *\n *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)\n *   when(spy.get(0)).thenReturn(\"foo\");\n *\n *   //You have to use doReturn() for stubbing\n *   doReturn(\"foo\").when(spy).get(0);\n * </pre>\n *\n * 2. Watch out for final methods.\n * Mockito doesn't mock final methods so the bottom line is: when you spy on real objects + you try to stub a final method = trouble.\n * What will happen is the real method will be called *on mock* but *not on the real instance* you passed to the spy() method.\n * Typically you may get a NullPointerException because mock instances don't have fields initiated.\n *\n * <p>\n * See examples in javadoc for {@link Mockito} class\n *\n * @param object\n *            to spy on\n * @return a spy of the real object\n */\n"
      }
    },
    "delineated_bug": {
      "0": {
        "start_line": 32,
        "end_line": 37,
        "file": "src/org/mockito/internal/MockitoCore.java",
        "code": "<START_BUG>\npublic <T> T mock(Class<T> classToMock, MockSettings mockSettings, boolean shouldResetOngoingStubbing) { return mock(classToMock, mockSettings); }\n    public <T> T mock(Class<T> classToMock, MockSettings mockSettings) {\n        mockingProgress.validateState();\n            mockingProgress.resetOngoingStubbing();\n<END_BUG>\n        return mockUtil.createMock(classToMock, (MockSettingsImpl) mockSettings);\n    }",
        "javadoc": ""
      },
      "1": {
        "start_line": 826,
        "end_line": 828,
        "file": "src/org/mockito/Mockito.java",
        "code": "public static <T> T mock(Class<T> classToMock, MockSettings mockSettings) {\n<START_BUG>\n        return MOCKITO_CORE.mock(classToMock, mockSettings);\n<END_BUG>\n    }",
        "javadoc": "/**\n * Creates a mock with some non-standard settings.\n * <p>\n * The number of configuration points for a mock grows\n * so we need a fluent way to introduce new configuration without adding more and more overloaded Mockito.mock() methods.\n * Hence {@link MockSettings}.\n * <pre>\n *   Listener mock = mock(Listener.class, withSettings()\n *     .name(\"firstListner\").defaultBehavior(RETURNS_SMART_NULLS));\n *   );\n * </pre>\n * <b>Use it carefully and occasionally</b>. What might be reason your test needs non-standard mocks?\n * Is the code under test so complicated that it requires non-standard mocks?\n * Wouldn't you prefer to refactor the code under test so it is testable in a simple way?\n * <p>\n * See also {@link Mockito#withSettings()}\n * <p>\n * See examples in javadoc for {@link Mockito} class\n *\n * @param classToMock class or interface to mock\n * @param mockSettings additional mock settings\n * @return mock object\n */\n"
      },
      "2": {
        "start_line": 896,
        "end_line": 900,
        "file": "src/org/mockito/Mockito.java",
        "code": "public static <T> T spy(T object) {\n        return MOCKITO_CORE.mock((Class<T>) object.getClass(), withSettings()\n                .spiedInstance(object)\n<START_BUG>\n                .defaultAnswer(CALLS_REAL_METHODS)); \n<END_BUG>\n    }",
        "javadoc": "/**\n * Creates a spy of the real object. The spy calls <b>real</b> methods unless they are stubbed.\n * <p>\n * Real spies should be used <b>carefully and occasionally</b>, for example when dealing with legacy code.\n * <p>\n * As usual you are going to read <b>the partial mock warning</b>:\n * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.\n * How does partial mock fit into this paradigm? Well, it just doesn't...\n * Partial mock usually means that the complexity has been moved to a different method on the same object.\n * In most cases, this is not the way you want to design your application.\n * <p>\n * However, there are rare cases when partial mocks come handy:\n * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)\n * However, I wouldn't use partial mocks for new, test-driven & well-designed code.\n * <p>\n * Example:\n *\n * <pre>\n *   List list = new LinkedList();\n *   List spy = spy(list);\n *\n *   //optionally, you can stub out some methods:\n *   when(spy.size()).thenReturn(100);\n *\n *   //using the spy calls <b>real</b> methods\n *   spy.add(\"one\");\n *   spy.add(\"two\");\n *\n *   //prints \"one\" - the first element of a list\n *   System.out.println(spy.get(0));\n *\n *   //size() method was stubbed - 100 is printed\n *   System.out.println(spy.size());\n *\n *   //optionally, you can verify\n *   verify(spy).add(\"one\");\n *   verify(spy).add(\"two\");\n * </pre>\n *\n * <h4>Important gotcha on spying real objects!</h4>\n *\n * 1. Sometimes it's impossible to use {@link Mockito#when(Object)} for stubbing spies. Example:\n *\n * <pre>\n *   List list = new LinkedList();\n *   List spy = spy(list);\n *\n *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)\n *   when(spy.get(0)).thenReturn(\"foo\");\n *\n *   //You have to use doReturn() for stubbing\n *   doReturn(\"foo\").when(spy).get(0);\n * </pre>\n *\n * 2. Watch out for final methods.\n * Mockito doesn't mock final methods so the bottom line is: when you spy on real objects + you try to stub a final method = trouble.\n * What will happen is the real method will be called *on mock* but *not on the real instance* you passed to the spy() method.\n * Typically you may get a NullPointerException because mock instances don't have fields initiated.\n *\n * <p>\n * See examples in javadoc for {@link Mockito} class\n *\n * @param object\n *            to spy on\n * @return a spy of the real object\n */\n"
      }
    },
    "contained_scope": "method",
    "bug_count": 3,
    "triggered_tests": {
      "0": {
        "test_path": "org.mockitousage.bugs.StubbingMocksThatAreConfiguredToReturnMocksTest",
        "test_method": "shouldAllowStubbingMocksConfiguredWithRETURNS_MOCKS",
        "test_code": "shouldAllowStubbingMocksConfiguredWithRETURNS_MOCKS() {\n        IMethods mock = mock(IMethods.class, RETURNS_MOCKS);\n        when(mock.objectReturningMethodNoArgs()).thenReturn(null);\n    }",
        "clean_err_msg": "org.mockito.exceptions.misusing.MissingMethodInvocationException: "
      }
    },
    "buggy_files": {
      "0": "src/org/mockito/internal/MockitoCore.java",
      "1": "src/org/mockito/Mockito.java"
    },
    "hunk_type": "multi_file_three_hunks",
    "hunk_mapping": {
      "0": [
        {
          "start_line": 32,
          "end_line": 35,
          "file": "src/org/mockito/internal/MockitoCore.java",
          "code": "<START_BUG>\n    public <T> T mock(Class<T> classToMock, MockSettings mockSettings, boolean shouldResetOngoingStubbing) { return mock(classToMock, mockSettings); }\n    public <T> T mock(Class<T> classToMock, MockSettings mockSettings) {\n        mockingProgress.validateState();\n            mockingProgress.resetOngoingStubbing();\n<END_BUG>"
        }
      ],
      "1": [
        {
          "start_line": 827,
          "end_line": 827,
          "file": "src/org/mockito/Mockito.java",
          "code": "<START_BUG>\n        return MOCKITO_CORE.mock(classToMock, mockSettings);\n<END_BUG>"
        }
      ],
      "2": [
        {
          "start_line": 899,
          "end_line": 899,
          "file": "src/org/mockito/Mockito.java",
          "code": "<START_BUG>\n                .defaultAnswer(CALLS_REAL_METHODS)); \n<END_BUG>"
        }
      ]
    },
    "bug_report": {
      "url": "https://code.google.com/archive/p/mockito/issues/151",
      "bug_description": "Stubbing mocks that are configured to return mocks yields exception",
      "title": ""
    }
  }
}